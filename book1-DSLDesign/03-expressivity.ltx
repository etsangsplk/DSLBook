\FloatBarrier

\section{Expressivity}

 
\noindent One of the fundamental advantages of domain-specific languages is
increased expressivity over more general programming languages. Increased
expressivity typically means that programs are shorter, and that the semantics
are more readily accessible to processing tools (we will get back to this). By
making assumptions about the domain of application and encapsulating knowledge
about the domain in the language and in its execution strategy (and not just in
programs), programs expressed using a DSL can be significantly more concise.

\cooling{Cooling algorithms expressed with the cooling DSL are ca. five times
shorter than the C version that is generated from them.}

While it is always possible to produce short but incomprehensible programs,
overall, shorter programs require less effort to read and write than longer
programs, and should therefore be more efficient in software engineering. We
will thus assume that, all other things being equal, shorter programs are
preferable over longer programs.\footnote{The size of a program may not
be the only relevant metric to asses the usefulness of a DSL. For example, if the
DSL required only a third of the code to write, but it takes four times as long
to write the code per line, the there is no benefit for writing programs.
However, often when reading programs, less code is clearly a benefit. So it
depends on the ratio between writing and reading code whether a DSL's
conciseness is important.}.

The Kolomogorov complexity \cite{LiVitanyi2008} of an object is the smallest
program in some description language that produces the object. In our case the
objects of interest are programs in $P$ and we are interested in designing
languages that minimize the size of encodings of programs. We use
the notation $|p_L|$ to indicate the size of program $p$ as encoded in
language~$L$\sidenote{We will abstract over the exact way to measure the size of
a program, which can be textual lines of code or nodes in a syntax tree, for
example.}. The essence is the assumption that, within one language, more complex
programs will require larger encodings. We also assume that $p_L$ is the
smallest encoding of $p$ in $L$, i.e. does not contain dead or convoluted code.
We can then qualify the expressivity of a language relative to another language.

\begin{center}
   A language $L_1$ is \emph{more expressive} than a language $L_2$
   ($L_1 \prec L_2$), \\ if for each $p \in P_{L_1} \cap P_{L_2}$, $|p_{L_1}| < |p_{L_2}|$. 
\end{center}

\noindent Typically, we need to qualify this statement and restrict it to the
domain of interest.

\marginnote{Note that optimizing a DSL too far towards conciseness may limit the
DSL's ability to cover a substantial part of the relevant programs in the
domain, making the DSL useless. We discuss coverage in \sect{coverage}.}
\begin{center}
A language $L_1$ is \emph{more expressive in domain $D$} than a
language $L_2$ ($L_1 \prec_D L_2$), \\ if for each $p \in P_D \cap P_{L_1}
\cap P_{L_2}$, $|p_{L_1}| < |p_{L_2}|$.
\end{center}

\noindent A weaker but more realistic version of this statement requires that a
language is \emph{mostly} more expressive, but may not be in corner cases: DSLs
may optimize for the common case and may require code written in a more general
language to cover the corner cases\footnote{We discuss this aspect in the section
on completeness (\sect{sect:completeness}).}.


\newthought{DSLs are more expressive} than GPLs in the domain they are built
for. But there is also a disadvantage: before being able to write these concise
programs, users have to learn the language. This task can be separated into
learning the domain itself, and learning the syntax of the language. For people
who know the domain, learning the syntax can be simplified by using good IDEs
with code completion and quick fixes, as well as with good, example-based
documentation. In many cases, DSL users already know the domain, or would have
to learn the domain even if no DSL were used. Learning the domain is independent
of the language itself. It is easy to see, however, that, if a domain is
supported by well-defined language, this can be a good reference for the domain
itself. Learning a domain can be simplified by working with a good DSL. 

\pension{The users of the pension DSL are pension experts. Most of them have
spent years describing pension plans using prose text, tables and (informal)
formulas. The DSL provides formal languages to express that same knowledge
about the domain.}

The same is true for the act of \emph{building} the DSL. The domain has to be
scoped, fully explored and systematically structured to be able to build a
language that covers that domain. This leads to a deep understanding of the
domain itself.

\cooling{Building the cooling DSL has helped the thermodynamicists and software
developers to understand the domain, its degrees of freedom and the variability
in refrigerator hardware and cooling algorithms. Also, the architecture of the
to-be-generated C application that will run on the device became much more
well-structured as a consequence of the separation between reusable frameworks,
device drivers and generated code.}




\subsection{Expressivity and the Domain Hierarchy}

In the definition of expressivity above we are comparing arbitrary languages.
The central idea behind domain-specific languages is that progressive
specialization of the domain enables progressively more expressive languages.
Programs for domain $D_n \subset D_{n-1}$ expressed in a language $L_{D_{n-1}}$
typically use a set of characteristic idioms and patterns. A language for $D_n$
can provide linguistic abstractions for those idioms or patterns, which makes
their expression much more concise and their analysis and translation less
complex.

\embc{Embedded C extends the C programming language with concepts for embedded
software including state machines, tasks, and physical quantities. The state
machine construct, for example, has concepts representing states, events,
transitions and guards. Much less code is required compared to switch/case
statements or cross-pointing integer arrays, two typical idioms for state
machine implementation in C. Program analysis, such as finding states
that can never be left because no transition leads out of them, is trivial.}




\exwebdsl{WebDSL entity declarations abstract over the boilerplate code required
by the Hibernate framework for annotating Java classes with object-relational
mapping annotations. This reduces code size by an order of
magnitude~\cite{Visser07}.}


\subsection{Linguistic vs. In-Language Abstraction} 
\label{lingvsinlang}

\paragraph{Linguistic Abstraction} By making the concepts of $D$ first class
members of a language $L_D$, i.e. by definining linguistic abstractions for
these concepts, they can be uniquely identified in a $D$ program and their
structure and semantics is well defined. No semantically relevant\sidenote{By
"semantically relevant" we mean that the tools needed to achieve the model
purpose (analysis, translation) have to treat these cases specially.} idioms or
patterns are required to express interesting programs in $D$. Consider the two
examples of loops in a Java-like language:

\footnotesize
\begin{verbatim} 
  int[] arr = ...                         int[] arr = ...
  for (int i=0; i<arr.size(); i++) {      List<int> l = ... 
      sum += arr[i];                      for (int i=0;  i<arr.size(); i++) { 
  }                                           l.add( arr[i] );
                                          }
\end{verbatim}
\normalsize

The left loop can be parallelized, since the order of summing up the array
elements is irrelevant. The right one cannot, since (we presume) the order of
the elements in the \lcr{List} class is relevant. A transformation engine that
translates and optimizes the programs must perform (sophisticated, and sometimes
impossible) program analysis to determine that the left loop can indeed be
parallelized. The following alternative expression of the same behaviour uses
better linguistic abstractions, because it is clear without analysis that the
first loop can be parallelized and the second cannot\marginnote{The property of
a language $L_D$ of having first-class concepts for abstractions relevant in $D$
is often called \emph{declarativeness}: no sophisticated pattern matching or
program flow analysis is necessary to capture the semantics of a program
(relative to the purpose), and treat it correspondingly.}. The decision can
simply be based on the language concept used (\lcr{for} vs. \lcr{seqfor})

\footnotesize
\begin{verbatim} 
    for (int i in arr) {             seqfor (int i in arr) { 
        sum += i;                        l.add( arr[i] );
    }                                }
\end{verbatim}
\normalsize


\embc{State machines are represented with first class concepts. This enables
code generation, as well as meaningful validation. For example, it is easy to
detect states that are not reached by any transition and report this as an
error. Detecting this same problem in a low-level C implementation requires
sophisticated analysis on the switch-case statements or indexed arrays that
constitute the implementation of the state machine.}

Linguistic abstraction also means that no details irrelevant to the model
purpose are expressed. Once again, this increases conciseness, and avoids the
undesired specification of unintended semantics (over-specification).
Overspecification is bad because it limits the degrees of freedom available to a
transformation engine. In the example above, the loop A is over-specified: it
expresses ordering of the operations, although this is (most likely) not
intended by the person who wrote the code.

\embc{State machines can be implemented as switch/case blocks or as arrays
pointing into each other. The DSL program does not specify which implementation
should be used and the transformation engine is free to chose the more
appropriate representation, for example, based on desired program size or
performance characteristics. Also, log statements and task declarations can be
translated in different ways depending on the target platform.}



\begin{marginfigure}
  \includegraphics[width=5cm]{figures/embc/components.png}
  \caption{Example component diagram. The top half defines components, their
  ports and the relationship of these ports to interfaces. The bottom half
  shows instances whose ports are connected by a connector.}
  \label{components}
\end{marginfigure}
\embc{Another good example is optional ports in components. Components (see
\fig{components}) define required ports that specify the interfaces they \emph{use}. For each component
instance, a required port is connected to the provided port of an instance of a
component that provides a port with a compartible interfaces. Required ports my
be optional, so for a given instance, it may be connected or not. Invoking an
operation on an unconnected required port would result in an error, so this has
to be prevented. This can be done by enclosing the invocation on a required
port in an if statement, chechking whether the port is connected. However, an
if statement can contain any arbitrary boolean expression as its condition 
(e.g. \ic{if (isConnected(port) || true) \{ port.doSomething(); \}}). So
checking \emph{statically} that the invocation only happens if the port is connected is
impossible. An better solution based on linguistic abstraction is to introduce a
new language concept that checks for a connected port directly: 
\ic{with port (port) \{ port.doSomething(); \}}. The \lcr{with port}
statement doesn't use a complete expression as its argument, but only a reference to a
an optional required port (\fig{optionalport}). This way, the IDE can check that
an invocation on a required optional port \lcr{port} is only done inside of a \lcr{with port}
statement on that same port.}

\begin{figure}[h]
\begin{center}
  \includegraphics[scale=1]{figures/embc/optionalport.png}
  \caption[labelInTOC]{The \lcr{with port} statement is required to surround an
  invocation on an optional, required port. If the port is not connected for
  the current instance, the code inside the \lcr{with port} is not executed. It
  acts as an \lcr{if} statement, but since it cannot contain a complete
  expression, the correct use of the \lcr{with port} statement can be
  statically checked.}
  \label{optionalport}  
\end{center}
\end{figure}


\paragraph{In-Lanuguage Abstraction} Conciseness can also be achieved by a
language providing facilities to define new (non-linguistic) abstractions in
programs. \marginnote{GPL concepts for building new abstractions include
procedures, classes, or functions and higher-order functions.}
It is \emph{not} a sign of a bad DSL if it has in-language abstraction
mechanisms as long as the created abstractions don't require special treatment
by analysis or processing tools --- at which point they should be refactored
into linguistic abstractions.

\cooling{The language does not support the construction of new abstractions
since its user community are non-programmers who are not familiar with defining
abstractions. As a consequence, the language had to be modified several
times during development as new requirements came up from the end users, and had
to be integrated directly into the language.}

\embc{Since C is extended, C's abstraction mechanisms (functions, structs,
enums) are available. Moreover, we added new mechanisms for building
abstractions including interfaces and components.}

\todo{refer tro the above optional port picture}

\exwebdsl{WebDSL provides \emph{template definitions} to capture partial web
pages including rendering of data from the database and form request handling.
User defined templates can be used to build complex user interfaces.}

\paragraph{Standard Library} If a language provides support for in-language
abstraction, these facilities can be used by the language \emph{designer} to
provide functionality to language users. Instead of adding language features, a
standard library is deployed along with the language to all its
users\marginnote{This approach is of course well known from programming
languages. All of them come with a standard library, and the language can hardly be used without relying on it. It
is effectively a part of the language}. This approach keeps the language itself
small, and allows subsequent extensions of the library without changing the
language definition and processing tools.

\cooling{Hardware building blocks have properties. For example, a \lcr{fan}
can be turned \lcr{on} or \lcr{off}, and for a \lcr{compressor}, the
\lcr{rpm} can be specified. The set of properties available for the various
building blocks is defined via a standard library and is not part of the
language. This way, if a new device driver supports a new property, it can be
made available to cooling programs without changing and redeploying the
language.}

\paragraph{Linguistic vs. In-Language Abstraction} A language that contains
linguistic abstractions for all relevant domain concepts is simple to transform;
the transformation rules can be tied to the identities of the language concepts.
It also makes the language suitable for domain experts, because relevant domain
concepts have a direct representation in the language. Code completion can
provide specific and meaningful support for "exploring" how a program should be
written. However, using linguistic abstractions extensively requires that the
relevant abstractions be known in advance, or frequent evolution of the language
is necessary. In-language abstraction is more flexible, because users can build
just those abstractions they need. However, this requires that users are
actually trained to build their own abstractions. This is often true for
programmers, but it is typically not true for domain experts.

Using a standard library may be a good compromise where one set of users
develops the abstractions to be used by another set of developers. This is
especially useful if the same language should be used for several, related
projects or user groups. Each can build their own set of abstractions in the
library. It should be kept in mind that in-language abstraction only works if
the transformation of these abstractions is not specific to the abstraction. In
such case, linguistic abstraction is better suited. \marginnote[-2cm]{Modular
language extension, as discussed later in \sect{lext}, provides a middle ground
between the two approaches. A language can be flexibly extended, while
retaining the advantages of linguistic abstraction.} 


\subsection{Language Evolution Support}

If a language uses a lot of linguistic abstraction, it is likely, especially
during the development of the language, that these abstractions change. Changing
language constructs may break existing models, so special care has to be taken
regarding language evolution.

Doing this requires any or all of the following: a strict configuration
management discipline, versioning information in the models to trigger
compatible editors and model processors, keeping track of the language changes
as a sequence of change operations that can be "replayed" on existing models, or
model migration tools to transform models based on the old language into the new
language.

Whether model migration is a challenge or not depends on the tooling. There are
tools that make model evolution a very smooth, but many environments
don't\marginnote{In parser-based languages, you can always at the very least
open the file in a text editor and run some kind of global search/replace to
migrate the program. In projectional editor, special care has to be taken to
enable the same functionality.}. Consider this when deciding about the tooling
you want to use! 

It is always a good idea to minimize those changes to a DSL that break existing
models. Backward-compatibility and deprecation are techniques well worth keeping
in mind when working with DSLs. For example, instead of just changing an
existing concept in an incompatible way, you may add a new concept in addition
to the old one, along with deprecatio of the old one and a migration script or
wizard. Note that you might be able to instrument your model processor to
collect statistics on whether deprecated language features continue to be used.
Once no more instances show up in models, you can safely remove the deprecated
language feature..

If the DSL is used by a closed, known user community that is accessible to the
DSL designers, it will be much easier to evolve the language over time because
users can be reached, making them migrate to newer versions\sidenote{The
instrumentation mentioned above may even report back uses of deprecated language
features after the official expiration date.}. Alternatively, the set of all
models can be migrated to a newer version using a script provided by the
language developers. In case the set of users, and the DSL programs, are not easily
accessible, much more effort must be put into keeping backward compatibility,
the need for evolution should be reduced\sidenote{This is the reason why many
GPLs can never get rid of deprecated language features.}.

Using a set of well-isolated viewpoint-specific DSLs prevents rippling effects
on the overall model in case something changes in one DSL.


\subsection{Configuration vs. Customization}

Note the difference between configuration and customization. A customization DSL
provides a vocabulary which you can creatively combine into sentences of
potentially arbitrary complexity. A configuration DSL consists of a well-defined
set of parameters for which users can specify values\marginnote{Think: feature
models. We will elaborate on this in the section of product lines}\todo{ref}.
Configuration languages are more limited, since you cannot easily express
instantiation and the relationship between things. However, they are also
typically less complex. Hence, the more you can lean towards the configuration
side, the easier it usually is to build model processors. It is also simpler
from the user's perspective, since the apparent complexity is limited.

\subsection{Precision vs. Algorithm}

Be aware of the difference between precision and algorithmic completeness. Many
domain experts are able to formally and precisely specify facts about their
domain (the "what" of a domain) while they are not able to define
(Turing-complete) algorithms to implement the system (the "how"). It is the job
of software developers to provide a formal language for domain users to express
facts, and then to implement generators and interpreters to map those facts into
executable algorithms that truthfully implement the facts they expressed. The
DSL expresses the "what", the model processor adds the "how". Consider creating
an incomplete language (\sect{sect:completeness}), and have developers fill in
the algorithmic details in GPL code.

\pension{Pension rules are declarative in the sense that a set of mathematical
equations and calculation rules are defined. The code generator, written by
developers, creates a scalable and sufficiently fast optimization from the
models.}
