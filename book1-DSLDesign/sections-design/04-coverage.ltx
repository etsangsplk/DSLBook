\FloatBarrier

\section{Coverage}
\label{coverage}

 

\marginnote[0.35cm]{Note that we can achieve full coverage by making $L$
\emph{too general}. Such a language, may, however, be less expressive, resulting
in bigger (unnecessarily big) programs. Indeed this is the reason for designing
DSLs in the first place: general purpose languages are too general.} A language
$L$ always defines a domain $D$ such that $P_D = P_L$. Let's call this domain
$D_L$, i.e.~the domain determined by $L$. This does not work the other way
around. Given a (deductively defined) domain $D$ there is not necessarily a
language that \emph{fully covers} that domain unless we revert to a universal
language at a $D_0$ (cf. the hierarchical structure of domains and languages).

\begin{quote}
A language $L$ \emph{fully covers} domain $D$, if for each program $p$ relevant
to the domain $P_D$ a program $p_L$ can be written in $L$. In other words, $P_D
\subseteq P_L$.
\end{quote}

  
Full coverage is a Boolean predicate; a language either fully covers a domain or
it does not. In practice, many languages do not fully cover their respective
domain. We would like to indicate the \emph{coverage ratio}. The domain coverage
ratio of a language $L$ is the portion of programs in a domain~$D$ that it can
express. We define $C_D(L)$, \emph{the coverage of domain $D$ by language $L$},
as
$$ C_{D}(L) = \dfrac{number\;of\;P_D\;programs\;expressable\;by\;L}{number\;
of\;programs\;in\;domain \;D}$$

At first glance, an ideal DSL will cover all of its domain ($C_D(L_D)$ is
100\%). It requires, however, that the domain is well-defined and we can
actually know what full coverage is. Also, over time, it is likely that the
domain evolves and grows, and the language has to be continuously evolved to
retain full coverage. \marginnote{As the domain evolves, language evolution has
to keep pace, requiring responsive DSL developers. This is an important process
aspect to keep in mind!}

In addition to the evolution-related reason given above, there are two reasons
for a DSL \emph{not} to cover all of its \emph{own} domain $D$. First, the
language may be deficient and needs to be redesigned. This is especially likely
for new and immature DSLs. Scoping the domain for which to build a DSL is an
important part of DSL design.

Second, the language may have been defined expressly to cover only a subset of
$D$, typically the subset that is most commonly used. Covering all of $D$ may
lead to a language that is too big or complicated for the intended user
community because of its support for rarely used corner cases of the
domain\footnote{Incremental language extension provides a third option: you can
put the common parts into the base language and the support for the corner cases
into optionally included language modules.}. In this case, the remaining parts
of $D$ may have to be expressed with code written in $D_{-1}$ (see also
\sect{sect:completeness}). This requires coordination between DSL users and
$D_{-1}$ users, if this not the same group of people.

\exwebdsl{WebDSL defines web pages through "page definitions" which have formal
parameters. \ic{navigate} statements generate links to such pages. Because of
this stylized idiom, the WebDSL compiler can check that internal links are to
existing page definitions, with arguments of the right type. The price that the
developer pays is that the language does not support free form URL construction.
Thus, the language cannot express all types of URL conventions and does not have
full coverage of the domain of web applications.}
 
\cooling{After trying to write a couple of algorithms, we had to add a
\ic{perform \ldots after t} statement to run a set of statements after a
specified time \ic{t} has elapsed. In the initial language, this had to be done
manually with events and timers. Over time we noticed that this is a very 
typical case, so we added first-class support.}

\embc{Coverage of this set of languages is full, although any particular
extension to C may only cover a part of the respective domain. However, even if
no suitable linguistic abstraction is available for some domain concept, it can
be implement in the $D_0$ language C, while retaining complete syntactic and
semantic integration. Also, additional linguistic abstractions can be easily
added because of the extensible nature of the overall approach.}





