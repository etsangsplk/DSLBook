\subsection{Implementation Challenges and Solutions}
\label{challenges}

The previous subsections discussed four strategies for language composition. In
this section we describe some of the challenges regarding syntax, type systems
and transformations for these four strategies.

\parhead{Syntax} Referencing and Reuse keeps fragments homogeneous. Mixing of
concrete syntax is not required. A reference between fragments is usually simply
an identifier and does not have its own internal structure for which a grammar
would be required\sidenote{Sometimes the reference use qualified names, in which
case the strings use dots and colons. However, this is still a trivial token
structure, so it is acceptable to define the structure separately in both
languages.}. The name resolution phase can then create the actual
cross-reference between abstract syntax objects.

\cooling{The algorithm language contains cross-references into the hardware language.
Those references are simple, dotted names such as \ic{compartment1.valve}.}

\genex{In the UI example, the adapter language simply introduces dotted names to
refer to fields of data structures.}

\noindent Extension and Embedding requires modular concrete syntax definitions
because additional language elements must be "mixed" with programs written with
the base/host language. As we discuss in Part III (mostly in \sect{syntaximpl}),
combining independently developed languages after the fact can be a problem:
depending on the parser technology, the combined grammar may not be parsable
with the parser technology at hand. There are parser technologies that do not
exhibit this problem, and projectional editors avoid it by definition. However,
several widely used language workbenches have problems in this respect. For more
details.


\embc{State machines are hosted in regular C programs. This works because the C
language's \ic{Module} construct contains a collection of
\ic{IModuleContents}, and the \ic{StateMachine} concept implements the
\ic{IModuleContent} concept interface. This state machine language is designed
specifically for being embedded into C, so it can access and extend 
\ic{IModuleContent} (\fig{statemachinmodules}). If the state machine
language were embeddable in any host language in addition to C, this dependency
on \ic{ModuleContent} (from the C base language) would not be allowed. An
adapter language would have to be created which adapts a \ic{StateMachine} to
\ic{IModuleContent}.}
\begin{marginfigure}[-20mm]
  \includegraphics[width=5cm]{figures-design/embc/statemachinmodules.png}
  \caption{The core language (above the dotted line) defines an interface
  \icsn{IModuleContent}. Anything that should be hosted inside a \icsn{Module}
  has to implement this interface, typically from another language.
  \icsn{StateMachines} are an example.} 
  \label{statemachinmodules}
\end{marginfigure}


\parhead{Type Systems} For Referencing, the type system rules and constraints
of the referencing language typically have to take into account the referenced
language. Since the referenced language is known when developing the referencing
language, the type system can be implemented with the referenced language in
mind as well. 

\cooling{In the refrigerator example, the algorithm language defines typing
rules for hardware elements (from the hardware language), because these types
are used to determine which properties can be accessed on the hardware elements
(e.g.,~a compressor has a property \ic{active} that controls if it is turned on
or off).}

\noindent In case of Extension, the type systems of the base language must be
designed in a way that allows adding new typing rules in language extensions. For example,
if the base language defines typing rules for binary operators, and the
extension language defines new types, then those typing rules may have to be
overridden to allow the use of existing operators with the new types. 

\embc{A language extension provides types with physical units (as in \ic{100 kg}).
Additional typing rules are needed to override the typing rules for C's basic
operators (+, -, *, /, etc.). MPS supports declarative type system
specification, so you can just \emph{add} additional typing rules for the case
where one or both of the arguments have a type with a physical unit.}

\noindent For Reuse and Embedding, the typing rules that affect the interplay
between the two languages reside in the adapter language. The type systems of both languages
must be extensible in the way described in the previous paragraph on Extension.

\genex{In the UI example the adapter language will have to adapt the data types
of the fields in the data description to the types the UI widgets expect. For
example, a combo box widget can only be bound to fields that have some kind of
text or enum data type. Since the specific types are specific to the data
description language (which is unknown at the time of creation of the UI
language), a mapping must be provided in the adapter language.}


\parhead{Transformation} In this section we use the terms
\emph{transformation} and \emph{generation} interchangably. In general, the term
transformation is used if one tree of program elements is mapped to another
tree, while generation describes the case of creating text from program trees.
However, for the discussions in this section, this distinction is generally not
relevant.

\begin{marginfigure}[42mm]
  \includegraphics[width=3cm]{figures-design/referencingCaseA.png}
  \caption{Referencing: Two separate, dependent, single-source transformations}
  \label{referencingCaseA}
\end{marginfigure}

Three cases have to be considered for Referencing. The first one
(\fig{referencingCaseA}) propagates the referencing structure to the target
fragments. We call these two transformations \emph{single-sourced}, since each
of them only uses a single, homogeneous fragment as input and creates a single,
homogeneous fragment as output, typically with references between them. Since
the referencing language is created with the knowledge about the referenced
language, the generator for the referencing language can be written with
knowledge about the names of the elements that have to be referenced in the
fragment generated from the referenced fragment. If a generator for the
referenced language already exists, it can be reused unchanged. The two
generators basically share knowledge about the names of generated elements.

\comparch{In the types viewpoint, interfaces and components are defined. The
types viewpoint is independent, and it is sufficient for the generation of the
code necessary for implementing component behavior: Java base classes are
generated that act as the component implementations (expected to be extended by
manually written subclasses). A second, dependent viewpoints describes component
instances and their connections;it depends on the types viewpoint. A third one
describes the deployment of the instances to execution nodes (servers,
essentially). The generator for the deployment viewpoint generates code that
actually instantiates the classes that implement components, so it has to know
the names of those generated (and hand-written) classes.}
  
\begin{marginfigure}[2mm]
  \includegraphics[width=3cm]{figures-design/referencingCaseB.png}
  \caption{A single multi-sourced transformation.}
  \label{referencingCaseB}
\end{marginfigure}
\noindent The second case (\fig{referencingCaseB}) is a multi-sourced
transformation that creates one single homogeneous fragment. This typically occurs if the
referencing fragment is used to guide the transformation of the referenced
fragment, for example by specifying transformation strategies (annotation
models). In this case, a new transformation has to be written that takes the
referencing fragment into account. The possibly existing generator for the
referenced language cannot be reused as is.

\cooling{The refrigerator example uses this case. The code generator that
generates the C code that implements the cooling algorithm takes into account
the information from the hardware description model. A single fragment is
generated from the two input models. The generated code is C-only, so the
fragment remains homogeneous.}


\begin{marginfigure}
  \includegraphics[width=3cm]{figures-design/referencingCaseC.png}
  \caption{A preprocessing transformation that changes the referenced fragment in a way
specified by the referencing fragment}
  \label{referencingCaseC}
\end{marginfigure}
\noindent The third case, an alternative to rewriting the generator, is the use
of a preprocessing transformation (\fig{referencingCaseC}), that changes the
referenced fragment in a way consistent with what the referencing fragment
prescribes. The existing transformations for the referenced fragment can then be
reused.


\seppar As we have discussed above, language extensions are usually created
by defining linguistic abstractions for common idioms of a domain $D$. A
generator for the new language concepts can simply recreate those idioms when
mapping $L_D$ to $L_{D-1}$, a process also called assimilation. In other words,
transformations for language extensions map a heterogeneous fragment (containing
$L_{D-1}$ and $L_D$ code) to a homogeneous fragment that contains only $L_{D-1}$
code (\fig{transExtension}). In some cases additional files may be generated,
often configuration files. In any case, the subsequent transformations for
$L_{D-1}$, if any, can be reused unchanged.

\begin{marginfigure}[-40mm]
  \includegraphics[width=5cm]{figures-design/transExtension.png}
  \caption{Extension: transformation usually
  happens by assimilation, i.e.~generating code in the host language from code
  expressed in the extension language. Optionally, additional files are
  generated, often configuration files.}
  \label{transExtension} 
\end{marginfigure} 


\embc{State machines are generated down to a function that contains a \ic{switch}
statement, as well as \ic{enum}s for states and events. Then the existing C-to-text
transformations are reused unchanged. In addition, the state machines are also
transformed into a dot file that is used to render the state machine
graphically via graphviz.}


\noindent Sometimes a language extension requires rewriting transformations
defined by the base language. In this case, the transformation engine must support
\emph{overriding} transformations by transformations defined in another
language.

\embc{In the data-types-with-physical-units example, the language also provides
range checking and overflow detection. So if two such quantities are added, the
addition is transformed into a call to a special \ic{add} function instead of
using the regular plus operator. This function performs overflow checking and
addition. MPS supports transformation priorities that can be used to override
the existing transformation with a new one.}

\noindent Language Extension introduces the risk of semantic interactions. The
transformations associated with several independently developed extensions of
the same base language may interact with each other. To avoid the problem,
transformations should be built in a way so that they do not "consume scarce
resources" such as inheritance links.\sidenote[][-4\baselineskip]{It would be
nice if DSL tools would detect such conflicts statically, or at least supported a way of marking
two languages or extensions as \emph{incompatible}. However, none of the tools
I know support such features.}

\genex{Consider the (somewhat constructed) example of two extensions to Java
that each define a new statement. When assimilated to pure Java, both new
statements require the surrounding Java class to extend a specific, but
different base class. This won't work because a Java class can only extend one
base class.}

\noindent Interactions may also be more subtle and affect memory usage or
execution performance. Note that this problem is not specific to languages, it can occur
whenever several independent extensions of a something can be used together,
ad hoc. A more thorough discussion of the problem of semantic interactions is
beyond the scope of this book.

\seppar In the Reuse scenario, it is likely that both the reused and the
context language already come with their own generators. If these generators
transform to different, incompatible target languages, no reuse is possible. If
they transform to a common target languages (such as Java or C) then the
potential for reusing previously existing transformations exists.

\begin{marginfigure}[-100mm]
  \includegraphics[width=4cm]{figures-design/reuseCaseA.png}
  \caption{Reuse: Reuse of existing transformations for both fragments plus
  generation of adapter code}
  \label{reuseCaseA} 
\end{marginfigure} 

There are three cases to consider. The first one, illustrated in
\fig{reuseCaseA}, describes the case where there is an existing transformation
for the reused fragment and an existing transformation for the context fragment
--- the latter being written with the knowledge that later extension will be
necessary. In this case, the generator for the adapter language may "fill in the
holes" left by the reusable generator for the context language. For example,
the generator of the context language may generate a class with abstract
methods; the adapter may generate a subclass and implement these abstract
methods. 

\begin{marginfigure}[-95mm]
  \includegraphics[width=4cm]{figures-design/reuseCaseB.png}
  \caption{Reuse: composing transformations}
  \label{reuseCaseB} 
\end{marginfigure} 


In the second case, \fig{reuseCaseB}, the existing generator for the
reused fragment has to be enhanced with transformation code specific to the
context language. A mechanism for composing transformations is needed. 

\begin{marginfigure}[-30mm]
  \includegraphics[width=4cm]{figures-design/reuseCaseC.png}
  \caption{Reuse: generating
  separate artifacts plus a weaving specification}
  \label{reuseCaseC} 
\end{marginfigure} 


The third case, \fig{reuseCaseC}, leaves composition to the target
languages. We generate three different independent, homogeneous fragments, and a
some kind of weaver composes them into one final, heterogeneous artifact. Often,
the weaving specification is the intermediate result generated from the adapter
language. An example implementation could use AspectJ.



\seppar An embeddable language may not come with its own generator, since, at
the time of implementing the embeddable language, one cannot know what to
generate --- its purpose is to be embedded! In that case, when embedding the
language, a suitable generator has to be developed. It will typically either
generate host language code (similar to generators in the case of language
extension) or directly generate to the same target language that is generated to
by the host language.

\begin{marginfigure}
  \includegraphics[width=5cm]{figures-design/transEmbedding.png} 
  \caption{In transforming embedded languages, a new transformation
  has to be written if the embedded language does not come with a
  transformation for the target language of the host language transformation.
  Otherwise the adapter language can coordinate the transformations for the
  host and for the emebedded languages.}
  \label{transEmbedding}  
\end{marginfigure}  

If the embeddable language comes with a generator that transforms to the same
target language as the embedding language, then the generator for the
adapter language can coordinate the two, and make sure a single, consistent
fragment is generated. \fig{transEmbedding} illustrates this case.

Just as language extension, language embedding may also lead to semantic
interactions if multiple languages are embedded into the same host language. 

