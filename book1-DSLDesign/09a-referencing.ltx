\subsection{Language Referencing}

Language referencing (\fig{langReferencing}) enables \emph{homogeneous}
fragments with cross-references among them, using \emph{dependent} languages.
 
A fragment $f_2$ depends on $f_1$. $f_2$ and $f_1$ are expressed with different
languages $l_2$ and $l_1$. The referencing language $l_2$ depends on the
referenced language $l_1$ because at least one concept in the $l_2$ references a
concept from $l_1$. We call $l_2$ the \emph{referencing} language, and $l_1$ the
\emph{referenced} language. While equations (2) and (3) continue to hold, (1)
does not. Instead
\begin{align}
\forall r \in \mathit{Refs_{l_2}} \mid   
   \mathit{lo(r.from)} = l_2\; \wedge \; \mathit{lo(r.to)} = (l_1 \vee  l_2)
\end{align}
                                  
(we use $x=(a \vee b)$ as a shorthand for $x = a \vee x = b$).                            

\begin{figure}[h]
\begin{center}
  \includegraphics[width=9cm]{figures/langReferencing.png} 
  \caption[labelInTOC]{Referencing: Language $l_2$ depends on $l_1$, because
  concepts in $l_2$ reference concepts in $l_1$. (We
  use rectangles for languages, circles for language concepts, and UML
  syntax for the lines: dotted = dependency, normal arrows = associations,
  hollow-triangle-arrow for inheritance.)} 
  \label{langReferencing}  
\end{center} 
\end{figure} 

\paragraph{Viewpoints} As we have discussed before, a domain $D$ can be composed
from different concerns. One way of dealing with this is to define a separate
concern-specific DSLs, each addressing one or more of the domain's concerns. A
program then consists of a set of concern-specific fragments, that relate to
each other in a well-defined way using language referencing. The latter approach
has the advantage that different stakeholders can modify "their" concern
independent of others. It also allows reuse of the independent fragments and
languages with different referencing languages. The obvious drawback is that for
tightly integrated concerns the separation into separate fragments can be a
usability problem.

\fountain{As an example, consider the domain of refrigerator configuration. The
domain consists of four concerns. The first concern $H$ describes the hardware
structure of refrigerators appliances including compartments, compressors, fans,
vents and thermometers. The second concern $A$ describes the cooling algorithm
using a state-based, asynchronous language. Cooling programs refer to hardware
building blocks and access the their properties in expressions and commands. The
third concern is testing $T$. A cooling test can test and simulate cooling
programs. The fourth concern $P$ is parametrization, used to configure a
specific hardware and algorithm with different settings, such as the actual
target cooling temperature. The dependencies are as follows: $A \rightarrow H, T
\rightarrow A, P \rightarrow A$. Each of these concerns are implemented as a
separate language with references between them. $H$ and $A$ are separated
because $H$ is defined by product management, whereas $A$ is defined by
thermodynamicists. Also, several algorithms for the same hardware must be
supported, which makes separate fragments for $H$ and $A$ useful. $T$ is
separate from $A$ because tests are not strictly part of the product definition
and may be enhanced after a product has been released. Finally, $P$ is separate,
because the parameters have to be changed by technicians in the field, and
several parametrizations for the same algorithm exist. These languages have been
built as part of a single project, so the dependencies between them are not a
problem.}

Referencing implies knowledge about the relationships of the languages as they
are designed. Viewpoints are the classical case for this. The depenent languages
\emph{cannot} be reused, because of the dependency on the other language.

\paragraph{Progressive Refinement} Progressive refinement, also introduced
earlier, also makes use of language referencing. 


 