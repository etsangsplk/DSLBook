                                 
\subsection{Language Embedding} 

Language embedding (\fig{langEmbedding}) enables \emph{heterogeneous} fragments
with \emph{independent} languages. It is similar to reuse in that there are two independent
languages $l_1$ and $l_2$, but instead of establishing references
between two homogeneous fragments, we now embed instances of concepts from $l_2$
in a fragment $f$ expressed with $l_1$, so
\begin{align}
\forall c \in \mathit{Cdn_f} \mid  \;
	&\mathit{lo(co(c.parent))} = l_1 \; \wedge \nonumber \\
	&\mathit{lo(co(c.child))} = (l_1 \vee l_2)
\end{align}
Unlike language extension, where $l_2$ depends on $l_1$ because concepts in
$l_2$ extends concepts in $l_1$, there is no such dependency in this case. Both
languages are independent. We call $l_2$ the \emph{embedded} language and $l_1$
the \emph{host} language. Again, an adapter language $l_A$ that extends $l_1$
can be used to achieve this, where
\begin{align}
\exists c \in \mathit{Cdn_{l_A}} \mid \mathit{lo(c.parent)} = 
	l_A \wedge \mathit{lo(c.child)} = l_1
\end{align}

\begin{figure}[h]
\begin{center} 
  \includegraphics[width=9cm]{figures-design/langEmbedding.png} 
  \caption{Embedding: $l_1$ and $l_2$ are independent languages.
  However, we still want to use them in the same fragment. To enable this, an 
  adapter language $l_A$ is
  added. It depends on both $l_1$ and $l_2$, and uses inheritance and
  composition to adapt $l_1$ to $l_2$ (this is the almost the same structure
  as in the case of reuse; the difference is that $B5$ now contains $A3$,
  instead of just referencing it.)}
  \label{langEmbedding}  
\end{center} 
\end{figure}


Embedding supports syntactic composition of independently developed languages. 
As an example, consider a state machine language that can be combined with any
number of programming languages such as Java or C. If the state machine
language is used together with Java, then the guard conditions used in the
transitions should be Java expressions. If it is used with C, then the
expressions should be C expressions. The two expression languages, or in fact,
any other one, must be embeddable in the transitions. So the state
machine language cannot depend on any particular expression language, and the
expression languages of C or Java obviously cannot be designed with knowledge
about the state machine language. Both have to remain independent, and have to
be embedded using an adapter language. 

When embedding a language, the embedded language must often be
extended as well. In the above example, new kinds of expressions must be added
to support referencing event parameters. These additional expressions will
typically reside in the adapter language as well.

\marginnote{Note that if the state machine language is specifically built to
"embed" C expressions, then this is a case of Language Extension, since the
state machine language depends on the C expression language.}

\exwebdsl{In order to support queries over persistent data, WebDSL embeds the
Hibernate Query Language (HQL) such that HQL queries can be used as
expressions. Queries can refer to entity declarations in the program and to
variables in the scope of the query.}

\pension{The pension workbench DSL embeds a spreadsheet language for expressing
unit tests for pension plan calculation rules.}


\parhead{Cross-Cutting Embedding, Metadata} A special case of embedding is
handling meta data. We define meta data as program elements that are not
essential to the semantics of the program, and are typically not handled by the
primary model processor. Nonetheless these data need to related to program
elements, and, at least from a user's perspective, they often need to be
embedded in programs. Since most of them are rather generic, embedding is the
right composition mechanism: no dependency to any specific language should be
necessary, and the meta data should be embeddable in any language. Example meta
data includes:

\begin{description}
  \item[Documentation] should be attachable to any program element, and in the
  documentation text, other program elements should be referencable. 
  \item[Traces] capture typed relationships between program elements or between
  program elements and requirements or other documentation ("this element
  \emph{implements} that requirement")
  \item[Presence Conditions] in product line engineering describe whether a
  program element should be available in the program for a given product
  configuration ("this procedure is only in the program in the
  \emph{international} variant of the product").
\end{description}

In projectional editors, this meta data can be stored in the program tree, and
shown only if switched on. In textual editors, meta data is often stored in
separate files, using pointers to refer to the respective model elements. The
data may be shown in hovers or views adjacent to the editor itself.

\embc{The system supports various kinds of meta data, including traces to
requirements and documentation. They are implemented with MPS' \emph{attribute}
mechanism which is discussed in part on MPS in section \sect{tools}. As a
consequence of how MPS attributes work, these meta data can be applied to
program elements defined in any arbitrary language.}
 
