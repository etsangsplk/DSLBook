* The DSLs in question still seem to be "big" relatively general languages. I'd really
  prefer to focus on somewhat smaller and narrower ones.
* some good literature in here
* DSLs aren't new .... but newer tools make it much less effort, so it can be used
  much more widely ... at least for smaller DSLs - see my first point.
* "In combination with an application li- brary, any GPL can act as a DSL."
  -> no!
* The abstractions are especially useful if they are statically checked - otherwise,
  one can just use a lib of f/w in a suitably "meta" language. Hence the focus on DSLs
  and their tools.
* They say a library is a DSEL. I disagree
* How will we handle executability? What does this mean? Ok - not executable, but formal
  enough to play a part in constructing (or specifying) an executable program.
* Is DSL development really harder than defining any reusable artifact (f/w)? I really
  really doubt it....! We shouldn't overemphasize the "hardness".
* "Obviously, adopting an existing DSL is much less expensive and requires much less expertise   
  than developing a new one!!
  -> but there might not be any. What can we do if we want domain users to get involved??
* Really a lot of good literature :-)
* I am not sure I agree with the paper's notion of "pattern". We shouldn't do this!!
* The (at least) first couple of "patterns" are at least good reasons/motivations for 
  developing DSLs.
* The Design section is more useful.
* There are terms for the relationship between DSLs and programming languages.
* I really dislike the very broad approach to DSLs, where templates in C++ and libraries
  are in scope. I am not sure this is useful. We shouldn't do that.
* I think we should feature the term "language workbench" prominently, to position
  our paper clearly in space and time.
* Again, we should emphasize the importance of tooling (IDE)