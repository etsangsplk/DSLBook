\section{Discussion}  
\label{discussion}

\subsection{Related Work}
\label{related}

Diomidis Spinessllis discusses a set of design patterns for DSLs
(\cite{Spinellis01:0}). Some of them relate directly to our work: the
\emph{Piggypack} pattern describes DSLs that are embedded in a GPL, and the DSL
constructs are mapped to GPL constructs for execution. The \emph{Pipeline}
pattern addresses the step-wise transformation of higher D programs into lower D
programs, which are subsequently translated further. He also defines
\emph{Language Extension} to mean that a language has additional features
compared to its base language, \emph{Language Specialization} removing concepts
from a base language. The rest of his paper looks at common use cases for DSLs
and DSL implementation techniques. Our work is different in that it aims at a
much more complete coverage of the design dimensions, and provides a conceptual
framework (the domain hierarchy and composition) to systematically describe
DSLs.

Mernik, Heering and Sloane's paper on How and When to Build a DSL
\cite{MernikHS05} provides a comprehensively broad, but relatively shallow
overview over the DSL space. It provides patterns that describe the decision
process that leads to building DSLs, then connects to some of the design
patterns from Spinellis' paper, and finally delves down into actual
implementation approaches. The paper also looks at a couple of supporting tools.
The strongest aspect of this work is the huge set of industry examples. Our work
is more restricted in that it covers only DSL design and not all the decision
process involved in DSL development. We also provide much more detail on the
core aspects of language design.

Just like in our paper, Zdun and Mark Strembeck (\cite{StrembeckZ09})
generalize from a set of DSLs of different sizes, contexts and target platforms.
However, instead of focusing on the design of the languages, they
focus on the activities involved in building the DSLs, leading to a tailorable
DSL engineering process. 

In their Worst Practices for Domain-Specific Modeling \cite{KellyP09}, Kelly and
Pohjonen discuss recurring problems in the implementation of graphical DSLs. The
worst practices are based on actual projects, mostly from Metacase customers.
Many of the bad practices are not directly relevant to designing (textual)
external DSLs, but help in getting a DSL-based development project set up well:
\emph{Analysis Paralysis} refers to "Wanting the language to be theoretically
complete, with its implementation assured" --- i.e. not enough pragmatism and
iteration during the design process. \emph{Lack of Domain Understanding}
addresses the problem of "Insufficiently understanding the problem or solution
domains". \emph{3GL: Visual Programming} refers to the pitfall of "Duplicating
the concepts and semantics of traditional programming languages" in the DSL.

Language modularization, composition and extension is an important aspect of DSL
design as we describe it in this paper. While building single external DSLs is a
pretty well understood and documented topic (as explained in Terence Parr's book
\cite{Parr:2010} and the user guides to the tools mentioned in this paper),
modularization, composition and extension of languages and IDEs are still an
area of active research. For example, KHEPERA \cite{FaithNP97} is a system for
progressively translating DSLs down along the D hierarchy. OpenJava
\cite{TatsuboriCIK99} and the Java Syntactic Extender \cite{BachrachP01} are
macro systems for Java that support the incremental extension of Java with
additional syntax. The extensions are translated back to the Java idioms from
which they abstract. In \cite{BravenboerDV07}, Bravenboer, Dolstra and Visser
discuss an approach for embedding of arbitrary guest languages into arbitrary
host languages. Xoc \cite{CoxBCKK08} and the Modular Embedded DSL
\cite{Voelter10} provide similar functionality for C. MontiCore
\cite{GronnigerKRSV08} supports the development of modular languages, where
binary composability, so no languge sources such as grammars are required for
composition. Finally, Hemel and Visser describe PIL \cite{HemelV09}, an
intermediate language intended as to be used as a reusable transformation
backend for DSLs - DSLs are transformed to PIL, reusing a set of existing
reusable PIL backend for several target languages.


% \EV{for another time}
% \todo{investigate: domains in model theory}
% 
% \paragraph{Program Size}
% 
% Question: how do we measure this?
% 
% \todo{MV: Only size, or also complexity? Or even effort spent to write the
% program? Or read it? Reference to general discussion about measuring program
% size/complexity?}
% 
% \todo{MV: See my comment above. I think LOC is not super useful, because it may
% take longer to write 5 lines of DSL code that 20 lines of GPL code (for some
% people). We could use LOC as a proxy and refer to the general problem of how to
% measure this.}
% 
% 
% \todo{EV: I guess the cognitive properties of a language are another dimension
% that we should consider; but since we have no clue about these, we should defer that to
% future work}
% 
% In this paper, we have ignored human factors of programming languages
% 
% See work of Brad Myers
%
% \EV{note: Turing completeness shows that unlikely languages can be used to
% encode anything. Turing completeness is not a good measure for
% ``expressibility''.}
  
   
\paragraph{Acknowledgements}

We thank Nora Ludewig and Andreas Graf for their feedback on previous versions
of the paper.
