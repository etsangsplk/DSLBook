\FloatBarrier

\section{Separation of Concerns}
\label{sec:viewpoints}


A domain $D$ can be composed from different concerns. \fig{compositionalDomains}
shows $D_{1.1}$ composed from the concerns A, B and C. \marginnote{For embedded
software, these could be component and interface definitions (A), component
instantiation and connections (B), as well as scheduling and bus allocation
(C).} To describe a complete program for $D$, the program needs to address all
the concerns.

\begin{figure}[b]
  \includegraphics[scale=0.7]{figures/compositionalDomains.png}
  \caption[labelInTOC]{A domain may consist of several concerns. A domain is
  covered either by a DSL that addresses all of these concerns, or by a set of
  related, concern-specific DSLs.}
  \label{compositionalDomains} 
\end{figure}

Two fundamentally different approaches are possible to deal with the set of
concerns in a domain. Either a single, integrated language can be designed that
addresses all concerns of $D$ in one integrated model. Alternatively, separate
concern-specific DSLs can be defined, each addressing one or more of the
domain's concerns. A complete program then consists of a set of
dependent, concern-specific fragments that relate to each other in a well-defined way.
Viewpoints support this separation of domain concerns into separate DSL.
\fig{viewpoints} illustrates the two different approaches.

\begin{figure}[t]
\begin{center}
  \includegraphics[scale=0.35]{figures/viewpoints.png}
  \caption[labelInTOC]{Part A shows an integrated DSL, where the various
  concerns (represented by different line styles) are covered by a single 
  integrated language (and consequently, one model). Part B shows several
  viewpoint languages (and model fragments), each covering a single concern.
  Arrows in Part B highlight dependencies between the viewpoints.}
  \label{viewpoints} 
\end{center}
\end{figure} 



\embc{The tasks language module includes the task implementation as well as task
scheduling in one language construct. Scheduling and implementation are two
concerns that could have been separated. We opted against this, because both
concerns are specified by the same person. The language used for implementation
code is \lcr{med.core}, whereas the task constructs are defined in the
\lcr{med.tasks} language. So the languages are modularized, but they are
used in a single integrated model.}

\exwebdsl{Web programs consists of multiple concerns including persistent data,
user interface, and access control. WebDSL provides specific languages for these
concerns, but \emph{linguistically integrates} them into a single
language\cite{HemelGKV11}. Declarations in the languages can be combined in
WebDSL modules. A WebDSL developer can choose how to factor declarations into
modules; e.g. all access control rules in one module, or all aspects of some
feature together in one module.}

\subsection{Viewpoints for Concern Separation}

If viewpoints are used, the concern-specific languages, and consequently the
viewpoint models, should have well-defined dependencies; cycles should be
avoided. \marginnote{The IDE should provide navigational support: If an element
in viewpoint B points to an element in viewpoint A then it should be possible to
follow this reference ("Ctrl-Click"). It should also be possible to query the
dependencies in the opposite direction ("find the persistence mapping for this
entity" or "find all UI forms that access this entity").} If dependencies
between viewpoint fragments are kept cycle-free, the independent fragments may
be sufficient for certain transformations; this can be a driver for using
viewpoints in the first place.

Separating out a domain concern into a separate viewpoint fragment can be useful
for several reasons. If different concerns of a domain are specified by
different stakeholders then separate viewpoints make sure that each stakeholder
has to deal only with the information they care about. The various fragments can
be modified, stored and checked in/out separately, maintaining only referential
integrity with referenced fragmwnt. The viewpoint separation has to be aligned
with the development process: the order of creation of the fragments must be
aligned with the dependency structure.

Viewpoints are also a good fit if the independent fragment is sufficient
for a transformation in the domain, i.e. it can be processed without the
presence of the additional concerns expressed in sepate viewpoints.

\marginnote{A final (very pragmatic) reason for using viewpoints is when the tooling used
does not support embedding of a reusable language because syntactic composition
is not supported.}
Another reason for separate viewpoints is a 1:n relationship between the
independent and the dependent fragments. If a single core concern may be
enhanced by several different additional concerns, then it is crucial to keep
the core concern independent of the information in the additional concerns.
Viewpoints make this possible.


\cooling{One concern in this DSL specifies the logical hardware structure of
refrigerators installations. The other one describes the refrigerator cooling
algorithm. Both are implemented as separate viewpoints, where the algorithm DSL
references the hardware structure DSL. Using this dependency structure,
different algorithms can be defined for the same hardware structure. Each of
these algorithms resides in its own fragment/file. While the C code generation
requires both behavior and hardware structure fragments, the hardware fragment
is sufficient for a transformation that creates a visual representation of the
hardware structures.}


\subsection{Viewpoints as Annotation Models}
 
A special case of viewpoint separation is annotation models (already mentioned
in \sect{severalmapp}). An annotation provides additional, often technical or
transformation-controlling data for elements in a core program. This is
especially useful in a multi-stage transformation (\sect{semtrafo}) where
additional data may have to be specified for the result of the first phase to
control the execution of the next phase. Since that intermediate model is
generated, it is not possible to add these additional specifications to the
intermediate model. Externalizing it into an annotation model solves that
problem. 

\genex{For example, if you create a relational data model from an object
oriented data model, you might automatically derive database table names from
the name of the class in the OO model. If you need to "change" some of those
names, use an annotation model that specifies an alternate name. The downstream
processor knows that the name in the annotation model overrides the name in the
original model.}

\subsection{Viewpoints for Progressive Refinement} 
\label{progref}

There is an additional use case for viewpoint models not related to the concerns
of a domain, but to progressive refinement. Consider complex systems.
Development starts with requirements, proceeds to high-level component design
and specification of non-functional properties, and finishes with the
implementation of the components. Each of these refinement steps may be
expressed with a suitable DSL, realizing the various "refinement viewpoints" of
the system (\fig{progressiveRefinement}). The references between model elements
are called traces\cite{JirapanthongZ05}. Since the same conceptual elements may
be represented on different refinement levels (e.g. component design and
component implementation), synchronization between the viewpoint models is often
required (enabled via techniques described in~\cite{DiskinXC10, Stevens10}).

\begin{figure}[t]
\begin{center}
  \includegraphics[scale=0.6]{figures/progressiveRefinement.png}
  \caption{Progressive refinement: the boxes represent models
  expressed with corresponding languages. The dotted arrows express
  dependencies, whereas the solid arrows represent references between model
  elements.}
  \label{progressiveRefinement}
\end{center}
\end{figure}

\subsection{Viewpoint Synchronization} 

In some cases the models for the various concerns need to be synchronized. This
means that when a change happens in a model representing one viewpoint, the
models representing other viewpoints must change in a consistent way. It depends
on the tools used whether synchronization is feasible: in projectional tools it
is relatively easy to achieve, for parser-based systems it can be problematic.

\todo{Say something about on demand, simple listeners, Krzysztofs work in that
space and QVTO and look at the example below. Use the ports example instead?}

\embc{Components implement interfaces. Each component provides an implementation
for each method define in each of the interfaces it implements. If a new method
is added to an interface, all components that implement that particular
interface must get a new, empty method implementation. This is an example of
model synchronization.}



\subsection{Views on Programs} 

In projectional editors it is also possible to store the data for all viewpoints
in the same model tree, while showing different "views" onto the model to
materialize the various viewpoints. The particular benefit of this approach is
that additional concern-specific views can be defined later, after programs have
been created.\marginnote{ MPS also provides so-called annotations, where
additional model data can be "attached" to any model element, and shown
optionally.}

\pension{Pension plans can be shown in a graphical notation highlighting the
dependency structure. The dependencies can still be edited in this view, but the
actual content of the pension plans is not shown.}

\begin{figure}[h]
  \rule{1\textwidth}{0.7pt}
  \vspace{-0.5cm}
  \includegraphics[scale=1]{figures/pension/dependencies.png}
  \caption[0.3cm]{EMPTY} 
  \label{dependencies}
  \rule{1\textwidth}{0.7pt}
\end{figure}

\embc{Annotations are used for storing requirements traces and documentation
information in the models. The program can be shown and edited with and without
requirements traces and documentation text.}

\begin{figure}[h]
  \rule{1\textwidth}{0.7pt}
  \vspace{-0.5cm}
  \includegraphics[scale=1]{figures/embc/traces.png}
  \caption[0.3cm]{EMPTY}
  \label{traces}
  \rule{1\textwidth}{0.7pt}
\end{figure}



