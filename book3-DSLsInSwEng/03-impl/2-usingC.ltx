
\subsection{Example Extensions addressing the Challenges}
\label{usingC}
 
In this section we present examples to show how we address the challenges
discussed in \sect{challenges}. We present at least one example for each
challenge. How such extensions are build will be discussed in \sect{design}.
Our aim in this paper is to showcase the extensibility of the mbeddr system,
and not to discuss in detail any particular extension. Table
\ref{tab:challenges_extensions_examples} shows an overview over the 
challenges, the examples, and the ways of extension each example makes use of.

\begin{figure}[h]
\footnotesize
\begin{center}
    \begin{tabular}{ | l | l |}
    \hline
    Challenge \ & Example Extensions \  \\ \hline
    \hline 
    $C_1$ & State machines ($W_1$, $W_2$), Components ($W_1$), Decision Tables ($W_3$) \\ \hline
    $C_2$ & Cleaned up C ($W_7$), Safe Modules ($W_5$, $W_7$) 
    \\ \hline    
    $C_3$ & Physical Units ($W_4$) 
    \\ \hline 
    $C_4$ & Unit Tests ($W_1$, $W_2$), State Machines ($W_1$, $W_2$), Safe Modules ($W_2$, $W_5$, $W_7$) \\ \hline 
    $C_5$ & Requirements Traceability ($W_6$), Product Line Variability ($W_6$)
    \\ \hline     
    \end{tabular} 
\end{center}
\caption{Embedded software development challenges, example extensions in this
section, and the ways of extending C each example makes use of.}   
\label{tab:challenges_extensions_examples}    
\normalsize
\end{figure}

 
\paragraph{A cleaned up C} (addresses $C_2$, uses $W_7$) To make C extensible,
we first had to implement C in MPS. This entails the definition of the language
structure, syntax and type system\footnote{A generator to C text is also
required, so the code can be fed into an existing compiler. However, since this
generator merely renders the tree as text, with no structural differences, this
generator is trivial. We do not discuss it any further}. In the process we
changed some aspects of C. Some of these changes are a first step in providing a
safer C ($C_2$). Others changes were implemented because it is more convenient
to the user or because it simplified the implementation of the language in MPS.
Some examples follow.


mbeddr C provides \emph{modules} (\fig{moduleexample}). A module contains the
top level C constructs (such as \ic{struct}s, functions or variables). These
module contents can be \lcr{exported}. Modules can \emph{import} other modules,
in which case they can access the exported contents of the imported modules.
While header files are generated, we do not expose them to the user: modules
provide a more convenient means of controlling which program nodes are
visible globally.


\begin{figure}[t]  
\includegraphics[width=11cm]{figures/impl/modules.pdf}
\caption{Modules are the top-level container in mbeddr C. They can import other
modules, whose exported contents they can then use. Exported contents are put
into the header files generated from the modules.}
\label{moduleexample}
\end{figure}


mbeddr C does not support the \emph{preprocessor}. Empirical studies, such as
\cite{2002_ernst_empirical_analysis_of_c_preprocessor_use}, show that it is
often used to emulate missing features of C in ad-hoc way, leading to problems
regarding maintenance and analyzability. Instead, mbeddr C provides first class
support for the most important use cases of the preprocessor. Examples include
the modules mentioned above (replacing \ic{\#include}) as well as the support
for variability discussed below (replacing \ic{\#ifdef}s). Removing
the preprocessor and providing specific support for its important use cases goes
a long way in creating more maintainable and more analyzable programs.
The same can be said for introducing a separate \lcr{boolean} type and
not interpreting  \lcr{int} as Booleans by default. An explicit cast operator is
available.

Type decorations, such as array brackets or the pointer asterisk must be
specified on the type, not on the identifier (\ic{int* a;} instead of 
\ic{int *a;}). Multiple variable declarations in the same
statement (as in \ic{int a, b;} are not supported. This has been done mainly to
simplify the implementation of C in MPS.


\paragraph{Decision Tables} (addressing $C_1$, uses $W_3$) are a new kind of
expression. An example is shown in \fig{dectab}. A decision table represents
nested \lcr{if} statements. It is evaluated to the value of the first cell
whose column and row headers are \lcr{true} (the evaluation order is
left to right, top to bottom). A default value (\lcr{FAIL}) is specified to
handle the case where none of the column/row header combinations is true. Since
the compiler and IDE have to compute a type for expressions, the decision table
specifies the type of its result values explicitly (\lcr{int8\_t}).



\begin{figure}[h]  
\includegraphics[width=11cm]{figures/impl/dectabexample.pdf}
\caption{A decision table evaluates to the value in the cell for
which the row and column headers are true, a default value 
otherwise. It is translated to nested \ic{if}s in a separate function. The
figure shows the translation for the common case where a decision table is
used in a \ic{return}. This case is optimized to not use an extra function.}
\label{dectab}    
\end{figure}


\paragraph{Unit Tests} (addresses $C_4$, uses $W_1$, $W_2$) are new top-level
constructs (\fig{testcase}). They are introduced in a separate \emph{unittest}
language that extends the C core. Unit tests are like void functions without
arguments. The \emph{unittest} language also introduces \lcr{assert} and
\lcr{fail} statements, which can only be used inside test cases. Testing
embedded software can be a challenge, and the \emph{unittest} extension is a
first step at providing comprehensive support for testing and mocking.


\begin{figure}[h]
\includegraphics[width=11cm]{figures/impl/unittest.pdf}
\caption{The \emph{unittest} language introduces test cases as well as
\lcr{assert} and \lcr{fail} statements which can only be used inside of a test
case. Test cases are transformed to functions, and the \ic{assert} statements
become \ic{if} statements with a negated condition. The generated code also
counts the number of failures so it can be reported to the user.}
\label{testcase}
\end{figure}

 

\paragraph{State Machines} (addresses $C_1$, $C_4$, uses $W_1$, $W_2$) provide a
new top level construct as well as new statements to interact
with state machines (see \fig{statemachines}). State
machines are transformed into a \ic{switch/case}-based implementation in the C
program. Entry, exit and transition actions may only access variables defined
locally in state machines and set out events. Out events may optionally be
mapped to functions in the surrounding C program, where arbitrary behaviour can
be implemented. This way, state machines are semantically isolated from the rest
of the system, enabling them to be model checked: if a state machine is marked
as \ic{verifiable}, we also generate a representation of the state machine in
the input language of the NuSMV model checker\footnote{http://nusmv.fbk.eu},
including a set of property specifications that are verified by default.
Examples include dead state detection, dead transition detection,
non-determinism and variable bounds checks. In addition, users can specify
additional high-level safety properties based on the  well-established catalog 
of temporal logic properties patterns in \cite{DwyerAC99}.


 
\begin{figure}[h]  
\includegraphics[width=11cm]{figures/impl/statemachine.pdf}
\caption{A state machine embedded in a C module. It declares in and out
events as well as local variables, states and transitions. Transitions react to
in events, and out events can be raised in actions. Through bindings
(\ic{tickHandler}) state machines can interact with C
code. The \ic{trigger} statement injects events into the state machine. State
machines can be instantiated and are transformed to \ic{enum}s and nested
\ic{switch/case} statements.}
\label{statemachines}  
\end{figure}




\paragraph{Components} (addresses $C_1$, uses $W_1$) are new top level
constructs used for modularization, encapsulation and the separation between
specification and implementation (\fig{components}). In contrast to modules, a
component uses interfaces and ports to declare the contract it obeys. 
Interfaces define operation signatures and optional pre and post conditions.
Provided ports specify the interfaces offered by a component, required ports
specify the interfaces a component expects to use. Different components can
implement the same interface operations differently. Components can be
instantiated (also in contrast to modules), and each instance's required ports
have to be connected to compatible provided ports provided by other component
instances.



\begin{figure}[h]
\includegraphics[width=11cm]{figures/impl/components.pdf}
\caption{Two components providing the same interface. The \lcr{<-} notation maps
operations offered through provided ports to their implementation in components.
An indirection through function pointers enables different implementations
behind a single interface.}
\label{components}  
\end{figure}

\paragraph{Physical Units} (addresses $C_3$, uses $W_4$) are new types that, in
addition to specifying their actual data type, also specify a physical unit (see
\fig{unitsexample}). New literals are introduced to support specifying values for these
types that include the physical unit. The type checker takes into account unit
compatibility. 

\paragraph{Requirements Traces} (addresses $C_5$, uses $W_6$) are meta data
annotations that link a program node to requirements, essentially nodes in
other models imported from requirements management tools. Requirements traces
can be attached to any program node without that node's definition having to be
aware of this (see the green highlights in \fig{screenshot}).
\todo{use fig traces there?}



\paragraph{Presence Conditions} (addresses $C_5$ and $W_6$) Like requirements
traces, presence conditions can be attached to any program node (the red
highlights with the \ic{resettable} next to them in \fig{screenshot} are
examples). A presence condition determines whether the program node to which it
is attached is part of a product in the product line. A product is configured by
specifying a set of configuration flags and the presence condition specifies a
Boolean expression over these configuration switches\footnote{We use feature
models to express product configurations, and the presence conditions are
expressions over features. But this aspect is not essential to the discussion
here.}. For example, in \fig{screenshot}, the \ic{resetted} out even and the
\ic{on start\ldots} transition in the second state have the \ic{resettable}
presence condition, where \ic{resettable} is a reference to a configuration
flag.  Upon transformation, program nodes whose presence condition evaluates to
\ic{false} for a particular product configuration are simply removed from the
program (and hence will not end up in the generated binary). This program
customization can also be performed while the program is edited, effectively
supporting variant-specific editing.


\paragraph{Safe Modules} (addresses $C_2$, uses $W_5$, $W_7$) Safe modules help
prevent writing risky code. For example, runtime range checking is performed for
arithmetic expressions and assignments. To enable this, arithmetic expressions
are replaced by function calls that perform range checking and report errors if
an overflow is detected. As another example, safe modules also provide the
\ic{safeheap} statement that automatically frees dynamic variables allocated
inside its body (see \fig{safeheap}).



\subsection{Addressing the Tool Integration Challenge}

We have not highlighted tool integration as an explicit challenge, because it is
a cross-cutting issue that affects all of the challenges above. Nonetheless it
needs to be addressed. We do that by providing an \emph{integrated environment}
that provides state-of-the-art IDE support for C and all of its extensions.
While we are still working on a debugger (see \sect{future}), all the other IDE
support is available. This includes syntax highlighting, code completion, static
error checking and annotation, quick fixes and refactorings. \fig{screenshot}
shows a screenshot of the tool, as we edit a module with a decision table, a
state machine, requirements traces and presence conditions.
 
\begin{figure}[h]
\begin{center} 
  \includegraphics[width=11cm]{figures/impl/screenshot2.png}
\end{center} 
\caption{A somewhat overloaded example program in the mbeddr IDE (an instance
of MPS). The module contains an \ic{enum}, a decision table and a state machine.
Requirements traces are attached to the table and an in event, and a presence condition is
attached to an out event and a transitions}
\label{screenshot}  
\end{figure}   
 


