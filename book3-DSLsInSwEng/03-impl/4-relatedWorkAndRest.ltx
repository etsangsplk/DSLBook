
\section{Related Work}
\label{related}
\paragraph{DSLs in Embedded Development} In addition to the general-purposeembedded software modeling tools mentioned before (Simulink and ASCET), muchmore specific languages have been developed. Examples include Feldspar\cite{2010_axelsson_feldspar_dsl_for_dsp}, a DSL embedded in Haskell for digitalsignal processing; Hume \cite{2003_hammond_hume_dsl_for_rt_embedded_systems}, aDSL for real-time embedded systems as well as the approach described in\cite{2008_gokhale_model_driven_middleware}, which use DSLs for addressingquality of service concerns in middleware for distributed real-time systems. Ourapproach is different because our DSLs are directly integrated into C, whereasthe examples mentioned in this paragraph are standalone DSLs that generateC code. As part of our future work we will investigate if and how some of theselanguages could benefit from a tighter integration with C based on mbeddr.

\paragraph{Specific Extensions of C} Extending C to adapt it to a particularproblem domain is not new. For example, in \cite{PalopoliAB99}, Palopoli et. al.present an extension of C for real time applications, Boussinot proposes anextension for reactive systems (\cite{Boussinot91}) and Yosi Ben-Asher et. al.present an extension for shared memory parallel systems (\cite{Ben-AsherFR96}).These are all \emph{specific} extensions of C, typically created by invasivelychanging the C grammar. These extensions do not include IDE support, and theapproach does not provide a framework for modular, incremental extension.However, these are all good examples of extensions that could be implemented aslanguage extensions in mbeddr, if the need arises. Besides extensions of C,there are also safer dialects of C, basically restrictedsub-languages. Examples include Cyclone\cite{2002_trevor_cyclone_safe_dialect_of_c} and the Misra C standard\cite{2004_misra_c}. We are actively working on implementing checks andrestrictions to implement the Misra C standard as a language extension using$W_7$, restriction. \todo{I don't think this fits in. Agree?}% \cite{2010_dagand_practical_dsls_for_os_development} presents a semantic% framework to ease the construction of DSLs for building operating systems. Based% on this framework several DSLs were constructed that focus on error-prone code,% such as device interactions and communication interface. The embedded systems% and operating systems are two related domains since both often work close to the% machine.


\paragraph{Language and IDE Extension}The landmark work of Hudak \cite{1998_hudak_modular_dsl_and_tools} introducesembedded DSLs as language extensions of Haskell. While Haskell provides advancedconcepts that enable such extensions, the new DSLs are essentially justlibraries built with the host language and are not first class languageentities: they do not define their own syntax, compile errors are expressed interms of the host language, no custom semantic analyses are supported and nospecific IDE-support is provided.


Several works avoid these limitations. For example, Bravenboer et. al.
\cite{2004_bravenboer_concrete_syntax_for_objects} and Dinkelacker
\cite{2011_dinkelaker_incremental_concrete_syntax_for_embedded_languages} 
provide custom concrete syntax, Bracha \cite{2004_bracha_pluggable_type_systems}
provides pluggable type systems and Erweg et. al.
\cite{2011_erdweg_growing_a_language_environment} discuss modular IDE
extensions. Our approach is similar in that we provide extensions of syntax,
type systems, semantics and IDE support for a base language. mbeddr is different
in that it extends C, and in that we use a projectional editor. This means we
can use non-textual notations and annotate cross-cutting meta data easily.
A similar argument can be made for the Xoc extensible C compiler described byCox \cite{CoxBCKK08}. It uses a parser-based approach and uses source-to-sourcetranslation to transform modular C extensions into regular C code. In contrastto mbeddr, Cox' approach also does not address IDE extension.

A particularly interesting comparison can be made with the Helvetia system byRenggli et. al. \cite{2010_renggli_embedding_languages_without_breaking_tools}.It supports language embedding and extension of Smalltalk using\emph{homogeneous} extension, which means that the host language (Smalltalk) isalso used for \emph{defining} the extensions (in contrast to some of theembedded DSLs discussed above, Helvetia can work with custom grammars for theDSLs). The authors argue that the approach is independent of the host languageand could be used with other host languages as well. While this is true inprinciple, the implementation strategy heavily relies on some aspects of theSmalltalk system that are not present for other languages, and in particular,not in C. Also, since extensions are defined in the host languages, the completeimplementation would have to be redone if the approach were used with anotherlanguage. This is particularly true for IDE support, where the Smalltalk IDE isextended using this IDE's APIs. mbeddr uses a \emph{heterogeneous} approachwhich does not have these limitations: MPS provides a language-agnosticframework for language and IDE extension that can be used with any language,once the language is implemented in MPS.
  In the same paper, Renggli and his colleagues introduce three different flavoursof language extension. A \emph{pidgin} creatively bends the existing syntax ofthe host language to to extend its semantics. A \emph{creole} introducescompletely new syntax and custom transformations back to the host language. An\emph{argot} reinterprets the semantics of valid host language code. mbeddr doesnot use any pidgins, because C's syntax is not very flexible, and because wehave the language workbench at our disposal, so it is easier to implementcreoles. $W_1$ - $W_4$ are creoles. In contrast, $W_5$ is an argot. It providesdifferent semantics for existing constructs. $W_6$ is yet different. New syntaxis introduced, but it can be attached to any language concept. The semantics isonly relevant to additional tools, not to the core C program --- no translationback to C takes place. $W_7$ \emph{removes} concepts in new contexts and hencealso does not fit with the categorization.  
\paragraph{Static Analysis} Static analysis of C programs is an active researcharea (as exemplified by \cite{KarthikJ05,Mine11,Puccetti10}), and severalcommercial tools are available, such as the Escher CVerifier\footnote{http://www.eschertech.com/products/ecv.php} orKlocwork\footnote{http://www.klocwork.com/}. We believe that we can simplifysome of the analyses provided by these tools by providing suitable extensions toC which embody relevant semantics directly, avoiding the need to reverseengineer the semantics for static analysis. For example, by expressingstate-based behavior directly using state machines instead of a low level Cimplementation, the state space relevant to a model checker can be reducedsignificantly, making model checking more feasible. 

\section{Discussion}
\label{discussion}
\paragraph{Other Language Workbenches} A central pillar to our work is MPS. Ourchoice of MPS is due to its support for all aspects of language development(structure, syntax, type systems, IDE, transformations), its support forflexible syntax as a consequence of projectional editing and its support foradvanced modularization and composition of languages. No other freely availabletool provides support for all those aspects, but some are supported by othertools. For example, Eclipse Xtext\footnote{http://eclipse.org/xtext} and itsaccompanying tool stack supports abstract and concrete syntax definition, IDEsupport and transformations, but it is weak regarding non-textual syntax andmodularization and composition of languages. TU Delft'sSpoofax\footnote{http://spoofax.org} supports language modularization, but doesneither support non-textual syntax nor concise type system definition.Intentional Software\cite{SimonyiCC06} supports extremely flexible syntax andlanguage composition (it is a projectional editor as well) but is not easilyavailable. \paragraph{Projectional Editing} Projectional editing is often considered adrawback because the editors feel somewhat different and the programs are notstored as text, but as a tree (XML). We already highlighted that MPS does a goodjob regarding the editor experience, and we feel that the advantages ofprojectional editors regarding syntactic freedom far outweigh the drawback ofrequiring some initial familiarization. Regarding storage, the situation is notany worse than with current modeling tools, and MPS does provide good supportfor diff and merge using the projected syntax. \paragraph{Other Base Languages} The technology described in this paper can beapplied to other base languages. JetBrains, for example, are extendingJava for building web applications. The advantage of using a heterogeneous overa homogeneous approach is that the tools built for language engineering areindependent of the extended languages. No new frameworks or tools have to bedeveloped. Of course the to-be extended language has to be implemented in thetool stack first. In our case we spent about three person months to implementcore C in MPS.
 
\paragraph{Language Modularity, Reuse and Growth} Modularity and composition iscentral to mbeddr. Extensions should not require modifications of the baselanguage (see \sect{design}). Ideally, independently developed extensions shouldnot interact with each other in unexpected ways. We have not seen suchinteractions so far, so it is relatively safe to assume that, if extensions aredeveloped carefully, such interactions will not happen. Modularity is also thebasis for reuse; the same language should be usable in different contexts. Weillustrate this with the state machines language. State machines can be used astop level concepts in modules (binding out events to C functions) and alsoinside components (binding out events to component methods). Parts of thetransformation of a state machine have to be different in these two cases, andthese differences were successfully isolated to make them exchangeable. Also, wereuse the C expression language inside the guard conditions in a state machine'stransitions. We use constraints to prevent the use of those C expression thatare not allowed inside transitions (for example, references to globalvariables). Summing up, these facilities allows different user groups to developindependent extensions, growing the mbeddr language stack towards theirparticular domain. For example, counters (frequently used in embedded systems) can be based on top ofthe state machines language. After an initial effort to learn MPS, extensionscan be created with very limited effort. For example, we have implementeddecision tables in a few hours. This results contradict the common misconceptionthat developing language extensions and tools implies impractically high effort. 
  \paragraph{Size and Practicability} The mbeddr system is intended for real-worlduse (the core is available as Open Source\footnote{http://mbeddr.com}), solanguage extensions have to scale to real-world industrial systems. As part ofour future work, we will conduct studies with our application partners. However,based on the extensions built so far we feel confident regarding the complexityof language extensions. We have also performed a number of scalability tests andfound that the environment scales to at least the equivalent of 100.000 lines ofC code. While there are certainly systems that are substantially larger, asignificant share of embedded software is below this limit and can be addressedwith mbeddr.
\paragraph{Other Domains} mbeddr's domain is embedded systems. However, the sameapproach can be used in other domains as well. For example, JetBrains aredeveloping Java extensions for web application development. These extensionsinclude support for object-relational mapping, web page templating, andportability of application logic between the client and server by translatingthe same code into Java and Javascript. In internal communications with theauthors, JetBrains have reported significant improvements in productivity andorders of magnitude of reduced time for getting new developers up to speed.JetBrains use this approach to develop the Youtrack bug tracking software,among others.




\section{Conclusion and Future Work}
\label{future}
In this paper we present how different ways of extending the C language can beused to address important challenges in embedded software development. Toillustrate these ways of extension we provide a set of concrete examples andtheir implementation in the mbeddr system. The feedback we have received  so farfrom practitioners on the mbeddr technology stack convinces us that languageengineering approaches have great potential to dramatically improve thedevelopment of embedded software. However, to realize the full potential of theapproach, more research is required in the following two major directions:



\paragraph{Extension of the Approach} We are working on a debugger that can beextended together with language extensions. While there is existing research(such as \cite{Lindeman-GPCE-2011,WuGRM05}), there are still open questions suchas how to calculate custom watches. We will also work more on formal analyses,including mapping higher-level DSLs to state machines and reinterpreting theverification results in the context of the DSL, exploring the relationshipbetween general program analysis and language extensions as well as using SATsolvers to verify the structural integrity of variant-aware programs. We willbuild support for graphical notations for state machines and data flow blockdiagrams once MPS' support for graphical editors becomes available in the 3.0time frame.  Another key research direction is to try to prevent (and analyze)unexpected semantic inconsistencies due to the interactions between differentDSLs.\paragraph{Real-World Feasibility} A major part of our future work is thevalidation of the approach in real-world embedded development projects. We arecurrently building a set of extensions specific to our application partners SickAG and Lear Corporation GmbH on top of the current mbeddr language stack. Theywill use it to build systems in the sensors and automotive domains,respectively. We will measure the increase in productivity and maintainabilityin order to provide solid data about the full potential of this approach. Theline of future work will also include an automatic importer for functions,\ic{struct}s, constants, \ic{enum}s and \ic{typdef}s defined in existing headerfiles to simplify working with legacy code. We are also considering an importerfor C implementation code (as long as it does not contain preprocessorstatements). This will not be fully automatic, since some of the changes tombeddr C require explicit decisions. 

\noindent
\textbf{Acknowledgements}  We thank our team mates Marcel Matzat and Bernhard
Merkle for their contributions to the material described in this paper. This
work has been developed as part of the LWES project, supported by the
Bunderministerium fuer Bildung und Forschung, Foerderkennzeichen 01/S11014.

