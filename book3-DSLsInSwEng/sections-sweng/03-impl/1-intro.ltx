\chapter{DSLs in the Implementation}

\chapterabstract{In this chapter we discuss the use of DSLs in the context of
system implementation. We do this based on an extensive case study in embedded
software development. While the C programming language provides very good
support for writing efficient, low-level code, it does not offer adequate means
for defining higher-level abstractions relevant to embedded software. In this
paper we present the mbeddr technology stack that supports extension of C with
constructs adequate for embedded systems. In mbeddr, efficient low-level
programs can be written using the well-known concepts from C. Higher-level
domain-specific abstractions can be seamlessly integrated into C by means of
modular language extension regarding syntax, type system, semantics and IDE. In
this chapter we show how language extension can address the challenges
of embedded software development and report on our experience in building these extensions.
This chapter provides details for the Extensible C case study used in other
places in the book.}

\noindent This section of the book is based on a paper written together with
Daniel Ratiu, Bernd Kolb and Bernhard Schaetz

 
\section{Introduction}

In this section we discuss the use of DSLs in the context of implementation.
There it is crucial that the DSLs are tightly integrated with the application
code that is often written in a GPL. Language embedding and extension
(\sect{sec:extAndComp}) are obviously useful approaches. In this chapter we
discuss the mbeddr system (\ic{http://mbeddr.com}) which supports domain
specific extensions to C\footnote{mbeddr is built with MPS, so you should make
sure that you have read and understood the MPS-based implementation examples in
Part III of the book.}.



The amount of software embedded in devices is growing. Embedded software
development is a challenging field. In addition to functional requirements,
strict operational requirements have to be fulfilled as well. These include
reliability (a device may not be accessible for maintenance after deployment),
safety (a system may endanger life or property if it fails), efficiency (the
resources available to the system may be limited) or real-time constraints (a
system may have to run on a strict schedule prescribed by the system's
environment). Addressing these challenges requires any of the following:
abstraction techniques should not lead to excessive runtime overhead; programs
should be easily analyzable for faults before deployment; and various kinds of
annotations, for example for describing and type checking physical units, must
be integrated into the code. Process issues such as requirements traceability
have to be addressed, and developers face a high degree of variability, since
embedded systems are often developed in the context of product lines.
 
Current approaches for embedded software development can roughly be
distinguished into programming and modeling. The \emph{programming} approach
mostly relies on C, sometimes C++ and Ada in rare cases. However, because of C's
limited support for defining custom abstractions, this can lead to software that
is hard to understand, maintain and extend. Furthermore, C's ability to work
with very low-level abstractions such as pointers, makes C code very expensive
to analyze statically. The alternative approach uses \emph{modeling} tools with
automatic code generation. The modeling tools provide predefined, higher-level
abstractions such as state machines or data flow component diagrams. Example
tools include ASCET-SD\footnote{http://www.etas.com/} or
Simulink\footnote{http://www.mathworks.com/products/simulink}. Using
higher-level abstractions leads to more concise programs and simplified fault
detection using static analysis and model checking (for example using the
Simulink Design
Verifier\footnote{http://www.mathworks.com/products/sldesignverifier}).
Increasingly, DSLs are used for embedded
software and studies show that
DSLs substantially increase productivity in embedded
software development. However, most real-world systems cannot be described
completely and adequately with a single modeling tool or DSL, and the
integration effort between manually written C code and possibly several modeling
tools and DSLs becomes significant.

 

A promising solution to this dilemma lies in a much tighter integration between
low-level C code and higher-level abstractions specific to embedded software. We
achieve this with an extensible C programming language. The advantages of C can
be maintained: existing \emph{legacy code} can be easily integrated, reused, and
evolved, and the need for \emph{efficient code} is immediately addressed by
relying on C's low-level programming concepts. At the same time, domain-specific
extensions such as state machines, components or data types with physical units
can be made available as C extensions. This improves
\emph{productivity} via more concise programs, it helps improve \emph{quality}
in a constructive way by avoiding low-level implementation errors up-front, and
leads to system implementations that are more amenable to \emph{analysis}. By
directly embedding the extensions into C, the mismatch and integration challenge
between domain specific models and general purpose code can be removed. An
industry-strength implementation of this approach must also include IDE support
for C and the extensions: syntax highlighting, code completion, error checking,
refactoring and debugging.
 
Developing such an extensible language and IDE is hard, but modern language
engineering approaches promise to make it much simpler. The LW-ES research
project, run by itemis AG, fortiss GmbH and Sick AG explores the benefits of
language engineering in the context of embedded software development. The open
source project is hosted at \ic{http://mbeddr.com}. The code is available via
this site.
  

Even though the work presented here is centered on C and embedded
software, the approach can be used with other domains and other base
languages (we discuss this in \sect{discussion}). In this case, the first
contribution would serve as a blueprint for identifying, motivating and designing language
extensions. The second would serve as comparative reference for future
(research) projects that use other language approaches or tools. The third would
serve as a baseline for more specialized DSLs in specific subdomains of embedded
software.



\sect{Challenges in Embedded Software}
\label{challenges}

\label{rephrasedChallenges}
In this section we discuss a set of challenges we address with the mbeddr
approach. We label the challenges $C_n$ so we can refer to them from
\sect{usingC} where we show how they are addressed by mbeddr\footnote{While these are
certainly not \emph{all} challenges embedded software developers face, based on
our experience with embedded software and feedback from various domains
(automotive, sensors, automation) and organizations (small, medium and large
companies), these are among the most important ones.}.


\parhead{$C_1$: Abstraction without Runtime Cost} Domain-specific concepts
provide more abstract descriptions of the system under development. Examples
include data flow blocks, state machines, or data types with physical units. On
the one hand, adequate abstractions have a higher expressive power that leads
to shorter and easier to understand and maintain programs. On the other hand, by
restricting the freedom of programmers, domain specific abstractions also
enable constructive quality assurance. For embedded systems, where runtime
efficiency is a prime concern, abstraction mechanisms are needed that can be
resolved before or during compilation, and not at runtime. 



\parhead{$C_2$: C considered Unsafe} While C is efficient and flexible, several
of C's features are often considered unsafe. For example, unconstrained casting
via \ic{void} pointers, using \ic{int}s as Booleans or the weak typing implied
by \ic{union}s can result in runtime errors that are hard to track down.
Consequently, the unsafe features of C are prohibited in many organizations.
Standards for automotive software development such as MISRA
limit C to a \emph{safer} language subset. However, most C IDEs are not aware of
these and other, organization-specific restrictions, so they are enforced with
separate checkers that are often not well integrated with the IDE. This makes it
hard for developers to comply with these restrictions efficiently.


\parhead{$C_3$: Program annotations} For reasons such as safety or efficiency,
embedded systems often require additional data to be associated with program
elements. Examples include physical units, coordinate systems, data encodings or
value ranges for variables. These annotations are typically used by specific,
often custom-built analysis or generation tools. Since C programs can only
capture such data informally as comments or \ic{pragma}s, the C type system and
IDE cannot check their correct use in C programs. They may also be stored
separately (for example, in XML files) and linked back to the program using
names or other weak links\footnote{Even with tool support that checks the consistency of
these links and helps navigate between code and this additional data, the
separation of core functionality and the additional data leads to unnecessary
complexity and maintainability problems.}.


\parhead{$C_4$: Static Checks and Verification} Embedded systems often have to
fulfil strict safety requirements. Industry standards for safety (such as
ISO-26262, DO-178B or IEC-61508) demand that for high safety certification
levels various forms of static analyses are performed on the software. These
range from simple type checks to sophisticated property checks, for example by
model checking. Since C is a very flexible and relatively weakly-typed language,
the more sophisticated analyses are very expensive. Using suitable
domain-specific abstractions (for example, state machines) leads to programs
that can be analyzed much more easily.




\parhead{$C_5$: Process Support} There are at least two cross-cutting and
process-related concerns relevant to embedded software development. First, many
certification standards (such as those mentioned above) require that code be
explicitly linked to requirements such that full traceability is available.
Today, requirements are often managed in external tools and maintaining
traceability to the code is a burden to the developers and often done in an ad
hoc way, for example via comments. Second, many embedded systems are developed
as part of product lines with many distinct product variants, where each variant
consists of a subset of the (parts of) artifacts that comprise the product line.
This variability is usually captured in constraints expressed over program parts
such as statements, functions or states. Most existing tools come with their own
variation mechanism, if variability is supported at all. Integration between
program parts, the constraints and the variant configuration (for example via
feature models) is often done through weak links, and with little awareness of
the semantics of the underlying language. For example, the C preprocessor, which
is often used for this task, performs simple text replacement or removal
controlled by the conditions in \ic{\#ifdef}s. As a consequence, variant
management is a huge source of accidental complexity.

\vspace{3mm}
\noindent An additional concern is tool integration. The diverse requirements
and limitations of C discussed so far often lead to the use of a wide variety of
tools in a single development project. Most commercial off-the-shelf (COTS)
tools are not open enough to facilitate seamless and semantically meaningful integration with
other tools, leading to significant accidental tool integration complexity.
COTS tools often also do not support meaningful
language extension, severely limiting the ability to define and use custom
domain-specific abstractions.




\sect{The mbeddr Approach}
\label{solapproach}

 
Language engineering provides a holistic approach to solve these challenges. In
this section we illustrate how mbeddr addresses the challenges with an
extensible version of the C programming language, growing a stack of languages
extensions (see \fig{growing}, and \sect{lext} for a discussion of language
extension). The following section briefly discusses language extension in
general and explores which ways $W_m$ of extending C are necessary to address
the challenges $C_n$. \sect{usingC} then shows examples that address each of the
challenges and ways of extending C.




\begin{figure}   
\begin{center} 
  \includegraphics[width=85mm]{figures-sweng/impl/growing_c_language.png}
\end{center}

\caption{Based on MPS, mbeddr comes with an implementation of the C programming
language. On top of C mbeddr defines a set of default extensions (white boxes)
stacked on top of each other. Users can use them in their programs, but they
don't have to. Support for requirements traceability and product line
variability is cross-cutting. Users build their own extensions on top of C or on
top of the default extensions. (Note: component/state machine integration and
state machine tests are not discussed in this paper.)}


\label{growing}
\end{figure}   


\noindent The semantics of an extension are typically defined by a
transformation back to the base language. For example, in an extension that provides state machines,
these may be transformed to a \ic{switch/case}-based implementation in C.
Extensions can be stacked (\fig{growing}), where a higher-level extension
extends (and transforms back to) a lower-level extension instead of C. At the
bottom of this stack resides plain C in textual form and a suitable compiler.
\fig{reduction} shows an example where a module containing a component
containing a state machine is transformed to C, and then compiled.



\begin{marginfigure}
  \includegraphics[width=50mm]{figures-sweng/impl/reduction.png}
\caption{Higher-level abstractions such as state machines
or components are reduced incrementally to their lower-level equivalent, reusing
the transformations built for lower-level extensions. Eventually, C text is
generated which is subsequently compiled with a C compiler suitable for the
target platform.}
\label{reduction}   
\end{marginfigure} 
 
  
 


A set of organizations, such as the departments in a large company, will likely
not agree on a \emph{single} set of extensions to C since they typically work in
slightly different areas. Also, a language that contains \emph{all} relevant
abstractions would become big and unwieldy. Thus, extensions have to be
\emph{modular}. They have to be defined independent of each other, without
modifying the base language, and unintended interactions between independently
created extensions must be avoided (a discussion of automatic detection of
interactions is beyond the scope of this paper). Also, users must be able to
include \emph{incrementally} only those extensions into any given program they
actually need. Ideally, they should be able to do this without requiring the
definition of a "combined language" for each combination of used extensions: for
example, a user should be able to include an extension providing state machines
and an extension providing physical units \emph{in the same program} without
first defining a combined language statemachine-with-units.




\subsection{Ways to extend C}
\label{ways}

In this section we discuss in which particular ways C needs to be extensible to
support addressing the challenges discussed above\footnote{\sect{usingC} shows examples
for each of the ways.}.



\parhead{$W_1$: Top Level Constructs} Top level constructs (on the level of
functions or \ic{struct} declarations) are necessary. This enables the
integration of test cases or new programming paradigms relevant in particular
domains such as state machines, or interfaces and components.


\parhead{$W_2$: Statements} New statements, such as \ic{assert} or \ic{fail}
statements in test cases, must be supported. If statements introduce new
blocks, then variable visibility and shadowing must be handled correctly, just
as in regular C. Statements may have to be restricted to a specific
context; for example the \ic{assert} or \ic{fail} statements must
\emph{only} be used in test cases and not in any other statement list.


\parhead{$W_3$: Expressions} New kinds of expressions must be supported. An
example is a decision table expression that represents a two-level decision
tree as a two dimensional table (\fig{dectab}).
 

\parhead{$W_4$: Types and Literals} New types, e.g.,~for matrices,
complex numbers or quantities with physical units must be supported. This also
requires defining new operators and overriding the typing rules for existing
ones. New literals may also be required: for example, physical units could be
attached to number literals (as in \ic{10kg}).



\parhead{$W_5$: Transformation} Alternative transformations for existing
language concepts must be possible. For example, in a module marked as
\ic{safe}, \ic{x + y} may have to be translated to
\ic{addWithBoundsCheck(x, y)}, a call to an \ic{inline} function that performs
bounds-checking besides the addition. 



\parhead{$W_6$: Meta Data Decoration} It should be possible to add meta data
such as trace links to requirements or product line variability constraints to
arbitrary program nodes, without changing the concept of the node.



\parhead{$W_7$: Restriction} It should be possible to define contexts that
restrict the use of certain language concepts. Like
any other extension, such contexts must be definable \emph{after} the original language
has been implemented, without invasive change. For example, the use of
pointer arithmetic should be prohibited in modules marked as \emph{safe} or the
use of real numbers should be prohibited in state machines that are intended to
be model checked (model checkers do not support real numbers).



