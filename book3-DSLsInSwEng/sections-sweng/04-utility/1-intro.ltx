\chapter{DSLs as Programmer Utility}

\section{Jnario - Executable Specifications for Java}

General introduction about the goal of this chapter and why Jnario is good example.

\subsection{Overview}

Tests always had an important role during development to ensure that an application behaves as expected. Nowadays tests have become more than simple checks whether a system's output correspond to the inputs. They aid the design process by giving early feedback about an application's modularity (aka testability). Furthermore, tests are means for developers to discuss and elaborate features with stakeholders. The verbose syntax of Java makes it hard to dicuss tests with stakeholders. Therefore, we created Jnario as a DSL to write executable acceptance specifications that are easily readable and understandable to business users, developers and testers. To make the tests understandable by non-programmers, Jnario uses a similar textual format to \emph{Cucumber}(http://cukes.info/). The idea is to describe the features of a Java application using scenarios. The preconditions, events and expected outcomes of a scenario are described textually with \emph{Given}, \emph{When} and \emph{Then} steps. Here is an example acceptance specification for adding values with a calculator:

\begin{lstlisting}[language=jnario-feature]
 Feature: Addition

  In order to avoid silly mistakes
  As a math idiot
  I want to be told the sum of two numbers
  
  Scenario: Add two numbers
    Given I have entered "50" into the calculator
    And I have entered "70" into the calculator
    When I press "add"
    Then the result should be "120" 
\end{lstlisting}

These scenarios can be made executable by adding for each step the required code to establish preconditions, trigger events or assert properties of the resulting state. There is one big difference between Jnario and Cucumber. You don't need to create separate step definitions to make your steps executable. You can directly add the necessary code below your steps. In our example we create a calculator, pass in the parameters defined in the steps (via the implicit variable \emph{args}) and check the calculated result:

\begin{lstlisting}[language=jnario-feature]
  ...
  Scenario: Add two numbers
        Calculator calculator = new Calculator()
    Given I have entered "50" into the calculator
        calculator.enter(args.first)             
    And I have entered "70" into the calculator
    When I press "add"
        calculator.press(args.first)             
    Then the result should be "120" 
        calculator.result =&gt; args.first          
\end{lstlisting}

This reduces the effort in writing scenarios by not needing to maintain separate step definitions. Of course you are still able to reuse existing step definitions in your scenarios. You even have code completion in the editor showing all existing steps. In our example, the step \emph{And I have entered "70" into the calculator} reuses the code of the step \emph{Given I have entered "50" into the calculator} with a different parameter value. You might think now that mixing code and text in your specs makes everything pretty unreadable. Actually, this is not a problem, as you can hide the code in the editor to improve the readability.

Scenarios are good for writing high-level acceptance specifications, but writing scenarios for data structures or algorithms quickly becomes tedious. That is why Jnario provides another language for writing unit specifications. This languages removes all the boilerplate from normal JUnit tests helping you to focus on what is important: specifying facts that your code should fulfill. A fact can be as simple as a single assertion:

\begin{lstlisting}[language=jnario-spec]
package demo

import java.util.Stack

describe Stack{
	fact new Stack().size => 0
}
\end{lstlisting}

We use \emph{=>} to describe the expected result of an expression. More complex facts can have an additional description:

\begin{lstlisting}[language=jnario-spec]
package demo

import java.util.Stack

describe Stack{
	fact "size increases when adding elements"{
		val stack = new Stack&lt;String&gt;
		stack.add("something")
		stack.size => 1
	}
}

\end{lstlisting}

Objects can behave differently in different contexts. For example, calling \emph{pop} on a non-empty stack decreases its size. However, if the stack is empty, \emph{pop} results in an exception. In Jnario we can explicitly specify such contexts using the \emph{context} keyword: 
 
\begin{lstlisting}[language=jnario-spec]
package demo

import java.util.Stack

describe "A Stack"{ 
	val stack = new Stack&lt;String&gt;
	context "empty"{
		fact stack.size => 0
		fact stack.pop throws Exception
	}
	context "with one element"{ 
    	before stack.add("element")
    	fact stack.size => 1
    	fact "pop decreases size"{
      		stack.pop
      		stack.size => 0 
    	}
	}   
}
\end{lstlisting}

You can execute unit specifications as normal JUnit tests. Note that Jnario uses the description as test name or, if not present, the actual expression being executed. If you look at the executed tests, you see that your specifications effectively document the behavior of your code.

Screenshot JUnit View

- Test Suites 
  - Group tests
  - Provide additional documentation

\subsection{Why a DSL}

 - remove boilerplate <- Expressivity
 - Mixing prose and code <- Expressivity
 - Add statements, literals that are good for testing, but don't necessarily make sense in a general purpose language
 	- Tables with example failure
 	- Self-explainable Assertions

Jnario is not just another testing framework. It is actually two domain-specific languages specifically made for writing executable specifications. If you think about current testing frameworks, they usually "stretch" the syntax of the underlying programming language to be able to write expressive tests. Now imagine a programming language in which the syntax is specifially designed for the purpose of writing tests. For example, a common scenario is to test a class with different sets of input parameters. I don't know about you, but I find it really hard in JUnit to write parameterized tests (http://junit.sourceforge.net/javadoc/org/junit/runners/Parameterized.html). Writing such tests in Jnario is really easy as it has a special table syntax:

\begin{lstlisting}[language=jnario-spec]
package demo
describe "Addition"{
  def examples{
  		|  a  |  b  |  sum  |
  		|  1  |  2  |   3   |
  		|  4  |  5  |   9   |
  		| 10  | 11  |  20   | 
  		| 21  | 21  |  42   | 
  }
  fact examples.forEach[a + b => sum]
}
\end{lstlisting}

Tables in Jnario are type safe: the type of a column will be automatically inferred to the common super type of all cells in a column. You can easily iterate over each row in a table and write assertions by accessing the column values as variables. If you execute the example specification it will fail with the following error:

\begin{lstlisting}[language=jnario-spec]
package demo
java.lang.AssertionError: examples failed

        | a      | b      | sum     |
        | 1      | 2      | 3       | ✓
        | 4      | 5      | 9       | ✓
        | 10     | 11     | 20      | ✘     (1)
        | 21     | 21     | 42      | ✓

(1) Expected a + b => sum but
         a + b is 21
         a is 10
         b is 11
         sum is 20
\end{lstlisting}
	
This demonstrates another advantage of Jnario, it tries to give you as much information as possible about why an assertion failed. A failed assertion prints the values of all evaluated sub-expressions. This means you don't need to debug your tests anymore to find the exact reason why an assertion failed. This works out of the box, without any additional constraints such as "your source files must reside in a specific folder". 

These are just two examples demonstrating the advantages of test-centric domain-specific language. Having full control over the syntax of the language and its translation into Java code allows us to add features that are helpful when writing tests, but would never make sense in a general purpose language.

\subsection{How does it work?}

Both Jnario languages - the Feature and Spec language - were developed with the Xtext framework. Xtext was selected because it fitted best for creating a DSL for Java and is a highly evolved framework which supports all steps necessary for creating and using a DSL. When creating Jnario we benefited from the generation of the lexer and parser, the constraint functionality, the code generator for Java source code and the UI capabilities for the integration into Eclipse. Due to the language modularity of Xtext we were able to reuse the existing languages Xbase and Xtend, which are based on Xtext.

Xtend
As mentioned before, Xtend is a statically-typed programming language that is based on Java. It supports features such as extension methods, type inference and lambda expressions in a very concise way and compiles to Java source code. We used the language Xtend as basis for our languages because we were able to reuse and extend the existing features such as the type system, the expressions and the tooling, for example for automatically adding import statements.

Design (ref?)

Jnario consists of three languages - the basic Jnario language, and the Feature and Spec language. For each of those languages a grammar has to be defined.

The Feature and Spec language have certain grammar rules in common. For those rules an own Jnario language was created which is used by the Spec and Feature language. The possibility of using existing grammars in your own grammar reduces redundancy in the grammars. The language specific rules are defined in the corresponding language project with their own grammar.

Since both languages are based on Xbase and Xtend we made heavy use of existing concepts and grammar parts. The following grammar rule is part of the Spec language. This rule is based on "XtendMember" which is a rule from the Xtend language that defines fields, functions and constructors. For the spec language this rule is extended and the notion of Examples or ExampleGroups are added. Examples are used to define facts with their implementation logic (XExpression/XBlockExpression), ExampleGroups consist of a describe block and an arbitrary number of members. 

(existing annotations are stored in the annotationInfo of the next member)

\begin{lstlisting}
Member returns xtend::XtendMember:
	{xtend::XtendMember} annotations+=XAnnotation* 
	(
		{Example.annotationInfo = current}
			( pending?='pending'? ('fact' | 'facts') expr=XExpression body=XBlockExpression?)
	|	{ExampleGroup.annotationInfo = current}
			(preamble='describe' targetType=JvmTypeReference? name=STRING? '{'
      		members+=Member*
      	'}')
    | ...
     );
\end{lstlisting}

Constraints (ref)

Existing constraints are checked whenever a file a saved. Since every DSL has different domain specific constraints they have to be defined for each language. Validation mechanisms are already part of Xtext and can be extended as needed for example for checking that a fact is only defined once. Another example is the type checks within the example tables of the Spec language where one column has to have matching types. 

Generation (ref)

Jnario translates not just to Java but also generates JUnit 4 compatible code. The features and specs can be run with JUnit to get immediate feedback with the established test framework. To be able to do this you have to define what parts of the language are mapped to which Java concepts. An example mapping for the feature language is shown in figure \ref{jnarioToJava}.

\begin{figure}[h]
\begin{center}
  \includegraphics[scale=0.5]{figures-sweng/utility/jnarioToJavaClasses.png}
  \caption[labelInTOC]{Generation from Jnario Feature DSL to Java classes with JUnit Tests}
  \label{jnarioToJava} 
\end{center} 
\end{figure}

Scenarios are mapped to Java classes, each step is mapped to a JUnit test method. Steps which are defined in a Background and executed for every Scenario are inherited. For the generation of the source code of the methods the existing Xtend generation could be used. For the compatibility with JUnit all necessary imports, and '@Test' annotations are added during the generation.

For the execution of the tests and we created our own JUnit Test Runners. The runner takes care of finding all test methods and executing them in the right order.


- Example: compiling assertions @Sebastian
 

Tooling (ref)

For Jnario a good tooling is important since the hurdles of learning a new language should be as low as possible and being able to work efficiently is a main goal. Xtext provides a great tooling support for new DSLs. With the existing integration into Eclipse and the easy extensibility of the UI components you can add support for your DSL fast. 

The Feature language aims to be readable for software developers and for domain experts who have no programming background. The best way to support both groups was to establish two views on a Feature file. We created an own Feature Editor that uses specialized folding to show or hide the implementation logic of the scenarios and features. This enables the possibility of showing only the parts of the file that are in natural language and it therefore feels like working with a text editor. In addition, highlighting of keywords comes in handy when referring to existing steps. We used different colors to show if a step is a implemented, not implemented or a reference to an existing step.

For working efficiently certain concepts such as quick fixes for importing necessary libraries or for creating new class files were added. Auto completion for steps in features is supported since you can reuse other steps by referencing them, even if they are not implemented. Another important feature is the debugging facility of Xtext which lets you step through your DSL file instead of using the generated code. 

Jnario also comes with a standalone compiler for running features and specs headless so features and specs can be run for example from a console.

Testing (ref)

As described in the chapter \ref{testing dsls} different parts of a DSL should be tested to ensure its functionalities and to be confident when changing parts of it. Jnario is a special case since it defines a framework for testing. This is why we decided to bootstrap the languages. Bootstrapping means to use the system under development for the development. We defined most of our tests as features and specs with Jnario as soon as the most basic implementation was done.

The advantages of this approach are that you get a good feeling if your concepts work when you are already using them and if they feel right. In addition, those tests are good examples for people who want to use the framework later and look for ideas of how to use it.

\begin{lstlisting}[language=jnario-feature] 	
 		Scenario: Inferring Fields from other Scenario
		CharSequence jnarioFile
		When I have a feature with two scenarios
			'''
			Feature: Feature 1
				Scenario: My Scenario
					String myString
					Given a string "value"
						myString = args.first
				Scenario: My Scenario 2
					Given a string "test"
					Then my string is "test"
						myString => args.first  
			'''
			jnarioFile = args.first
		Then it should execute successfully
			jnarioFile.successful
\end{lstlisting}

A bootstrap feature is defined in listing \ref{}. The scenario is used for testing the field inference between different scenarios. In this scenario an example feature is defined that has two scenarios where the field myString from the first scenario should be inferred in the second scenario.

What happens is that the given feature is assigned to the variable jnarioFile and afterwards the method successful is called. In this method the given CharSequence runs through the entire language infrastructure. This includes compiling, type system and constraint checks, generating the corresponding Java files and executing those. For the entire scenario "Inferring Fields from other Scenario" to pass the inner feature and scenarios also have to pass.
 	

 \subsection{Summary}