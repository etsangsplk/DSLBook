Part I

Chapter 1: Introduction to DSLs

	Why DSL
	   DSLs as the purest form of abstraction and formalization
	   Internal vs. External DSLs - we focus on External
	     some of this stuff is already in the book intro
	   DSLs + General Purpose Language
	     Why Limitation can be a benefit
	   Compare to UML and to programming languages
	     and also compare to "picture drawing"
	   Notational Flavors
	     Gr vs. Textual vs. Projection, vs. Mixes, when to use what
	DSL program vs. code [discuss]
       Formal language may be called
	     model | specification | configuration | program (map back to backgrounds)
	What is a model what is code?

	
Chapter 2: DSL Overview and Terminology

	[moved into the corresponding chapter file]
	

Chapter 3: Language Design Concerns, Policies

    [moved into the DSL 2011 paper for elaboration; will become chapter later]	
	
	
Part II: DSLs in Software Engineering

Chapter 4: Thinking about Systems				

	   Building a DSL helps you formalize your system
	   Learn about your domain as you build a DSL
	   Todays DSL tools allow you to iterate quickly
	   Like analysis models, but you can actually "play" with them
	   	EX (for all topics):
	   		architectural DSLs
	   		WebDSL to explore Web programming domain
	   		"turn around laptop and play with the DSL"
	   		understanding the Pension domain

Chapter 5:	Automating System Construction, Deriving other stuff

	   High Level of Abstraction to Low Level automated
	   	EX: MED state machines
	   Fan out: several artifacts from the same model
	   	EX: WebDSL (or any Web application), n-tier/layer applications
	   Structured approach - no accidental errors
	   	EX: 1. state machines in MED - it's easier to write a generator than to write the code manually
	   		2. Web applications - due to the fan out and limited IDE/cross reference checking support, it's easier/more productive to get cross references right with a generator
	   Platform independence (if you have multiple platforms to begin with)
	   	EX: mobl, itemis' mobile efforts
	   Avoiding details you don't care about (get rid of your boiler plate)
	   	EX: request life cycle in WebDSL
	   What compilers do....
	   	EX: gcc having various backends (and frontends)

Chapter 6: System Analysis + Verification		

	   Constraints can check certain properties on a higher, more meaningful level
	   	EX: MED state machine
	   Simulation
	   	EX: refrigerators
	   Formal analysis can proof certain properties iff you select the right formalism
	   	EX: model checking on state machines
	   Solvers can help optimize your system: finding the right model
	    EX: KC feature model solving etc.
	    EX: Jules White Prolog in DSLs for allocation
	   (Keynotes Pamela Zave, Ed Lee)
	   {as a proxy to deeper sources}
	   automatic synthesis, solvers, etc.

Chapter 7: Technical DSLs

	{ranging from "small" DSLs like regexes and anything which is made by developers during a project to "large" DSLs like WebDSL, covering a certain domain as a whole}

    DSLs as utilities for developers	{address one specific concern}
    	EX: parser( generator)s
    Developer-centric DSLs {modulo some discussion} //  multi-concern/viewpoint DSLs?
    	EX: WebDSL, mobl, etc.
    Automate "annoying" repetitive coding tasks
    discuss if and how this is better than frameworks
      (use Xtext/SDF themselves as examples of this)
    (here is where the discussion always comes up!)
    Maybe integrate KC's FSMLs
 
Chapter 8: DSLs in Testing     
    Describing Tests through DSLs   
    WOrks especially well if the system is described with models as well - Connecting to the rest of the description    
    Automatically finding tests     
      eg with state machines
      -> see formal stuff, solvers
         
Chapter 9: DSLs in Requirements Engineering	
	
	    Req Eng is about capturing what a system is supposed to do, but not how
	    ideally complete, unambiguous, checkable ... etc.
	    DSLs can be used to describe certain parts of the requirements formally with a formal DSL -> see business DSLs
	    if everything is a model, traceability is simple(r)
	    You can also capture req "text" in structuring models, then you can trace to/with text
	    In Systems Eng, you can "experiment" with the models, see formal analysis

Chapter 10: DSLs in Software Architecture		
	
		What is architecture, what it is not		
		Architecture vs. Technology
		Architectural Principles
		  what are these, and how DSLs allow to focus on "the real architecture"
		Architecture as Language
		  An extensive case study based on my "award winning" :-) papers
		Non-Functional Properties and their verification		
		  Timing/Mock Example, Ed Lee, Alloy
		  -> see the formal analysis stuff
		Components as the core building blocks		
		  My Component Discussion (from the old book)
		UML, AUTOSAR, ADLs: are they useful?
	
Chapter : Business DSLs			

		The role of business folks in software development		
		  Fachlichkeit vs. Software, Charles' scrambled egg
		what are suitable domains		
		  structured thinkers vs. Chaots
		Relationship to Requirements
		How to teach it to business folks		
		The importance of flexible notations (existing notations in the domain)
		"Playing with the models" as a way for understanding them
		Getting input - what Business folks can tell you		
		  They won't talk about reuse and stuff.
					
Chapter : DSLs and Product Lines
			
		What are product lines		
		Classificaiton of Variability		
		  see my Var patterns paper
		The role of DSLs in PLE		
		  � and why DSLs are important here
		Integration with Feature Models		
		  Config vs. Construction
		The role of AO		
		  Injecting Variations
				
Chapter : DSLs for formal analysis

	    Overview over a couple of formal verification tools and approaches 
	    (see the book I am reading over christmas; maybe invite additional auth
	    Don't invent your own formalisms here, use existing stuff; math!
	    Maybe map your own DSLs onto these formalisms
	
Chapter : Process Issues

		Emphasize that many of the challenges are not DSL-specific (meta software is software as well, models are now software and should be engineered)
		Efficiency (through DSLs and Automation) as an alternative to "more and more cheaper people"
		Agile, Scrum, bla bla :-)
	    parts from [MV]'s DSL Best Practices Paper
		
				
Part III: Building DSLs

Chapter : Intro to Part II			
			
	Why we emphasize tools as well - usability issues
	How modern LWBs are different from lex and yacc		
	
Chapter : Three Example DSLs

	  SDF: WebDSL
	  MPS: MED
	  Xtext: Refrigerators
							
Chapter : Concrete and Abstract Syntax, 	
	
		  Concrete may be textual or graphical (or tabular or form based, or mixed (ideally))
		  parsing (c->a) vs. projection (a->c)
		  Concrete is the "UI" to the user
		  Abstract is the "API" for the developer, the heart of everything
		  Theory: abstract syntax first 
		  Pragmatics: often Abstract is derived from concrete
		  Mapping C -> A should be relarively flexible
		  Brief explanation of grammar classes, grammars vs. parser spects (paradise lost)
		  
Chapter : Editor Services

		  Typical editor services
		    ... and how are they described
		    more interactive stuff, such as the tests/sims at BSH
		  
Chapter : Scoping and Linking		

          scopes as the potentially visible objects
          name resolution
          scopes as name-manging mechanism 
          explicit symbol table vs. direct object links
          name shadowing, scopes as a hierarchy

   		  Constraints	and Type Systems	
		  rules that can be checked using only the structure of a model
		  (aka static semantics)
		  what are good languages for describing constraints (model navigation + query)
		  simple constraints vs actual typesystems
		  how to build type systems, the idea of attribute grammars
	
Chapter:  Expressions and Type Systems
		
Chapter : Language Semantics		

		  Semantics is "what it all means"
		  Use statemachines as an example of a notation that may have many semantics (Ptolemy)
		  Approaches to defining semantics
		  
		  Translators (denotational semantics)
		  - Typically used: map to something whose semantics you (think you) know

	      Interpreters (operational semantics)
	      - interpreters as model of semantics
	      - see WebDSL semantics
       
	      Reasoning about semantics
	      - Problem: How do you know the mapping is correct
            
		  you define it away: what the mapping does it what it means, by definition!
		  What do you do if you have several mappings to different targets? 
		  How do you make sure these do the same thing?
		  Pragmatics: Textual docs and (high coverage) testing
		  computational models: temproal data, reactive (mobl)
		  interpreter + generator must be the same
		  proofing vs. testing
		  "Interpreter is easier to understand and reason about"
		  model checking!�


Chapter : Building Generators

      when to build generators (as opposed to interpreters) 
      different approaches: text, Stratego, MPS (trafo) 
      special languages (target lang level + meta level)
      what are good gen languages (some criteria)
          integrating manually written code (generation gap)        
        parts from My DSL Best Practices Paper
      modifying generated code: not
      generation gap pattern 
      extension of tatget lang to make it more easily generatable (expr blocks)

Chapter : Building Interpreters  
 
      which languages are good candidates
      for building interpreters; some "patterns", Fowler book
      
Chapter : Transforming Models           

      when to use M2M (see best practices paper) 
      what are good trafo languages
      unidirectional, bidirectional (relational)
      incremental vs. batch)
      parts from My DSL Best Practices Paper
              		
Chapter : Testing DSLs		

		  Testing whether the DSL can express what it should - review, example code...
		  Testing the syntax: just write examples and see....
		  Testing whether all constraints work: tests (e.g. using the type system f/w)
		  Testing whether the semantics are correct
		    express "tests" in the same (or related) DSL
		  Then interpret or generate both and see if they fit
		  ... you can easily automate that!
		  If a DSL only describes structure: Constraints, and "xpath" on the genreated stuff
		
Chapter : Debugging DSLs		

		  debugging the DSL definition (use the debugger of your favourite LWB)
		  debugging the models: only makes sense for models with behavior
		  state machine debuggers exist
		  not a lot of support for "getting a debugger for free" from the language definition
		  problem: debugging on several levels (DSL, intermediate, implemetation), error traceability through the levels
		  MPS as an example?
		
Chapter : Language Composition

    Working With Several Language				
		Why composition is important		
		Kinds of Composition
		Technological approaches for langiage composition		
		What makes languages composable		
	    ... see the research ...	
	    mobl good example (embedded HTML)

Chapter : Bootstrapping DSL tools 

      What is bootstrapping
      Why is it useful: eat your own dogfood
      MPS: Extend the tool you use to build DSLs are you use it (dispatch)
				
Chapter : Documenting DSLs		
	
	    tutorials
	    rationales
	    implementation docuemntations

Chapter : Language evolution

	{not much absolutely solid, but a lot of guidelines}

	What axes of language evolution exist?
	...


Discussion
* Goal
* Who: roles
* Style/Audience
* Runnable Examples
* Handling Source Code 
* More Details in the outline
* Milestones + Deadlines
* Involvement of Guest Writers
* Level of Openness
* 

				
Scrapheap
    Use of textual DSLs together with graphical ones (DAMOS, Yakindu), and tables (ProR) 
    Introducing DSLs into an organization
	Enterprise Modeling (Repos, Scalability)
	take a look at best practices generally
	multi-viewpoints, annotations etc.		
	Documenting Models	
	Solvers, Searching ....
    Testing Models != Testing DSLs 
    Language Annotations in MPS
    Should my Architectural Principles go somewhere into the book?
	Protocol-SM im ArchAsLang Example oder im Verification Chapter?
	Visualization
    MPS C Zeug in Arch Chapter
    Contract Analysis and Verification in Arch Chapter?
    What makes proj editors work and usable
    combining textual and others. tables, graphical
    action DSL Book explain diff lang paradigms (functional, dataflow, imporative, OO, ....) (existing books...