Design
----------------------------------------------------------

In the intro, make it way more concrete, less philosophical (platonic, etc.)
  domain == colleciton of programs?
Provide more detail in the examples; example code?

Explain more clearly the difference and relationship metamodel / grammar. 

Tradeoffs between the dimensions?

we distinguish between the conceptual programs in the domain and those that
> can be expressed with a language. For a good DSL, these two sets are mostly
> the same for a given domain


semantics: emphasize documentation as an way to tell the end users.

Viewpoints: explain relationship between "DOmain == set of programs"
and "domain == several concerns". Do we need the term concern-specific DSL?


Progressive REfinement;
of these refinement steps may be expressed with a suitable DSL, re-alizing 
the various "refinement viewpoints" of the system (Fig.1
A refinement step is expressed with a suiotable DSL.  So an refinement step
> is one of the programs defined by the DSL.  Therefore we now are talking
> about refinement or transfromation DSLS. 

Move the Structuring Programs raus aus den Design Dimensions?

Bei den Case Studies erwähnen warum sie drin sind.

Case Studies: Jan Visualisierung, ISC Achmea, Spray, Youtrack Team? 

Checking constraints, different cost, at different times.

what about dimensions like:
static analyzability, users training/maturity, integration with existing software ? 

Expressivity:
John C. Mitchell, "On abstraction and the expressive power of programming languages", Science of Computer Programming, 1993
Matthias Felleisen, On the expressive power of programming languages,  Science of Computer Programming, 1991

Do we want to remove the formulas? Or at least provide examples for each?

Du könntest noch etwas in Richtung Freiheitsgrade unterbringen. Mit DSLs schränkt man von die (fast) unendliche Freiheit auf wenige Ausdrucksmöglichkeiten ein, dafür bekommt man leichtere Erlernbarkeit, weniger Fehleranfälligkeit, bessere Optimierbarkeit usw. Würde in den 2. Absatz passen.

Bei Expressivity: nochmal klar sagen dass auch Wissen über die Domäne im 
Fällt Dir eine gute Art und Weise ein zu beschreiben, wie durch Beschränkung und Abstraktion eine kleinere Sprache entsteht? 
-> Var, Immer gleich


bei den process aspects: kann man da auch Beispiele aus den Domänen bringen?

PLE: 
1) kompakte DSL, kleine Variantenprogramme, jedes Mal neuschreiben
2) Sprache ist orthogonal zu drübergelefter pos oder neg Var
3) DSL kann Var direkt ausdrücken (durch Komponenten, Schnittstellen, Vererbung)
4) ggfs. User Defined ABstractions erlauben, damit nicht für jede Var 
   die Sprache geändert werden muss
   

Sep of Concerns: 
Cross-Cutting Concerns?

In the modularization part: we seem to need more examples (especially in the
transformation etc.). But these will come in the implementation chapter as well.


Mention somewhere that the Platform may also influence the language:
example: refrigerator DSL, problem mit den versch. langen Zeiten, daher
zeiteinheiten in der Spache.


Implementation
----------------------------------------------------------
Checking constraints, different cost, at different times.
Synchronization via auto-running quick fixes.

Formale Methoden: Generiere TestfŠlle vom Modell automatisch; dann generiere
diese in die Zielwelt (codegen, interpreter) and run them.

testen von ausfŸhrbarem code: testet nicht, was neben *auch noch* geht...
... zusŠtzlich zu dem was gehen soll. (security)

IDE services: pretty printers, analyzers, debuggers, ...






General
------------------------------------------------------------
Clean up "I" and "we".
Einige der "I"s in passiv wandeln
Our

