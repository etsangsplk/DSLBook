\section{Spoofax Example}

In this section we look at an example roughly similar to the one for MPS and
Xtext discussed in the previous sections. We start with Mobl's data modelling
language, which we have already seen in previous chapters. 

To understand some of the discussions later, we first have to understand how
Spoofax organizes languages. In Spoofax, language definitions are typically
modularized and organized in directories. For example, Mobl's syntax definition
comes with a module for entities, which imports modules for statements and
expressions. These modules reside in the same directory:

\begin{lstlisting}[language=sdf]
module MoblEntities

imports
  MoblStatements
  MoblExpressions
\end{lstlisting}

\noindent Similarly, rewrite rules for program analysis, editor services,
program transformation, and code generation are organized in modules, which are imported
from Mobl's main module. Thereby, the various modules for program analysis,
editor services, and program transformation are organized in subdirectories:

\begin{lstlisting}[language=sdf]
module mobl

imports
  analysis/names
  analysis/types
  analysis/checks
  editor/complete
  editor/hover
  editor/refactor
  trans/desugar
  trans/normalize
  generate
\end{lstlisting}


\subsection{Referencing}

We will illustrate references to elements written in another DSL with Mobl's
screen definition language.
This sublanguage of Mobl is used to model the user interface of mobile applications.
Here is some example code:

\begin{lstlisting}[language=webdsl]
entity Task {
  name        : String 
  description : String 
  done        : Bool 
  date        : DateTime
}
\end{lstlisting}
\noindent This fragment is written in Mobl's data definition language. It
defines an entity \ic{Task} with some properties. We discussed the language in
several examples throughout the book already.

\begin{lstlisting}[language=webdsl]
screen root() {
  header("Tasks")
  group {
    list(t in Task.all()) {
      item { label(t.name) }
    }
  }
}
\end{lstlisting}

\noindent This is a screen definition written in Mobl's screen definition
language. It defines a root screen for a list of tasks, using the \ic{name} of a
\ic{Task} as a label for \ic{list} elements. There are two references to the
data model: \ic{Task} refers to an \ic{Entity}, and \ic{name} refers to a
property of that \ic{Entity}.In general, a \ic{Screen} defined in the UI model refers to \ic{Entities} from Mobl's entity language, and \ic{Fields} in a screen refer to \ic{Properties} in an entity.

\parhead{Structure} When referencing elements of another language, both
languages typically share a definition of identifiers. For example, the screen
definition language imports the same lexical module as the data modelling
language does via the expression module:
\begin{lstlisting}[language=sdf]
module MoblEntities

imports
	...
	MoblExpressions
\end{lstlisting}

\begin{lstlisting}[language=sdf]
module MoblExpressions

imports
	lexical/Common
\end{lstlisting}

\begin{lstlisting}[language=sdf]
module MoblScreens

imports
	lexical/Common
\end{lstlisting}

\noindent However, Spoofax also supports the use of different, typically
overlapping identifier definitions\footnote{This requires scannerless parsing,
since a scanner cannot handle overlapping lexical definitions.}. In this case,
the referencing language needs to import the identifier definition of the
referenced language.
Independent of the used identifiers in both languages, the reference has to be
resolved. Definition sites are already defined by the referenced language. The
corresponding references need to be defined in the referencing language by using
the namespaces from the referenced language:

\begin{lstlisting}[language=sdf]
"list" Item@=ID "in" Collection "{" Item* "}" -> List       {"ScreenList"}
Entity@ID "." "all" "(" ")"                   -> Collection {"Collection"}
\end{lstlisting}

\noindent This fragment from the syntax definition of the screen definition
language specifies lists and items in these lists. The screen definition
language defines its own namespace \ic{Item}. Items are declared in the list
head, introducing a variable for the current item of a collection. For example,
the screen definition we have seen earlier defines an item \ic{t}. When we
describe the collection, we can refer to entities. The corresponding namespace
\ic{Entity} is defined in the data modelling language. The screen definition
language uses the same namespace, to resolve the references into the referred
language.

Similarly, the screen definition language uses the namespace \ic{Property} from
the data modelling language, to refer to properties of entities:

\begin{lstlisting}[language=sdf]
"item" "{" ItemPart* "}"                -> Item     {"Item"}
"label" "(" Item@ID "." Property@ID ")" -> ItemPart {"LabelPart"}
\end{lstlisting}


\parhead{Type System} Similar to the name resolution, the type system of the
referencing language needs to be defined with the knowledge of the type system
of the referenced language.
\begin{lstlisting}[language=stratego]
constraint-error: 
  LabelPart(item, property) -> (property, "Label has to be a string.")
  where
    type := <type-of> property 
    not (!type => !StringType())
\end{lstlisting}

\noindent This constraint checks whether a label is of type string or not.
Therefore, it needs to determine the type of the property used as a label.

\parhead{Generators} The same holds for generators. Typically, they just share
knowledge about the naming and typing of generated code elements.
\todo{guido does it: Metaborg paper}



\subsection{Reuse}

As discussed in the previous sections, referencing concerns the case where the
referencing language is built with the knowledge about the referenced language,
so it can have direct dependencies. In the example above, the screen definition
language directly uses the namespaces and types from the entity language.

\parhead{Structure} In case of reuse, such a direct dependency is not allowed.
Our goal is to combine two \emph{independent} languages. To show this case, we
again use the same example as in the MPS section. We first introduce a trivial
DSL for defining relational table structures. These can optionally be mapped to
a data source, but the language makes no assumption about how this data source
looks (and which language is used to define it). Consequently, the grammar has
no dependency on another other one:

\begin{lstlisting}[language=sdf]
module DBTables
  "database" DB@=ID Table*         -> Database {"DB"}
  "table" Table@=ID Column*        -> Table    {"DBTable"}
  DataType Column@=ID ColumnMapper -> Column   {"DBColumn"}
          -> ColumnMapper {"DBMissingMapper"}
  
  "char"   -> DataType {"DBCharType"}
  "number" -> DataType {"DBNumberType"}
\end{lstlisting}

\noindent Again, the \ic{Column} rule has an optional \ic{ColumnMapper} which
works as the hook for reuse. The reusable language provides only a rule for a
missing column mapper. Rules for a concrete mapper are missing, but can be added
later in a sublanguage. In the next step, we want to be able to reference
properties from Mobl's data modelling language:

\begin{lstlisting}[language=mpsmodex]
database TaskDB

table Tasks

  char name        <- Task.name
  char description <- Task.description
\end{lstlisting}

\noindent To do this, we define an adapter module, which imports the reusable
table module and the data modelling language.
So far, \ic{ColumnMapper} is only an abstract concept, without a useful definition.
The adapter module now defines a rule for \ic{ColumnMapper}, which defines the concrete syntax of an actual mapper:
\begin{lstlisting}[language=sdf]
module MoblDBAdapter

imports
  DBTables
  MoblEntities
  
context-free syntax
   "<-" Entity@ID "." Property@ID -> ColumnMapper {"PropertyMapper"}
\end{lstlisting}

\noindent There is only one rule in this module, which defines a concrete
mapper. On the right-hand side, it uses the same sort as the rule in the table
module (\ic{ColumnMapper}). On the left-hand side, it refers to a property from
the imported data modelling language.

\parhead{Type System} The type system needs to connect types from the abstract
but reusable language to types from the language which actually reuses it. In
our example, the types of the database language needs to be connected to the
primitive types used in Mobl. Constraints ensure we only map those fields to a
particular column that are type-compatible:

\begin{lstlisting}[language=stratego]
module reuse/dbtables/analysis/types

rules
  constraint-error: 
    DBColumn(type, _, mapper) -> (mapper, "Incompatible type")
    where
      type' := <type-of> mapper ;
      <not(compatible-types)> (type, type')
      
  compatible-types: _ -> <fail>
\end{lstlisting}

\noindent The code above is defined in the generic implementation of the
database language. It assumes that a mapper has a type and checks if this type
is compatible to the declared column type. It defines a default rule for type
compatibility, which always fails.

The connection to the type system of the entity language can now be made in an
adapter module:

\begin{lstlisting}[language=sdf]
module analysis/types/adapter

imports
  module analysis/types 
  module reuse/dbtables/analysis/types 

rules
  type-of: PropertyMapper(e, p) -> <type-of> p
  
  compatible-types: (DBCharType(), StringType()) -> <id>
  compatible-types: (DBNumberType(), IntType())  -> <id>
\end{lstlisting}

\noindent The first rule defines the type of a \ic{PropertyMapper} to be the
type of the property. Then, two rules define type compatibility for Mobl's \ic{String} type
with the \ic{char} type in the table language, and Mobl's \ic{int} type with the
\ic{num} type.

\parhead{Generator} Similar to the Xtext example, we can use two strategies to
reuse a generator for the database language. The first strategy relies on
composition techniques of the target language\footnote{Obviously this works only
for OO languages where we can use the approach. It would be harder to do in, for
example, C.}. Like in the MPS example, the code generator of the database
language generates an abstract Java class for fetching data while Mobl's
original code generator generates Java classes from entities.
We can then define an additional generator, which generates a concrete subclass
which fetches data from entities.

The second strategy we discussed in the Xtext example addressed the generation
of inlined code, which requires an extendable generator of the reusable
language. With rewrite rules, this can be easily achieved in Spoofax. The
reusable generator calls a dedicated rule for generating the inlined code, but
defines only a failing implementation of this rule:
\begin{lstlisting}[language=stratego]
module reuse/table/generate

rules
  db-to-java: Column(t, n, mapper) -> 
       [Field([PRIVATE], t', n), Method([PROTECTED], BoolType, n', params, stmts)] 
  where
    n'    := <to-fetch-method-name> n ;
    param := <to-fetch-method-parameters> mapper ;
    stmts := <to-fetch-statements(|n)> mapper
    
  to-fetch-method-parameters: _ -> <fail>
  to-fetch-statements(|n)   : _ -> <fail>
\end{lstlisting}

\noindent This rule generates code for columns. It generates a private field and
a protected method to fetch the content. This method needs a name, parameters,
and an implementation. We assume that the method name is provided by the generic
generator. For the other parts, the generic generator only provides failing
placeholder rules. These have to be implemented in a concrete reuse setting:


\begin{lstlisting}[language=stratego]
module generate/java/adapter
imports 
  generate/java
  reuse/table/generate
  
rules
 to-fetch-method-parameters: 
   PropertyMapper(entity, property) -> [Param(type, "entity")]
   where
     type := <entity-to-java-type> entity
     
 to-fetch-statements(|field-name):
   PropertyMapper(entity, property) -> 
         [Assign(VarRef(field-name), MethodCall(VarRef("entity"), m, []), Return(True())] 
   where
     m := <property-to-get-method-name> property
\end{lstlisting} 

\noindent This adapter code generates a single parameter for the fetch method.
It is named \ic{entity} and its type is provided by a rule from the entity
language generator. This rule maps entity names to Java types. For the
implementation body, the second rule generates an assignment and a return
statement. The assignment calls the getter method for the property. Again, the
name of this getter method is provided by the entity language generator.

\subsection{Extension}

Because of Spoofax' module system and rule-based nature, language extension
feels like ordinary language development. When we want to add a new feature for
a language, we simply create new modules for syntax, type system, and code
generation rules. These modules import the existing modules as needed. In the
syntax definition, we can extend a syntactic sort with new definition rules. In
the type system, we add additional \ic{type-of} rules for the new language
constructs and define constraints for well-typedness. Finally, we add new rules
to the generator, which can handle the new language constructs.
Since in case of extension, the extending language has a dependency on, and is
developed with knowledge of the base language, it can be designed in a way that
will not lead to parsing ambiguities. 
However, the composition of different, independent extensions of the same base language might lead to ambiguities.
These ambiguities will only occur between the extensions.
The base language will stay unambiguous, since each module is only imported once. 

\subsection{Restriction}

In the easiest case, restriction can be handled on the level of syntax rules.
SDF's import directives allow not only for renaming of sorts, but also for replacing complete syntax rules.
To remove a rule completely, we can replace it with a dummy rule for a sort, which is not used anywhere.
The following example restricts Mobl to a version without property access expressions:

\begin{lstlisting}[language=sdf]
module MoblWithoutPropertyAccess

imports
  Mobl [Exp "." ID -> Exp => -> UnusedDummySort]
\end{lstlisting}

In more complex cases, only parts of a syntax rule need to be restricted.
For example, we might restrict Mobl's screen definition language to support only unparametrized screen definitions.

\subsection{Embedding}

Embedding can be easily achieved in Spoofax. 
In general, the procedure is very similar to reuse.
We discussed embedding already in \sect{Sec:spoofax-trafo-codegen}, where we
embedded the target language into Stratego.
We will discuss the embedding of HQL into mobl as another example here.

\parhead{Structure} 
Embedding requires an additional syntax definition module which imports the main
modules of the host and guest language and defines additional syntax rules which
realise the embedding. 
In target language embedding into Stratego, this was achieved with quotations
and antiquotations.
The following module is a first attempt to embedd HQL into mobl:

\todo{guido does it: SQL in Java example from earlier?
Two flavors of Ext: Ext & ExtWIthEmbdFlavour
One Style of Emb: Embedding: The two (or more) langs don't know each other
before they are enbedded.

}


\begin{lstlisting}[language=sdf]
module Mobl-HQL

imports Mobl Hql

context-free syntax

  QueryRule           -> Exp {cons("HqlQuery")}
  DeleteStatement ";" -> Statement {cons("HqlStatement")}
  
  "~" Exp             -> Expression {cons("DslExp")}  
\end{lstlisting}

The module imports syntax definitions of host and guest language.
Tt embedds HQL queries as mobl expressions and HQL's delete statement as a mobl
statement without any quotations.
Furthermore, it allows to use quoted mobl expressions inside HQL queries.

There are two issues in this module.
First, we might accidentially merge sorts with the same name in host and guest
language.
Since both languages are developed independently, we cannot assume mutual
exclusive names in their syntax definitions.
One way to avoid name clashes, is to rename sorts manually during import:

\begin{lstlisting}[language=sdf]
module Mobl-HQL

imports 
  Mobl 
  Hql [ QueryRule       => HqlQueryRule
        DeleteStatement => HqlDeleteStatement
        Expression      => HqlExpression
        ...
      ]
\end{lstlisting}

This can be quite cumbersome, since we have to rename all sorts, not only the
embedded ones.
But we can rely on Spoofax to generate a renamed version of a language
definition.
This \emph{Mix} is a parametrized syntax definition, where Spoofax replaces each
sort by a parametrized sort:

\begin{lstlisting}[language=sdf]
module HqLMix[Context]

imports 
  Hql [ QueryRule       => QueryRule[[Context]]
        DeleteStatement => DeleteStatement[[Context]]
        Expression      => Expression[[Context]]
        ...
      ]
\end{lstlisting}

The parameter allows us to distinguish sorts from the host and the target
language. 
We can then import this module with an actual parameter and use the
parametrized sorts in the embedding:

\begin{lstlisting}[language=sdf]
module Mobl-HQL

imports Mobl HqlMix[HQL] 

context-free syntax

  QueryRule[[HQL]]           -> Exp {cons("HqlQuery")}
  DeleteStatement[[HQL]] ";" -> Statement {cons("HqlStatement")}
  
  "~" Exp                    -> Expression[[HQL]] {cons("DslExp")}  
\end{lstlisting}

The second issue is ambiguity.
We need to integrate HQL queries into the precedence rules for mobl expressions.
Thereby, we do not have to repeat all rules.
Preceeding and succeeding rules are sufficient:

\begin{lstlisting}[language=sdf]
context-free priorities

    Assignment                      -> Exp
  > QueryRule[[HQL]]                -> Exp
  > "if" "(" Exp ")" Exp "else" Exp -> Exp  
\end{lstlisting}

% Further ambiguities might arise if host and target language share same prefixes
% or suffixes for embedded constructs.
% For example, in \code{from Page as p} the \code{as} phrase can be either
% an alias in the HQL query or a cast in mobl.
% To disambiguate this, we can repeat rules from the host or target language
% definition and annotate them:

\parhead{Type System} 
The type system needs to connect the types from the host and guest languages.
This can be achieved by adding typing rules for embedded and antiquoted constructs. 
For example, we need to connect the HQL type of a query to a mobl type of the
embedding expression. Since mobl and HQL share the same types, this is simple:

\begin{lstlisting}[language=stratego]
type-of: HqlQuery(q) -> <type-of> q
\end{lstlisting}

In other cases, types can connected by mappings between host and guest types.
Additional constraints can check for incompatible types which cannot be mapped
into the host or guest language.

\parhead{Generator} There are two strategies for code generation for embedded
languages. If the guest language provides a suitable code generator, we can
combine it with the code generator of the host language. First, we need rules
which generate code for embedded constructs. These rules have to extend the host
generator by delegating to the guest generator. Next, we need rules which
generate code for antiquoted constructs. These rules have to extend the guest
generator by delegating to the host generator.

Another strategy is to define a model-to-model transformation which desugars (or
"assimilates") embedded constructs to constructs of the host language. This
transformation is then applied first, before the host generator is applied to
generate code. The embedding of a target language into Stratego is an example
for this approach. The embedded target language will be represented by abstract
syntax trees for code generation fragments. These trees need to be desugared
into Stratego pattern matching constructs. For example, the embedded \ic|[return
|[x]|; ]| will yield the following abstract syntax tree:

\begin{lstlisting}
ToJava(
  Return(
    FromJava(
      Var("x")
    )
  )
) 
\end{lstlisting}

\noindent In ordinary Stratego without an embedded target language, we would
have written the pattern \ic{Return(x)} instead. The corresponding abstract
syntax tree looks like this:
\begin{lstlisting}
NoAnnoList(
  App(
    Op("Result"),
    [Var("x")]
  )
) 
\end{lstlisting}

\noindent The desugar transformation now needs to transform the first abstract
syntax tree into the second one:

\begin{lstlisting}[language=stratego]
desugar-all: x -> <bottomup(try(desugar-embedded))> x

desugar-embedded: ToJava(e) -> <ast-to-pattern> e

ast-to-pattern: 
  ast -> pattern
  where
    if !ast => FromJava(e) then
      pattern := e
    else
      c       := <constructor> ast ;
      args    := <arguments> ast ;
      ps      := <map(ast-to-pattern)> args ;
      pattern := NoAnnoList(App(Op(c), ps))
\end{lstlisting}

\noindent The first rule drives the desugaring of the overall tree. It tries to
apply \ic{desugar-embedded} in a bottom-up traversal. The only rule for desugaring
embedded target language code matches the embedded code and applies
\ic{ast-to-pattern} to it. If this is applied to an antiquote, the contained
subnode is already a regular Stratego pattern. Otherwise, the node has to be an
abstract syntax tree of the target language. It is deconstructed into its
constructor and subtrees, which are desugared into patterns as well. The
resulting patterns and the constructor are then used to construct the overall
pattern.