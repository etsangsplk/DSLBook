\section{Spoofax Example}

In this section we look at an example roughly similar to the one for MPS and
Xtext discussed in the previous sections. We start with Mobl's data modelling
language, which we have already seen in previous chapters. 

To understand some of the discussions later, we first have to understand how
Spoofax organizes languages. In Spoofax, language definitions are typically
modularized and organized in directories. For example, Mobl's syntax definition
comes with a module for entities, which imports modules for statements and
expressions. These modules reside in the same directory:

\begin{code}
module MoblEntities

imports
  MoblStatements
  MoblExpressions
\end{code}

Similarly, rewrite rules for program analysis, editor services, program
transformation, and code generation are organized in modules, which are imported
from Mobl's main module. Thereby, the various modules for program analysis,
editor services, and program transformation are organized in subdirectories:

\begin{code}
module mobl

imports
  analysis/names
  analysis/types
  analysis/checks
  editor/complete
  editor/hover
  editor/refactor
  trans/desugar
  trans/normalize
  generate
\end{code}


\subsection{Referencing}

We will illustrate references to elements written in another DSL with Mobl's
screen definition language, where a \ic{Screen} defined in the UI model refers
to \ic{Entities} from Mobl's entity language, and \ic{Field}s in a screen refer
to entity \ic{Property}. Here is some example code:

\begin{code} entity Task {
  name        : String description : String done        : Bool date        :
  DateTime
}
\end{code}
\noindent This fragment is written in Mobl's data definition language. It
defines an entity \ic{Task} with some properties. We discussed the language in
several examples throughout the book already.

\begin{code}
screen root() {
  header("Tasks")
  group {
    list(t in Task.all()) {
      item { label(t.name) }
    }
  }
}
\end{code}

\noindent This is a screen definition written in Mobl's screen definition
language. It defines a root screen for a list of tasks, using the \ic{name} of a
\ic{Task} as a label for \ic{list} elements. There are two references to the
data model: \ic{Task} refers to an \ic{Entity}, and \ic{name} refers to a
property of that \ic{Entity}.

\parhead{Structure} When referencing elements of another language, both
languages typically share a definition of identifiers. For example, the screen
definition language imports the same lexical module as the data modelling
language does via the expression module:
\begin{code}
module MoblEntities

imports
	\ldots
	MoblExpressions
\end{code}

\begin{code}
module MoblExpressions

imports
	lexical/Common
\end{code}

\begin{code}
module MoblScreens

imports
	lexical/Common
\end{code}

\noindent However, Spoofax also supports the use of different, typically
overlapping identifier definitions\footnote{This requires scannerless parsing,
since a scanner cannot handle overlapping lexical definitions.}. In this case,
the referencing language needs to import the identifier definition of the
referenced language.
Independent of the used identifiers in both languages, the reference has to be
resolved. Definition sites are already defined by the referenced language. The
corresponding references need to be defined in the referencing language by using
the namespaces from the referenced language:

\begin{code}
"list" Item@=ID "in" Collection "{" Item* "}" -> List       {"ScreenList"}
Entity@ID "." "all" "(" ")"                   -> Collection {"Collection"}
\end{code}

\noindent This fragment from the syntax definition of the screen definition
language specifies lists and items in these lists. The screen definition
language defines its own namespace \ic{Item}. Items are declared in the list
head, introducing a variable for the current item of a collection. For example,
the screen definition we have seen earlier defines an item \ic{t}. When we
describe the collection, we can refer to entities. The corresponding namespace
\ic{Entity} is defined in the data modelling language. The screen definition
language uses the same namespace, to resolve the references into the referred
language.

Similarly, the screen definition language uses the namespace \ic{Property} from
the data modelling language, to refer to properties of entities:

\begin{code}
"item" "{" ItemPart* "}"                -> Item     {"Item"}
"label" "(" Item@ID "." Property@ID ")" -> ItemPart {"LabelPart"}
\end{code}


\parhead{Type System} Similar to the name resolution, the type system of the
referencing language needs to be defined with the knowledge of the type system
of the referenced language.
\begin{code}
constraint-error: 
  LabelPart(item, property) -> (property, "Label has to be a string.")
  where
    type := <type-of> property 
    not (!type => !StringType())
\end{code}

\noindent This constraint checks whether a label is of type string or not.
Therefore, it needs to determine the type of the property used as a label.

\parhead{Generators} The same holds for generators. Typically, they just share
knowledge about the naming and typing of generated code elements.



\subsection{Reuse}

As discussed in the previous sections, referencing concerns the case where the
referencing language is built with the knowledge about the referenced language,
so it can have direct dependencies. In the example above, the screen definition
language directly uses the namespaces and types from the entity language.

\parhead{Structure} In case of reuse, such a direct dependency is not allowed.
Our goal is to combine two \emph{independent} languages. To show this case, we
again use the same example as in the MPS section. We first introduce a trivial
DSL for defining relational table structures. These can optionally be mapped to
a data source, but the language makes no assumption about how this data source
looks (and which language is used to define it). Consequently, the grammar has
no dependency on another other one:

\begin{code} 
module DBTables
  "database" DB@=ID Table*         -> Database {"DB"}
  "table" Table@=ID Column*        -> Table    {"DBTable"}
  DataType Column@=ID ColumnMapper -> Column   {"DBColumn"}
  
  -> ColumnMapper {"DBMissingMapper"}
  
  "char"   -> DataType {"DBCharType"}
  "number" -> DataType {"DBNumberType"}
\end{code}

\noindent Again, the \ic{Column} rule has an optional \ic{ColumnMapper} which
works as the hook for reuse. The reusable language provides only a rule for a
missing column mapper. Rules for a concrete mapper are missing, but can be added
later in a sublanguage. In the next step, we want to be able to reference
properties from Mobl's data modelling language:

\begin{code}database TaskDB

table Tasks

  char name        <- Task.name
  char description <- Task.description
\end{code}

\noindent To do this, we define an adapter module, which imports the reusable
table module and the data modelling language:

\todo{add rule for column mapper}
\begin{code}
module MoblDBAdapter

imports
  DBTables
  MoblEntities
  
context-free syntax

   "<-" Entity@ID "." Property@ID -> ColumnMapper {"PropertyMapper"}
\end{code}

\noindent There is only one rule in this module, which defines a concrete
mapper. On the right-hand side, it uses the same sort as the rule in the table
module (\ic{ColumnMapper}). On the left-hand side, it refers to a property from
the imported data modelling language.

\parhead{Type System} The type system needs to connect types from the abstract
but reusable language to types from the language which actually reuses it. In
our example, the types of the database language needs to be connected to the
primitive types used in Mobl. Constraints ensure we only map those fields to a
particular column that are type-compatible:

\begin{code}
module reuse/dbtables/analysis/types

rules
  constraint-error: 
    DBColumn(type, _, mapper) -> (mapper, "Incompatible type")
    where
      type' := <type-of> mapper ;
      <not(compatible-types)> (type, type')
      
  compatible-types: _ -> <fail>
\end{code}

\noindent The code above is defined in the generic implementation of the
database language. It assumes that a mapper has a type and checks if this type
is compatible to the declared column type. It defines a default rule for type
compatibility, which always fails.

The connection to the type system of the entity language can now be made in an
adapter module:

\begin{code} 
module analysis/types/adapter

imports
  module analysis/types 
  module reuse/dbtables/analysis/types 

rules

  type-of: PropertyMapper(e, p) -> <type-of> p
  
  compatible-types: (DBCharType(), StringType()) -> <id>
  compatible-types: (DBNumberType(), IntType())  -> <id>
\end{code}

The first rule defines the type of a \ic{PropertyMapper} to be the type of the
property. Then, two rules define type compatibility for Mobl's \ic{String} type
with the \ic{char} type in the table language, and Mobl's \ic{int} type with the
\ic{num} type.

\parhead{Generator} Similar to the Xtext example, we can use two strategies to
reuse a generator for the database language. The first strategy relies on
composition techniques of the target language. Like in the MPS example, the code
generator of the database language generates an abstract Java class for fetching
data while Mobl's original code generator generates Java classes from entities.
We can then define an additional generator, which generates a concrete subclass
which fetches data from entities.

The second strategy we discussed in the Xtext example addressed the generation
of inlined code, which requires an extendable generator of the reusable
language. With rewrite rules, this can be easily achieved in Spoofax. The
reusable generator calls a dedicated rule for generating the inlined code, but
defines only a failing implementation of this rule:
\begin{code}
module reuse/table/generate

rules
  db-to-java: Column(t, n, mapper) -> 
       [Field([PRIVATE], t', n), Method([PROTECTED], BoolType, n', params, stmts)] where
    n'    := <to-fetch-method-name> n ;
    param := <to-fetch-method-parameters> mapper ;
    stmts := <to-fetch-statements(|n)> mapper
    
  to-fetch-method-parameters: _ -> <fail>
  to-fetch-statements(|n)   : _ -> <fail>
\end{code}

\noindent This rule generates code for columns. It generates a private field and
a protected method to fetch the content. This method needs a name, parameters,
and an implementation. We assume that the method name is provided by the generic
generator. For the other parts, the generic generator only provides failing
placeholder rules. These have to be implemented in a concrete reuse setting:


\begin{code}
module generate/java/adapter

imports 
  generate/java
  reuse/table/generate
  
rules

 to-fetch-method-parameters: 
   PropertyMapper(entity, property) -> [Param(type, "entity")]
   where
     type := <entity-to-java-type> entity
     
 to-fetch-statements(|field-name):
   PropertyMapper(entity, property) -> 
         [Assign(VarRef(field-name), MethodCall(VarRef("entity"), m, []), Return(True())] 
   where
     m := <property-to-get-method-name> property
\end{code} 

\noindent This adapter code generates a single parameter for the fetch method.
It is named \ic{entity} and its type is provided by a rule from the entity
language generator. This rule maps entity names to Java types. For the
implementation body, the second rule generates an assignment and a return
statement. The assignment calls the getter method for the property. Again, the
name of this getter method is provided by the entity language generator.

\subsection{Extension}

Because of Spoofax' module system and rule-based nature, language extension
feels like ordinary language development. When we want to add a new feature for
a language, we simply create new modules for syntax, type system, and code
generation rules. These modules import the existing modules as needed. In the
syntax definition, we can extend a syntactic sort with new definition rules. In
the type system, we add additional \ic{type-of} rules for the new language
constructs and define constraints for well-typedness. Finally, we add new rules
to the generator, which can handle the new language constructs.
Since in case of extension, the extending language has a dependency on, and is
developed with knowledge of the base language, it can be designed in a way that
will not lead to parsing ambiguities. 

\todo{How about using several independent extensions of the same base language
in a program? Do we have to define a "composite" language? Especially in case
these extensions would lead to ambiguities?}


\subsection{Embedding}

Embedding can be easily achieved in Spoofax. The procedure is very similar to
reuse\footnote{We discussed embedding already in the chapter on code generation
(\todo{ref}), where we embedded the target language into Stratego.}. We will
use the embedding of the Mobl's expression language into Mobl's screen
definition language as another example here. Instead of just referring to
entities, we reuse the whole expression language now.

\parhead{Structure} There are two styles for embedding. The first one requires
an embedding module which imports the main modules of the host and guest
language and defines additional syntax rules for embedding (quotations and
antiquotation). We have seen this in the target language embedding in templates
(\todo{ref}). In the second style, the syntax definition of the host language
directly employs syntactic sorts of the guest language. For the screen
definition language, we want to reuse variable definitions and expressions in
list heads, as well as expressions in labels:
\todo{This is not really embedding, right? It is extension with an embeddign
flavor, since MoblScreens now has a direct dependency to MoblExpressions.
Right?}

\begin{code}
module MoblScreens

imports MoblExpressions 

context-free syntax

  "list" VarDef "in" Exp "{" Item* "}" -> List     {"ScreenList"}
  "label" "(" Exp ")"                  -> ItemPart {"LabelPart"}
\end{code}

\parhead{Type System} The type system needs to connect the types from the host
and guest languages. This can be achieved by adding typing rules for embedded
and antiquoted constructs. In the embedding of expressions, we do not have
antiquotes. However, we expect certain types for embedded expressions. For
example, the expression in a list head needs to be a collection. The type from
the variable definition needs to be compatible with the content of the
collection. Finally, the expression for a label should provide a string. We can
capture these requirements in constraints:


\begin{code}
constraint-error: 
  ScreenList(_, e, _) -> (e, "Needs to provide a collection.")
  where
    type := <type-of> e;
    <not(collection-type)> type
    
constraint-error: 
  ScreenList(VarDef(t, _), e, _) -> (t, "Cannot assign collection elements (incompatible types).")
  where
    type  := <type-of> e ;
    type' := <collection-type> type ;
    <not(is-assignable)> (t, type')
\end{code}


\parhead{Generator} There are two strategies for code generation for embedded
languages. If the guest language provides a suitable code generator, we can
combine it with the code generator of the host language. First, we need rules
which generate code for embedded constructs. These rules have to extend the host
generator by delegating to the guest generator. Next, we need rules which
generate code for antiquoted constructs. These rules have to extend the guest
generator by delegating to the host generator.

The screen definition language needs to generate a method which returns the text
of a label. Therefore, it relies on the code generator for expressions, to
translate the expression into Java code:

\begin{code}
generate-label-text-method: 
  LabelPart(exp) -> Method([PUBLIC()], StringType(), "getText", [Return(java-exp)])
  where
    java-exp := <to-java> exp
\end{code}

\noindent

Another strategy is to define a model-to-model transformation which desugars (or
"assimilates") embedded constructs to constructs of the host language. This
transformation is then applied first, before the host generator is applied to
generate code. The embedding of a target language into Stratego is an example
for this approach. The embedded target language will be represented by abstract
syntax trees for code generation fragments. These trees need to be desugared
into Stratego pattern matching constructs. For example, the embedded \ic|[return
|[x]|; ]| will yield the following abstract syntax tree:

\begin{code}
ToJava(
  Return(
    FromJava(
      Var("x")
    )
  )
) 
\end{code}

\noindent In ordinary Stratego without an embedded target language, we would
have written the pattern \ic{Return(x)} instead. The corresponding abstract
syntax tree looks like this:
\begin{code}
NoAnnoList(
  App(
    Op("Result"),
    [Var("x")]
  )
) 
\end{code}

\noindent The desugar transformation now needs to transform the first abstract
syntax tree into the second one:

\begin{code}
desugar-all: x -> <bottomup(try(desugar-embedded))> x

desugar-embedded: ToJava(e) -> <ast-to-pattern> e

ast-to-pattern: 
  ast -> pattern
  where
    if !ast => FromJava(e) then
      pattern := e
    else
      c       := <constructor> ast ;
      args    := <arguments> ast ;
      ps      := <map(ast-to-pattern)> args ;
      pattern := NoAnnoList(App(Op(c), ps))
\end{code}

The first rule drives the desugaring of the overall tree. It tries to apply
\ic{desugar-embedded} in a bottom-up traversal. The only rule for desugaring
embedded target language code matches the embedded code and applies
\ic{ast-to-pattern} to it. If this is applied to an antiquote, the contained
subnode is already a regular Stratego pattern. Otherwise, the node has to be an
abstract syntax tree of the target language. It is deconstructed into its
constructor and subtrees, which are desugared into patterns as well. The
resulting patterns and the constructor are then used to construct the overall
pattern.