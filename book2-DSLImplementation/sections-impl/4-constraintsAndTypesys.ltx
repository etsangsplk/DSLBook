\chapter{Constraints}
\label{ch:constraints}

\chapterabstract{Constraints are Boolean expressions that must be true for
every instance of a language. Together with type systems, which are discussed
in the next chapter, they ensure the static semantics of a language. The
chapter introduces the concept, some considerations regarding languages
suitable for expressing constraints and provides examples with our tools.}

\noindent

As we have explained in the DSL Design part of the book, not all programs that
conform to the structure (AST, meta model) of a language are valid. Language
definitions include further restrictions that cannot be expressed purely by
structure. Such additional restrictions are typically called constraints. 

Constraints are Boolean conditions that have to evaluate to \ic{true} in order
for the model to be correct ("does \ic{expr} hold?")\footnote{Constraints
represent the static semantics of a language. The execution semantics are
typically represented by transformations, generators or interpreters.}. An error
message is reported if the expression evaluates to \ic{false} ("\ic{expr} does
not hold!"). Constraints are typically associated a particular language concept
("for each instance of \ic{x}, \ic{expr-with-x} must hold"). Constraints address
model correctness beyond syntax and scoping/linking, but short of actual
execution semantics.



There are two major kinds of constraints we can distinguish: well-formedness and
type systems. Examples for well-formedness constraints include:

\begin{itemize}
  \item uniqueness of names in lists of elements (e.g.,~functions in a
  namespace);
  \item every non-start state of a state machine has at least one incoming
  transition;
  \item a variable is defined before it is used (statement ordering);
\end{itemize}

\noindent Type system rules are different in that they verify the correctness of
types in programs, e.g.,~they make sure you don't assign a \ic{float} to an
\ic{int}. Particularly in expression languages, type calculation and checking
can become quite complicated and therefore warrants special support. This is why
we distinguish between constraints in general (covered in this chapter)  and
type systems (which we cover in the next chapter). 

Constraints can be implemented with any language or framework that is able to
query a model and report errors to the user. To make constraint checking
efficient, it is useful if the language has the following characteristics:

\begin{itemize}
  \item It should be able to effectively navigate and filter the model. Support
  for path expressions (as in \ic{aClass.operations.arguments.type} as a way to
  find out the types of all arguments of all operations in a class) is extremely
  useful.
  \item Support for higher-order functions is useful so one can write
  generic algorithms and traversal strategies
  \item A good collection language, often making use of higher-order functions,
  is very useful, so it is easily possible to filter collections, create
  subsets or get the set of distinct values in a list.
  \item Finally, it is helpful to be able to associate a constraint
  declaratively with the language concept for whose instances it should be
  executed
\end{itemize}

\noindent Here is an example constraint written in a pseudo-language:

\begin{lstlisting}[morekeywords={constraint, for, expression, message, this}]
constraint for:  
  Class
expression: 
  this.operations.arguments.type.filter(ComplexNumber).isNotEmpty &&
  !this.imports.any(i|i.name == "ComplexNumberSupportLib")
message: 
  "class "+this.name+" uses complex numbers, "+
     "so the ComplexNumberSupportLib must be imported"
\end{lstlisting}

\noindent 
Some kinds of constraints require specialized data structures to be built or
maintained in sync with the program. Examples include dead code detection,
missing returns in some branches of a method's body or read access to an
uninitialized variable. To be able to find these kinds of errors statically, a
dataflow graph has to be constructed from the program. A dataflow graph models
the various execution paths through a (part of a) program. Once a dataflow graph
is constructed, it can be used to check whether there exists a path from program
start to a variable read without coming across a write to the same variable. We
show an example of using a data flow graph in the MPS example
(\sect{mpsconstraints}).


\section{Constraints in Xtext}
\label{xtextconstraints}

Just like scopes, constraints are implemented in Java or any other JVM
language\footnote{As mentioned earlier, a language that provides higher order
functional abstractions such as Xtend is very useful for navigating and querying
ASTs}. Developers add methods to a validator class generated by the Xtext
project wizard.
In the end, these validations plug into the EMF validation
framework\footnote{Other EMF \icsn{EValidator} implementations can be used in
Xtext as well.}.

A constraint checking method is a Java method with the following
characteristics: it is public, returns \ic{void}, has any name, it has a
single argument of the type for which the check should apply, and it has the \ic{@Check} annotation. 
For example, the following method is a check that is invoked for all instances
of \ic{CustomState} (i.e.~not for start states and background states). It checks
that each such state can actually be reached by verifying that it has incoming
transitions (expressed via a \ic{ChangeStateStatement}):
	

\begin{lstlisting}[language=java]
@Check(CheckType.NORMAL)
public void checkOrphanEndState( CustomState ctx ) {
    CoolingProgram coopro = Utils.ancestor(ctx, CoolingProgram.class);
    TreeIterator<EObject> all = coopro.eAllContents();
    while ( all.hasNext() ) {
        EObject s = all.next();
        if ( s instanceof ChangeStateStatement ) {
            ChangeStateStatement css = (ChangeStateStatement) s;
            if ( css.getTargetState() == ctx ) return;
        }
    }
    error("no transition ever leads into this state", 
    	CoolingLanguagePackage.eINSTANCE.getState_Name());
}
\end{lstlisting}


\noindent The method retrieves the cooling program that owns the \ic{ctx} state,
then retrieves all of its descendants and iterates over them. If the descendant
is a \ic{ChangeStateStatement}, and if the \ic{targetState} property of the
\ic{ChangeStateStatement} references the current state, then we return: we have
found a transition leading into the current state. If we don't find one of
these, we report an error. An error report contains the error message, a
severity (\ic{INFO}, \ic{WARNING}, \ic{ERROR}), the element to which it is
attached, as well as the particular feature\footnote{Feature is EMF's term for
properties, references and operations of \icsn{EClass}es.} of that element that
should be highlighted. The \ic{CheckType.NORMAL} in the annotation defines when
this check should run:

\begin{itemize}
  \item \ic{CheckType.NORMAL}: run when the file is saved 
  \item \ic{CheckType.FAST}: run after each model change (i.e.~after each keypress) 
  \item \ic{CheckType.EXPENSIVE}: run only if requested via the context menu
\end{itemize}
 
Note that Xtext (nor any of the other tools) supports impact analysis by
default. Impact analysis is a strategy for finding out whether a particular
constraint can potentially be affected by a particular change, and only
evaluating the constraint if it can. Impact analysis can improve performance if
this analysis is faster than evaluating the constraint itself. For local
constraints this is usually not the case. Only for non-local constraints that
cover large parts of the model (and possibly require loading additional
fragments), impact analysis is important. Xtext uses a pragmatic approach in the
sense that these constraints are marked as \ic{EXPENSIVE} and run only on
request (over lunch, during nightly build).

Let us get back to the example about orphan states. The implementation of the
constraint checks orphan-ness separately for each state. In doing so, it gets
all descendants of the cooling program \emph{for each state}. This can be a
scalability problem for larger programs. To solve this issue, one would write
\emph{a single constraint} for the whole cooling program that identifies all
orphan states in one or maybe two scans through the program. This constraint
could then be marked as \ic{EXPENSIVE} as programs get really big. In general,
local constraints (as shown in the code above) are easier to write than
the more optimized global constraints. However, the latter often perform better. 


\section{Constraints in MPS}
\label{mpsconstraints}

\subsection{Simple Constraints} 

MPS' approach to constraints is very similar to Xtext's\footnote{Note that in
MPS, constraints are implemented as part of the type system, in so-called
Non-Typesystem Rules. MPS also has a language aspect called Constraints, but
as we have seen before, this is used for something else.}.
The main difference is that the constraint is written in \ic{BaseLanguage}, which is an extended
version of Java that has some of the features that makes constraints more
concise. Here is the code for the same \emph{state unreachable} constraint,
which we can make use of in the state machines extension to C:

\begin{lstlisting}[language=mps] 
checking rule stateUnreachable {                                                                                                                                                                         
  applicable for concept = State as state                                                                                                                                                                       
  do {                                                                                                                                                                                                          
    if (!state.initial && 
        state.ancestor<concept = Statemachine>.
            descendants<concept = Transition>.
            where({~it => it.target == state; }).isEmpty) { 
        error "orphan state - can never be reached" -> state; 
    }
  }                                                                                                                                                                                                             
}                                                                                                                                                                                                               
\end{lstlisting}

\noindent 
Currently there is no way to control when a constraint is run, it is decided
based on some MPS-internal algorithm. However, pressing \keystroke{F5} in a
program or explicitly running the model checker forces all constraints to be
reevaluated.

\subsection{Dataflow}

The foundation for data flow analysis is the so-called data flow graph. This is
a data structure that describes the flow of data through a program's code. For
example, in \ic{int i = 42; j = i + 1;} the \ic{42} is "flowing" from the \ic{init}
expression in the local variable declaration into the variable \ic{i} and then,
after adding \ic{1}, into \ic{j}. Data flow analysis consists of two tasks: building a
data flow graph for a program, and then performing analysis on this data flow
graph to detect problems in the program.

MPS comes with predefined data structures for representing data flow graphs, a
DSL for defining how the graph can be derived from language concepts (and hence,
programs) and a set of default analyses that can be integrated into your
language\footnote{MPS also comes with a framework for developing custom analyses; however, this is
beyond the scope of this book.}. We will look at all these ingredients in this
section\footnote{To play with the data flow graph, you can select a method in a Java program and then use
the context menu on the method; select \icsn{Language Debug -> Show Data Flow
Graph}. This will render the data flow graph graphically and constitutes a good
debugging tool when building your own data flow graphs and analyses.}.



\parhead{Building a Data Flow Graph} Data flow is specified in the
\emph{Dataflow} aspect of language definitions. There you can add
data flow builders (DFBs) for your language concepts. These are programs
expressed in MPS' data flow DSL that build the data flow graph for instances of
those concepts in programs. Here is the DFB for \ic{LocalVariableDeclaration}.
\begin{lstlisting}[language=mps]
data flow builder for LocalVariableDeclaration { 
  (node)->void { 
    if (node.init != null) { 
      code for node.init 
      write node = node.init 
    } else {
      nop
    }
  } 
}
\end{lstlisting}

\noindent 
If the \ic{LocalVariableDecaration} has an \ic{init} expression (it is
optional!), then the DFB for the \ic{init} expression has to be executed. The
\ic{code for} statement calls the DFB for the node that is passed as its
argument. Then we perform an actual data flow definition: the \ic{write node =
node.init} specifies that write access is performed on the current node. The
statement also expresses that whatever value was in the \ic{init} expression is
now in the node itself. If there is no \ic{init} expression, we still want to
mark the \ic{LocalVariableDeclaration} node as visited by the data flow builder
-- the program flow has come across this node. A subsequent analysis reports
all program nodes that have \emph{not} been visited by a DFB as dead code. So
even if a node has no further effect on a program's data flow, it has to be
marked as visited using \ic{nop}.

To illustrate a \ic{read} statement, we can take a look at the
\ic{LocalVariableRef} expression which read-accesses the variable it
references. Its data flow is defined as \ic{read node.var}, where \ic{var} is
the name of the reference that points to the referenced variable. 

In an \ic{AssignmentStatement}, we first execute the DFB for the \ic{rvalue}
and then "flow" the \ic{rvalue} into the \ic{lvalue} -- the purpose of an 
assignment:

\begin{lstlisting}[language=mps]
data flow builder for AssigmentStatement { 
  (node)->void { 
    code for node.rvalue 
    write node.lvalue = node.rvalue 
  } 
}
\end{lstlisting}

\noindent 
For a \ic{StatementList}, we simply mark the list as visited and then execute
the DFBs for each statement in the list. We are now ready to inspect the data
flow graph for a simple function. \fig{dfgexample} shows the function and the graph.
\begin{figure}
\begin{center} 
  \includegraphics[width=8cm]{figures-impl/4/dfgexample.png}
\end{center}
\caption{An example for a data flow for a simple C function.}
\label{dfgexample}  
\end{figure}

\noindent 
Most interesting data flow analysis has to do with loops and branching. So
specifying the correct DFBs for things like \ic{if}, \ic{switch} and \ic{for}
is important. As an example, we look at the DFB for the \ic{IfStatement}. We
start with the obligatory \ic{nop} to make the node as visited. Then we run the
DFB for the condition, because that is evaluated in any case. Then it becomes
interesting: depending on whether the condition is \ic{true} or \ic{false}, we either run
the \ic{thenPart} or we jump to where the \ic{else if} parts begin. Here is
the code so far:

\begin{lstlisting}[language=mps]
nop 
code for node.condition 
ifjump after elseIfBlock // elseIfBlock is a label defined later 
code for node.thenPart 
{ jump after node } 
\end{lstlisting}

\noindent 
The \ic{ifjump} statement means that we may jump to the specified label (i.e.
we then execute the \ic{else if}s). If not (we just "run over" the
\ic{ifjmp}), then we execute the \ic{thenPart}. If we execute the
\ic{thenPart}, we are finished with the whole \ic{IfStatement} -- no
\ic{else if}s or \ic{else} parts are relevant, so we jump after the current
node (the \ic{IfStatement}) and we're done. However, there is an additional
catch: in the \ic{thenPart}, there may be a \ic{return} statement. So we may
never actually arrive at the \ic{jump after node} statement. This is why it is
enclosed in curly braces: this says that the code in the braces is optional. If
the data flow does not visit it, that's fine (typically because we return from
the method before we get a chance to execute this code).

Let's continue with the \ic{else if}s. We arrive at the \ic{elseIfBlock} label
if the condition was \ic{false}, i.e.~the above \ic{ifjump} actually happened. We
then iterate over the \ic{elseIf}s and execute their DFB. After that, we run
the code for the \ic{elsePart}, if there is one. The following code can only be
understood if we know that, if we execute one of the \ic{else if}s, then we
jump \emph{after the whole \ic{IfStatement}}. This is specified in the DFB for
the \ic{ElseIfPart}, which we'll illustrate below. Here is the rest of the code
for the \ic{IfStatement}'s DFB:

\begin{lstlisting}[language=mps]
label elseIfBlock 
foreach elseIf in node.elseIfs { 
  code for elseIf 
} 
if (node.elsePart != null) { 
  code for node.elsePart 
}
\end{lstlisting}

\noindent 
We can now inspect the DFB for the \ic{ElseIfPart}. We first run the DFB for
the condition. Then we may jump to after that \ic{else if}, because the
condition may be \ic{false} and we want to try the next \ic{else if}, if there is
one. Alternatively, if the condition is \ic{true}, we run the DFB for the body
of the \ic{ElseIfPart}. Then two things can happen: either we jump to after
the whole \ic{IfStatement} (after all, we have found an \ic{else if} that is
\ic{true}), or we don't do anything at all anymore because the current \ic{else if}
contains a \ic{return} statement. So we have to use the curly braces again for the
jump to after the whole \ic{if}. The code is below, and an example data flow
graph is shown on figure \fig{ifdfg}.

\begin{lstlisting}[language=mps]
code for node.condition 
ifjump after node 
code for node.body 
{ jump after node.ancestor<concept = IfStatement> } 
\end{lstlisting}



\begin{marginfigure}
\begin{center} 
  \includegraphics[width=3cm]{figures-impl/4/ifdfg.png}
\end{center}
\caption{A data flow graph for an \icsn{if} statement \icsn{if ( i > 0 ) { j = 1; }
else { j = 2; } }}
\label{ifdfg}  
\end{marginfigure}


\noindent 
The DFB for a loop makes use of the fact that loops can be represented using
conditional branching. Here is the DFB for the \ic{for} loop:
\begin{lstlisting}[language=mps]
code for node.iterator 
label start 
code for node.condition 
ifjump after node 
code for node.body 
code for node.incr 
jump after start
\end{lstlisting}

\noindent 
We first execute the DFB for the \ic{iterator} (which is a subconcept of
\ic{LocalVariableDeclaration}, so the DFB shown above works for it as well).
Then we define a label \ic{start} so we can jump to this place from further
down. We then execute the \ic{condition}. Then we have an \ic{ifjmp} to after
the whole loop (which covers the case where the condition is \ic{false} and the
loop ends). In the other case (where the condition is still \ic{true}) we
execute the code for the \ic{body} and the \ic{incr} part of the \ic{for}
loop. We then jump to after the \ic{start} label we defined above.


\parhead{Analyses} MPS supports a number of data flow analyses out of the
box. These analyses operate only on the data flow graph, so the same
analyses can be used for any language, once the DFBs for that language map
programs to data flow graphs. The following utility class uses the unreachable
code analysis: 

\begin{lstlisting}[language=java, morekeywords={foreach, in, error}]
public class DataflowUtil { 

  private Program prog; 
   
  public DataflowUtil(node<> root) { 
    prog = DataFlow.buildProgram(root); // build a program object and store it  
  } 
   
  public void checkForUnreachableNodes() { 
    // grab all instructions that are unreachable (predefined functionality) 
    sequence<Instruction> allUnreachableInstructions = 
             ((sequence<Instruction>) prog.getUnreachableInstructions()); 
    // remove those that may legally be unreachable 
    sequence<Instruction> allWithoutMayBeUnreachable = 
            allUnreachableInstructions.where({~instruction =>
                !(Boolean.TRUE.equals(instruction.
                       getUserObject("mayBeUnreachable"))); }); 
    
    // get the program nodes that correspond to the unreachable instructions 
    sequence<node<>> unreachableNodes = allWithoutMayBeUnreachable.
            select({~instruction => ((node<>) instruction.getSource()); }); 
       
    // output errors for each of those unreachable nodes 
    foreach unreachableNode in unreachableNodes { 
      error "unreachable code" -> unreachableNode; 
    } 
  } 
} 
\end{lstlisting}

\noindent 
The class constructs a \ic{Program} object in the constructor. \ic{Program}s
are wrappers around the data flow graph and provide access to a set of
predefined analyses on the graph. We will make use of one of them here in the
\ic{checkForUnreachableNodes} method. This method extracts all unreachable
nodes from the graph (see comments in the code above) and reports errors for
them. To actually run the check, we call this method from a
checking rule for C functions:

\begin{lstlisting}[language=mps]
checking rule check_DataFlow {                            
  applicable for concept = Function as fct                
  overrides false                                         
  do {                                                    
    new DataflowUtil(fct.body).checkForUnreachableNodes();
  }                                                       
}                                                         
\end{lstlisting}






\section{Constraints in Spoofax}
\label{Sec:spoofax-constraints}

Spoofax uses \emph{rewrite rules} to specify all semantic parts of a language
definition. In \sect{Sec:rewrite-rules} we provide a primer on rewrite rules,
and in this section we show how they can be used to specify constraints in
language definitions.

\subsection{Basic Constraint Rules}

By convention, Spoofax  uses rules by the name \ic{constraint-error} to
indicate constraints that trigger errors, \ic{constraint-warning} for warnings,
and \ic{constraint-note} for notes. To report an error, warning or information
note, these rules have to be overwritten for the relevant term patterns. The
following example is created by default by the Spoofax project wizard. It simply 
reports a note for any module named \ic{example}:

\begin{lstlisting}[language=stratego]
constraint-note:
  Module(name, _) -> (name, "This is just an example program.")
  where
    !name => "example"
\end{lstlisting}

\noindent The condition checks if the module \ic{name} matches the string
\ic{"example"}\footnote{Remember, \ic{!x => y} matches a term \ic{x} against a
pattern \ic{y}.} On its right-hand side, the rule returns a tuple with the tree
node where the marker should appear and a string message that should be shown.
All constraint rules have this form.

Most constraint rules use string interpolation for error messages. Interpolated
strings have the form \ic{\$[...]} where variables can be escaped using
\ic{[...]}. The following example uses string interpolation to report a warning.
A standard library rule \ic{string-starts-with-capitals} is used\footnote{These
and other library rules are documented on the Spoofax website at\icsn{http://www.spoofax.org/}.}.

\begin{lstlisting}[language=stratego]
constraint-warning:
  Entity(theName, _) -> (theName, 
     $[Entity [theName] does not have a capitalized name]) 
  where
      not(<string-starts-with-capital> theName)
\end{lstlisting}



\subsection{Index-Based Constraint Rules}

Some constraint rules interact with the Spoofax index discussed in
\sect{Sec:spoofax-index}. Notable examples include constraints that forbid
references to undefined program elements and duplicate definitions. Newly
created Spoofax projects provide default constraint rules for these cases, which
can be customized.

One way to interact with Spoofax's name resolution index and resolution algorithm
is using the URI annotations on the abstract syntax. These are placed on each 
reference and definition. For example, a valid reference to a mobl variable 
\ic{v} is represented in abstract syntax with an annotated term such as

\begin{lstlisting}
Var("v"{[Var(),"v","function","module"]})
\end{lstlisting}

\noindent Without an annotation, the term reads \ic{Var("v")}. The annotation is
added directly to the name, surrounded with curly braces. The annotation itself is a
URI \ic{Var://module/function/v}, represented as a list consisting of the
namespace, the name, and the path in reverse order.

\noindent 
Unresolved references are represented by terms such as the following (notice
the \ic{Unresolved} term, surrounding the namespace):

\begin{lstlisting}
Var("u"{[Unresolved(Var()),"u","function","module"]})
\end{lstlisting}

\noindent 
In most statically typed languages, references that cannot be statically
resolved indicate an error. The following constraint rule reports an error for these cases: 

\begin{lstlisting}[language=stratego]
constraint-error:
  x -> (x, $[Unable to resolve reference.])
  where
    !x => _{[Unresolved(t) | _]}
\end{lstlisting}


\noindent 
This rule matches any term \ic{x} in the abstract syntax, and reports an error
if it has an \ic{Unresolved} annotation\footnote{For dynamic languages, or
languages with optional types, the constraint could be removed or relaxed. In
those cases, name resolution may only play a role in providing editor services
such as code completion.}. Note how the pattern \ic{\_\curlies{[Unresolved(t) |
\_]}} matches any term (indicated by the wildcard \ic{\_}) that has a list
annotation where the head of the list is \ic{Unresolved(t)} and the tail matches
\ic{\_}.

In addition to annotations, the Spoofax index provides an API for inspecting
naming relations in programs. \fig{Fig:spoofax-index-api} shows some of the
key rules the index provides.

\begin{figure}[h]
\begin{tabular}{|l|l|}
\hline
\ic{index-uri} & Gets the URI of a term. \\
\ic{index-namespace} & Gets the namespace of a term. \\
\ic{index-lookup} & Returns the first definition of a reference. \\
\ic{index-lookup-all} & Returns all definitions of a reference. \\
\ic{index-get-files-of} & Gets all files a definition occurred in. \\
\ic{index-get-all-in-file} & Gets all definitions for a given file path. \\
\ic{index-get-current-file} & Gets the path of the current file. \\
\hline
\end{tabular}
\caption{API rules for working with the Spoofax index.}
\label{Fig:spoofax-index-api}
\end{figure}

\noindent 
We can use the index API to detect duplicate definitions. In most languages,
duplicate definitions are always disallowed. In the case of mobl, duplicate
definitions are not allowed for functions or entities, but they are allowed for
variables, just as in JavaScript. The following constraint rules checks for
duplicates definitions:

\begin{lstlisting}[language=stratego]
constraint-error:
  name -> (name, $[Duplicate definition])
  where
    namespace := <index-namespace> name;
    not(<is-duplicates-allowed> namespace);
    defs := <index-lookup-all> name;
    <gt> (<length> defs, 1)
    
is-duplicates-allowed:
  Var() -> True()
\end{lstlisting}


\noindent Again, this rule is created automatically in a new Spoofax project,
but it provides an interesting showcase of the index API. This rule matches any tree
node \ic{name} and starts by determining its namespace using \ic{index-namespace}.
Then, it fires a helper rule \ic{is-duplicates-allowed}. We only report
duplicate definitions if the helper does not succeed (indicated by the
\ic{not})\footnote{Since there is no definition for anything else than
\icsn{Var()}, the rule will fail in these cases.}. For mobl, that means we never
report this error for definitions in the \ic{Var()} namespace. Next, the
constraint rule determines all definitions of the reference. If the list has more than one element, the rule reports an error. This is checked by
comparing the length of the list with \ic{1}.


Another important constraint for names is \emph{definition before use}: for many
program elements, it is an error if it is used before it is defined. In mobl,
this property is enforced for variables, but not for entities or functions. The
rule to check for this property follows the same pattern as the rule for
duplicates, and should normally not be changed by users. Instead, like before,
the rule uses a helper rule that can be customized to determine which namespaces
require definition before use:

\begin{lstlisting}[language=stratego]
is-ordered-namespace:
  Var() -> True()
\end{lstlisting}

\noindent 
More sophisticated constraints and error messages can be specified using a type
system, as we show in the next chapter.



\chapter{Type Systems}
\label{typesysimpl}

\chapterabstract{Type systems are a subset of constraints -- the implement type
calculations and type checks. Those can be relatively complex, so special
support beyond general-purpose constraint checking is useful. In this chapter we
discuss what type systems have to be able to do, various strategies for
computing types and we provide the usual examples with Xtext, MPS and Spoofax.}

\noindent
Let us start with a definition of type systems from Wikipedia: 

\begin{quote} 
A type system may be defined as a tractable syntactic framework for
classifying phrases according to the kinds of values they compute. A type system
associates types with each computed value. By examining the flow of these
values, a type system attempts to prove that no type errors can occur. The type
system in question determines what constitutes a type error, but a type system
generally seeks to guarantee that operations expecting a certain kind of value
are not used with values for which that operation makes no sense.
\end{quote}

\noindent In summary, type systems associate types with program elements and
then check whether these types conform to predefined typing rules\footnote{As we
have set, type systems are special kind of constraints and hence constitute the
static semantics of a language.}. We distinguish between dynamic type systems
which perform the type checks as the program executes, and static type systems,
where type checks are performed ahead of execution, mostly based on type
specifications in the program. This chapter focuses exclusively on static type
checks\footnote{In case a DSL uses dynamic typing, the type checks habe to be
performed at runtime based on the actual types of values. Many of the
ways of expressing typing rules are similar in this case. However, all the
DSLs I have built so far use static typing -- the fact you can actually have
static type systems is a primary benefit of external DSLs. DSLs with dynamic
type systems are probably better implemented as internal DSLs, relying on the
dynamic type system of the host language. Internal DSLs are beyond the scope
of this book.}.
 
 
\section{Type Systems Basics}\label{tsbasics}

To introduce the basic concepts of type systems, let us go back to the example
used at the beginning of the section on syntax. As a reminder here is the
example code, and \fig{astexample-again} shows the abstract syntax tree. 


\begin{lstlisting}[morekeywords={var, calc, int}]
var x: int;
calc y: int = 1 + 2 * sqrt(x)
\end{lstlisting}
 

\begin{figure}[ht]
\begin{center}
  \includegraphics[scale=0.6]{figures-impl/2/astexample.png}
  \caption[]{Abstract syntax tree for the above program. Boxes
  represent instances of language concepts, solid lines represent containment,
  dotted lines represent cross-references}
  \label{astexample-again} 
\end{center}
\end{figure}

\noindent 
Using this example, we can illustrate in more detail what type systems have to
do:

\begin{description}

  \item[Declare Fixed Types] Some program elements have fixed types. They don't
  have to be derived or calculated, they are always the same and known in
  advance. Examples include the integer constants \ic{IntConst} (whose type is
  \ic{IntType}), the square root concept \ic{sqrt} (whose type is \ic{double}),
  as well as the type declarations themselves (the type of \ic{IntType} is 
  \ic{IntType}, the type of \ic{DoubleType} is \ic{DoubleType}).

  \item[Derive Types] For some program elements, the type has to be derived
  from the types of other elements. For example, the type of a \ic{VarRef} (the
  variable reference) is the type of the referenced variable. The type of a
  variable is the type of it's declared type. In the example above, the type of
  \ic{x} and the reference to \ic{x} is \ic{IntType}.

  \item[Calculate Common Types] Most type systems have some kind of type
  hierarchy. In the example, \ic{IntType} is a subtype of \ic{DoubleType} (so
  \ic{IntType} can be used wherever \ic{DoubleType} is expected). A type system
  has to support the specification of such subtype relationships. Also, the type
  of certain program elements may be calculated from the arguments passed to
  them; in many cases the resulting type will be the "more general one" based on
  the subtyping relationship. Examples include the \ic{Plus} and \ic{Multi}
  concepts: if the left and right arguments are two \ic{IntTypes}, the result is
  an \ic{IntType}. In case of two \ic{DoubleType}s, the result is a
  \ic{DoubleType}. If an \ic{IntType} and a \ic{DoubleType} are used, the result
  is a \ic{DoubleType}, the more general of the two.

  \item[Type Checks] Finally, a type system has check for type errors and report
  them to the user. In the example, a type error would occur if something with a
  \ic{DoubleType} were assigned to an \ic{IntType} variable.

\end{description}


\noindent
Note that the type of a program element is generally not the same as it's
language concept. For example, the concept (meta class) of the number \ic{1} is
\ic{IntConst} and its type is \ic{IntType}. The type of the \ic{sqrt} is
\ic{DoubleType} and its concept is \ic{Sqrt}. Only for type declarations
themselves the two are (usually) the same: the type of an \ic{IntType} is
\ic{IntType}. Different instances of the same concept can have different types:
a \ic{+} calculates it's type as the more general of the two arguments. So the
type of each \ic{+} instance depends on the types of the arguments of that
particular instance.
 
Conceptually, the core of a type system can be considered to be a function
\ic{typeof} that calculates the type for a program element. Types
are often represented with the same technology as the language concepts. As we
will see, in case of MPS types are just nodes, i.e.\ instances of concepts. In
Xtext, we use \ic{EObjects}, i.e.\ instances of \ic{EClasses} as types. In
Spoofax, any ATerm can be used as a type. In all cases, we can even define the
concepts as part of the language. This is useful because most of the concepts
used as types also have to be used in the program text whenever types are
explicitly declared (as in \ic{var x: int}).



\section{Type Calculation Strategies}

In the end, the \ic{typeof} function can be implemented in any way suitable; after
all, it is just program code. However, in practice, three approaches seem to be
used most: recursion, unification and pattern matching. We will explore each of
these conceptually, and then provide examples in the tool sections.


\subsection{Recursion}

Recursion is widely used in computer science and we assume that every reader is
familiar with it. In the context of type systems, the recursive approach for
calculating a type defines a polymorhphic function \ic{typeof}, which takes a
program element and returns its type, while calling itself\footnote{or, most
likely, one of the polymorphic overrides} to calculate the types of those
elements on which its own type depends. Let us consider the following example
grammar (we use Xtext notation here):

\begin{lstlisting}[language=xtextgrammar]
LocalVarDecl:
    "var" name=ID ":" type=Type ("=" init=Expr)?;
\end{lstlisting}
 

\noindent 
The following examples are structurally valid example sentences:
 
\begin{lstlisting}[morekeywords={var, int}]
var i: int          // 1
var i: int = 42     // 2
var i: int = 33.33  // 3
var i = 42          // 4
\end{lstlisting}
 

\noindent 
Let's develop the pseudo-code for \ic{typeof} function the \ic{LocalVarDecl}. 
A first attempt could look as follows:

 
\begin{lstlisting}[language=java]
typeof( LocalVarDecl lvd ) {
    return typeof( lvd.type )
}

typeof( IntType it ) { return it }
typeof( DoubleType dt ) { return dt }
\end{lstlisting}
 

\noindent 
Notice how the \ic{typeof} for \ic{LocalVarDecl} recursively calls \ic{typeof}
for its \ic{type} property. Recursion ends with the \ic{typeof} functions for
the types; they return themselves. This implementation successfully calculates
the type of the \ic{LocalVarDecl}, but it does not address the type check that
makes sure that, if an \ic{init} expression is specified, it has the same type
(or a subtype) of the \ic{type} property. This could be achieved as follows:

 
\begin{lstlisting}[language=java]
typeof( LocalVarDecl lvd ) {
    if isSpecified( lvd.init ) { 
        assert typeof( lvd.init ) isSameOrSubtypeOf typeof( lvd.type )
    } 
    return typeof( lvd.type )
}
\end{lstlisting}

\noindent 
Notice (in the grammar) that the specification of the variable type (in the
\ic{type} property) is also optional. So we have create a somewhat more
elaborate version of the function:

 
\begin{lstlisting}[language=java, morekeywords={raise, error, assert}]
typeof( LocalVarDecl lvd ) {
    if !isSpecified( lvd.type ) && !isSpecified( lvd.init ) 
        raise error
        
    if isSpecified( lvd.type ) && !isSpecified( lvd.init ) 
    	return typeof( lvd.type )
    	
    if !isSpecified( lvd.type ) && isSpecified( lvd.init ) 
    	return typeof( lvd.init )

    // otherwise...    	 
    assert typeof( lvd.init ) isSameOrSubtypeOf typeof( lvd.type )
    return typeof( lvd.type )
}
\end{lstlisting}


\noindent 
This code is quite verbose. Assuming that assertions are ignored if one of the
called \ic{typeof} functions returns \ic{null} because the argument is not
specified, we can simplify this to the following code. This is probably the
shortest version of the code that can be imagined using recursive function calls
and a suitable language\footnote{Note how ignoring an assertion if an argument
is \icsn{null} is a good example of custom semantics that is useful for a given
purpose. Essentially, we have just defined a DSL for type calculations based on
recursive function calls)}.
 
\begin{lstlisting}[language=java, morekeywords={assert, isSpecified,
isSameOrSubtypeOf}] 
typeof( LocalVarDecl lvd ) {
    assert isSpecified lvd.type || isSpecified lvd.init
    assert typeof( lvd.init ) isSameOrSubtypeOf typeof( lvd.type )
    return typeof( lvd.type )
}
\end{lstlisting}



\subsection{Unification}

Unification is the second well-known approach to type calculation. Let's 
start with a definition from Wikipedia:

\begin{quote}
Unification is an operation [..] which produces from [..] logic terms a 
substitution which [..] makes the terms equal modulo some equational theory.
\end{quote}

\noindent
While this sounds quite sophisticated, we have all used unification in
high-school for solving sets of linear equations. The \emph{equational theory} is 
algebra. Here is an example: 

\begin{lstlisting} 
(1) 2 * x == 10
(2) x + x == 10 
(3) x + y == 2 * x + 5
\end{lstlisting}

\noindent 
\emph{Substitution} refers to assignment of values to \ic{x} and \ic{y}. A
solution for this set of equations is \ic{x := 5, y := 10}. 

Using unification for type systems means that language developers specify a
number of type equations which contain type variables (cf. the \ic{x} and
\ic{y}) as well as type values (the numbers in the above example). Some kind of engine
is then trying to make all equations \ic{true} by assigning type values to the
type variables in the type equations. The interesting property of this approach
is that there is no distinction between typing rules and type checks. We simply
specify a set of equations that must be \ic{true} for the types to be
valid\footnote{Consequently they can be evaluated "in both ways". They can be
used for type checking, but they can also be used to compute "missing" types,
i.e. support type inference. MPS (which uses this apprach) also exploits this
declarative nature of typing rules by supporting type-aware code completion
(\ic{Ctrl-Shift-Space}), where MPS computes the required type from the current
context and then only shows code completion menu entries that fit the context
regarding their type (and not just based on the structure).}.
If an equation cannot be satisfied for any assignment of type values to type
variables, a type error is detected. To illustrate this, we return to the
\ic{LocalVarDecl} example introduced above.
 
\begin{lstlisting}[morekeywords={var, int}]
var i: int          // 1
var i: int = 42     // 2
var i: int = 33.33  // 3
var i = 42          // 4
\end{lstlisting}
  \noindent 
The following two type equations constitute the complete type system
specification. The \ic{:==:} operator expresses type equation (left side must be
the same type as right side), \ic{:<=:} refers to subtype-equation (left side
must be same type or subtype of right side, the pointed side of \ic{<} points
to the "smaller", the more specialized type)\footnote{The operators are taken from MPS,
which uses this unification for the type system.}. 
 
\begin{lstlisting}[language=mps] 
typeof( LocalVarDecl.type ) :>=: typeof( LocalVarDecl.init ) 
typeof( LocalVarDecl )      :==: typeof( LocalVarDecl.type ) 
\end{lstlisting}
 
\noindent 
Let us look at the four examples cases. We use capital letters for free type
variables. In the first case, the \ic{init} expression is not given, so the first
equation is ignored. The second equation can be satisfied by assigning \ic{T}, the
type of the variable declaration, to be \ic{int}. The second equations acts as a type
derivation rule and defines the type of the overall \ic{LocalVarDecl}
to be \ic{int}.

\begin{lstlisting}[language=mps]
// var i: int          
typeof( int ) :>=: typeof( int )      // ignore
typeof( T )   :==: typeof( int )      // T := int
\end{lstlisting}

\noindent 
In the second case the \ic{type} and the \ic{init} expression are given, and
both have types that can be calculated independent of the equations specified
for the \ic{LocalVarDecl} (they are fixed). So the first equation has no free
type variables, but it is \ic{true} with the type values specified (two \ic{int}s).
Notice how in this case the equation acts as a type check: if the equation were
not \ic{true} for the two given values, a type error would be reported. The second 
equation works the same as above, deriving \ic{T} to be \ic{int}.
\begin{lstlisting} [language=mps]
// var i: int = 42
typeof( int ) :>=: typeof( int )    // true
typeof( T )   :==: typeof( int )    // T := int
\end{lstlisting}
 
\noindent 
The third case is similar to the second case; but the first equation, in which
all types are specified, is not \ic{true}, so a type error is raised.
 
\begin{lstlisting}[language=mps]
// var i: int = 33.33 
typeof( int ) :>=: typeof( double )   // error!
typeof( T )   :==: typeof( int )      // T := int
\end{lstlisting}
 

\noindent 
Case four is interesting because no variable type is explicitly specified; the
idea is to use what's known as type inference to derive the type from the \ic{init}
expression. In this case there are two free variables in the equations,
substituting both with \ic{int} solves both equations. Notice how the unification
approach automatically leads to support for type inference!

\begin{lstlisting}[language=mps]
// var i = 42    
typeof( U ) :>=: typeof( int )  // U := int
typeof( T ) :==: typeof( U )    // T := int
\end{lstlisting}

\noindent 
To further illustrate how unification works, consider the following example
where we try to provide typing rules for array types and array initializers.
 
\begin{lstlisting}[morekeywords={var, int}]
var i: int[]
var i: int[] = {1, 2, 3}
var i = {1, 2, 3}
\end{lstlisting}
 
\noindent 
Compared to the \ic{LocalVarDecl} example above, the additional complication in
this case is that we need to make sure that \emph{all} the initialization
expressions (inside the curly braces) have the same or compatible types. Here
are the typing equations:
 
\begin{lstlisting}[language=mps, morekeywords={typevar}]
typevar T
foreach ( e: init.elements ) 
    typeof(e) :<=: T
            
typeof( LocalVarDecl.type ) :>=: new ArrayType(T)
typeof( LocalVarDecl )      :==: typeof( LocalVarDecl.type ) 
\end{lstlisting}
 

\noindent 
We introduce an additional type variable \ic{T} and iterate over all the
expression in the array initializer, establishing an equation between each of
these elements and \ic{T}. This results in a set of equations that \emph{each}
must be satisfied\footnote{This clearly illustrates that the \ic{:<=:} operator
is \emph{not} an assignment, since if it were, only the last of the
\icsn{init.elements} would be assigned to \icsn{T}, which clearly makes no sense.}.
The only way to achieve this is that all array initializer members are of the
same (sub-)type. In the examples, this makes \ic{T} to be \ic{int}. The rest of
the equations works as explained above. Notice that if we'd write \ic{var i =
\{1, 33.33, 3\}}, then \ic{T := double}, but the equations would still work
because we use the \ic{:>=:} operator.


\subsection{Pattern Matching}

In pattern matching, we simply list the possible combinations of types in a big
table. Cases that are not listed in the table will result in errors.
For our \ic{LocalVarDecl} example, such a table could look like the following:

\vspace{5mm}
\begin{tabular}{l l l}
\ic{typeof(type)} & \ic{typeof(init)} & \ic{typeof(LocalVarDecl)}\\
\hline
\ic{int} & \ic{int} & \ic{int}\\
\ic{int} & - & \ic{int}\\
- & \ic{int} & \ic{int}\\
\ic{double} & \ic{double} & \ic{double}\\
\ic{double} & - & \ic{double}\\
- & \ic{double} & \ic{double}\\
\ic{double} & \ic{int} & \ic{double}\\
\end{tabular}
\vspace{5mm}
 
\noindent
To avoid repeating everything for all valid types, variables could be used. \ic{T+}
refers to \ic{T} or subtypes of \ic{T}.


\vspace{5mm}
\begin{tabular}{l l l}
\ic{typeof(type)} & \ic{typeof(init)} & \ic{typeof(LocalVarDecl)}\\
\hline
\ic{T} & \ic{T} & \ic{T}\\
\ic{T} & - & \ic{T}\\
- & \ic{T} & \ic{T}\\
\ic{T} & \ic{T+} & \ic{T}\\
\end{tabular}

\vspace{3mm}
\noindent
Pattern matching is used for binary operators in MPS and also for matching terms
in Spoofax. 



\section{Xtext Example}

Up until version 1.0, Xtext provided no support for implementing type systems
(beyond implementing everything manually and plugging it into the constraints).
In version 2.0, a type system integrated with the JVM's type system is available. Since
it is limited to JVM-related types, it is not as versatile as it couldbe\footnote{We illustrate it to some extent in the section on languagemodularity (\sect{mpsmodular}).}, since it cannot easily be used for languagesthat have no relationship with the JVM, such as C or C++.
As a consequence of this limitation and the fact that Xtext is widely used, two
third-party libraries have been developed: 
the Xtext Typesystem Framework (developed by the
author\footnote{\icsn{http://code.google.com/a/eclipselabs.org/p/xtext-typesystem/}},
and XTypes (developed by Lorenzo
Bettini\footnote{\icsn{http://xtypes.sourceforge.net/}}. In the remainder of this
section we will look at the Xtext Typesystem Framework (see
also an SLE 2012 paper that compares typesystem approaches for
Xtext~\cite{TS12}).




\parhead{Xtext Typesystem Framework} The Xtext Typesystem Framework is
fundamentally based on the recursive approach. It provides an interface
\ic{ITypesystem} with a method \ic{typeof(EObject)} which returns the type for the
program element passed in as an argument. In its simplest form, the interface
can be implemented manually with arbitrary Java code. To make sure type errors
are reported as part of the Xtext validation, the type system framework
has to be integrated into the Xtext validation framework manually:

 
\begin{lstlisting}[language=java]
@Inject 
private ITypesystem ts;

@Check(CheckType.NORMAL)
public void validateTypes( EObject m ) {
    ts.checkTypesystemConstraints( m, this );
}    
\end{lstlisting}
 

\noindent As we have discussed in \sect{tsbasics}, many type systems rely on a
limited set of typing strategies (assigning fixed types, deriving the type of an
element from one of its properties, calculating the type as the common type of
its two arguments). The \ic{DefaultTypesystem} class implements \ic{ITypesystem}
and provides support for declaratively specifying these strategies. In the code
below, a simplified version of the type system specification for the cooling
language, the \ic{initialize} method defines one type (the type of the
\ic{IntType} is a clone of itself) and defines one typing constraint (the
\ic{expr} property of the \ic{IfStatement} must be a Boolean). Also, for types
which cannot be specified declaratively, an operation \ic{type(..)} can be
implemented to programmatically define types.

 
\begin{lstlisting}[language=java]
public class CLTypesystem extends DefaultTypesystem {

    private CoolingLanguagePackage cl = CoolingLanguagePackage.eINSTANCE;
    
    @Override
    protected void initialize() {
        useCloneAsType(cl.getIntType());
        ensureFeatureType(cl.getIfStatement(), 
            cl.getIfStatement_Expr(), cl.getBoolType());
    }
        
    public EObject type( NumberLiteral s, TypeCalculationTrace trace ) {
        if ( s.getValue().contains(".")) {
            return create(cl.getDoubleType());
        }
        return create(cl.getIntType());
    }
}
\end{lstlisting}
 

\noindent 
In addition to the API used in the code above, the Typesystem Framework also
comes with a textual DSL to express typing rules. From the textual type system
specification, a generator generates the implementation of the Java class that
implements the type system using the APIs. In that sense, the DSL is just a
facade on top of a framework; however, this is a nice example of how a DSL can
provide added value over a framework or API (\fig{fig:xtext-typesyseditor} shows
a screenshot):

\begin{itemize}
  \item the notation is much more concise compared to the API
  \item referential integrity and code completion with the target language meta
  model is provided
  \item if the typing rules are incomplete, a static error is shown in the
  editor, as opposed to getting runtime error during initialization of the 
  framework (see the warning in (\fig{fig:xtext-typesyseditor})
  \item \keystroke{Ctrl-Click} on a property jumps to the typing rule
  that defines the type for that property.
\end{itemize}



\begin{figure}[ht]
\begin{center} 
  \includegraphics[scale=0.7]{figures-impl/4/xtext-typesyseditor.png}
  \caption[]{The Xtext-based editor for the type system specification
  DSL provided by the Xtext Typesystem Framework. It is a nice example of the
  benefits of a DSL over an API (on which it is based), since it can statically
  show inconsistencies in the type system definition, has a more concise syntax
  and provides customized go-to-definition functionality.}
  \label{fig:xtext-typesyseditor} 
\end{center}
\end{figure}


\parhead{Type system for the Cooling language} The complete type system for
the cooling language is 200 lines of DSL code, and another 100 lines of Java
code. We'll take a look at some representative examples.

Primitive types usually use a copy of themselves as their type\footnote{It has
to be a copy as opposed to the object itself, because the actual program element
must not be pulled out of the EMF containment tree.}. This is specified as
follows:

\begin{lstlisting}[language=xts]
typeof BoolType -> clone
typeof IntType -> clone
typeof DoubleType -> clone
typeof StringType -> clone
\end{lstlisting}

\noindent 
Alternatively, since all primitive types extend an abstract meta class
\ic{PrimitiveType}, this could be shortened to the following, where the \ic{+}
operator specifies that the rule applied for the specified concept and all its
subconcepts:

\begin{lstlisting}[language=xts]
typeof PrimitiveType + -> clone
\end{lstlisting}


\noindent 
For concepts that have a fixed type that is different from the concept itself
(or a clone), the type can simply be specified:

 
\begin{lstlisting}[language=xts]
typeof StringLiteral -> StringType
\end{lstlisting}
 

\noindent 
Type systems are most important, and most interesting, in the context of
expressions. Since all expressions derive from the abstract \ic{Expr} concept, we can
declare that this class is abstract, and hence no typing rule is given. However,
the editor reports a warning if there are concrete subclasses of an abstract
class for which no type is specified either.
 
\begin{lstlisting}[language=xts]
typeof Expr -> abstract
\end{lstlisting}

\noindent 
The notation provided by the DSL groups typing rules and type checks for a
single concept. The following is the typing information for the \ic{Plus}
concept. It declares the type of \ic{Plus} to be the common type of the
\ic{left} and \ic{right} arguments ("the more general one") and then adds two
constraints that check that the \ic{left} and \ic{right} argument are either
\ic{int}s or \ic{double}s\footnote{These rules do not support using \ic{+} forconcatenating strings and for concatenating strings with numbers (as in \ic{"a"+ 1}). However, support for this feature can be provided as well by using acoercion rule.}. 
\begin{lstlisting}[language=xts]
typeof Plus -> common left right {
    ensureType left  :<=: IntType, DoubleType
    ensureType right :<=: IntType, DoubleType
} 
\end{lstlisting}

\noindent 
The typing rules for \ic{Equals} are also interesting. It specifies that the
resulting type is \ic{boolean} that the \ic{left} and \ic{right} arguments must
be \ic{COMPARABLE}, and that the left and right arguments be compatible.
\ic{COMPARABLE} is a so-called type characteristic: this can be considered as
collection of types. In this case it is \ic{IntType}, \ic{DoubleType}, and
\ic{BoolType}. The \ic{:<=>:} operator describes unordered compatibility: the
types of the two properties \ic{left} and \ic{right} must either be the same, 
or \ic{left} must be a subtype or \ic{right}, or vice versa.
 
\begin{lstlisting}[language=xts]
characteristic COMPARABLE {
    IntType, DoubleType, BoolType
}
typeof Equals -> BoolType {
    ensureType left          :<=: char ( COMPARABLE )
    ensureType right         :<=: char ( COMPARABLE )
    ensureCompatibility left :<=>: right
}
\end{lstlisting}
 

\noindent 
There is also support for \emph{ordered} compatibility, as can be seen from the
typing rule for \ic{AssignmentStatement} below. It has no type (it is a
statement!), but the \ic{left} and \ic{right} argument must exhibit ordered
compatibility: they either have to be the same types, or \ic{right} must be a
subtype of \ic{left}, \emph{but not vice versa}.
 
\begin{lstlisting}[language=xts]
typeof AssignmentStatement -> none {
    ensureCompatibility right :<=: left
}
\end{lstlisting}
 
\noindent 
The framework uses the generation gap pattern, i.e.~from the DSL-based type
specification, a generator creates a class \ic{CLTypesystemGenerated} (for the
cooling language) that contains all the code that can be derived from the type
system specification. Additional specifications that cannot be expressed with
the DSL (such as the typing rule for \ic{NumberLiteral} or type coercions) can
be implemented in Java\footnote{. The type system DSL is \emph{incomplete}, since some
aspects of type systems have to be coded in the "lower level". However, in this
case this is appropriate since it keeps the type system DSL simple and, since
the DSL users are programmers, it is not a problem for them to write a few lines
of Java code.}.


\section{MPS Example}
\label{mpstypesys}

MPS includes a DSL for type system rule definition. It is based on
unification, and pattern matching for binary operators. 

The type of a \ic{LocalVariableReference} is calculated with the following
typing rule\footnote{Since only the expression within the \icsn{do \curlies{...}}
block has to be written by the developer, we'll only show that expression in
the remaining examples.}. It establishes an equation between the type of the
\ic{LocalVariableReference} itself and the variable it references. \ic{typeof}
is a built-in operator returns the type for its argument. 
 
\begin{lstlisting}[language=mps]
rule typeof_LocalVariableReference {                    
  applicable for concept = LocalVariableReference as lvr
  overrides false                                       
                                                        
  do {                                                  
    typeof( lvr ) :==: typeof( lvr.variable );              
  }                                                     
}                                                       
\end{lstlisting}
 

\noindent 
The rules for the Boolean \ic{NotExpression} contains two equations. The first
one makes sure that the negated expression is Boolean. The second one types the
\ic{NotExpression} itself to be Boolean. Just as in Xtext, in MPS types are
instances of language concepts.
 
\begin{lstlisting}[language=mps]
typeof( notExpr.expression ) :==: new node<BooleanType>(); 
typeof( notExpr )            :==: <boolean>; 
\end{lstlisting}
 \noindent 
In MPS there are two different ways how language concepts can be instantiated. 
The first one (as shown in the first equation above) uses the BaseLanguage
\ic{new} expression. The second one uses a quotation, where "a piece of tree" can be 
inlined into program code. It uses the concrete syntax of the quoted construct 
-- here: a \ic{BooleanType} -- in the quotation.
A more interesting example is the typing of \ic{struct}s. Consider the
following C code:
 
\begin{lstlisting}[language=c]
struct Person {
    char* name;
    int	age;
}

int addToAge( Person p, int delta ) {
    return p.age + delta;
}
\end{lstlisting}
 

\noindent 
At least two program elements have to be typed: the parameter \ic{p} as well as
the \ic{p.age} expression. The type of the \ic{FunctionParameter} concept is the
type of its type. This is not specific to the fact that the parameter refers to
a \ic{struct}. 

\begin{lstlisting}[language=mps]
typeof( parameter ) :==: typeof( parameter.type );
\end{lstlisting}


\noindent 
The language concept that represents the \ic{Person} type in the parameter is a
\ic{StructType}. A \ic{StructType} refers to the \ic{StructDeclaration} whose
type it represents, and extends \ic{Type}, which acts as the super
type for all types in mbeddr C\footnote{This is essentially a use of the
Adapter pattern.}. 
\begin{marginfigure}[-2cm]
  \includegraphics[width=5cm]{figures-impl/4/structtype.png}
  \caption{Structure diagram of the language concepts involved in typing \icsn{struct}s.}
  \label{structtype}
\end{marginfigure} 

\ic{p.age} is an instance of a \ic{StructAttributeReference}. It is defined as
follows (see \fig{structattrref} as well as the code below). It is an
\ic{Expression}, owns another expression property (on the left of the dot) as
well as a reference to a \ic{StructAttribute} (\ic{name} or \ic{age} in the
example). 
\begin{marginfigure}[2cm]
  \includegraphics[width=5cm]{figures-impl/4/structattrref.png} 
  \caption{Structure diagram of the language concepts involved in references to
  \icsn{struct} attributes.}
  \label{structattrref}
\end{marginfigure} 

 
\begin{lstlisting}[language=mps]
concept StructAttributeReference extends Expression
                                 implements ILValue
  children:                                        
    Expression context 1        
                                                   
  references:                                      
    StructAttribute attribute 1  
\end{lstlisting}
 
                                                   
\noindent 
The typing rule for the \ic{StructAttributeReference} is shown in the code
below. The \ic{context}, the expression on which we use the dot operator, has 
to be a \ic{GenericStructType}, or a subtype thereof (i.e.~a \ic{StructType} which points to an actual
\ic{StructDeclaration}). Second, the type of the whole expression is the type of the
reference \ic{attribute} (e.g.,~\ic{int} in case of \ic{p.age}).  
\begin{lstlisting}[language=mps]
typeof( structAttrRef.context ) :<=: new node<GenericStructType>(); 
typeof( structAttrRef )         :==: typeof( structAttrRef.attribute );
\end{lstlisting}
 

\noindent 
This example also illustrates the interplay between the type system and other
aspects of language definition, specifically scopes. The referenced
\ic{StructAttribute} (on the right side of the dot) may only reference a
\ic{StructAttribute} that is part of the the \ic{StructDeclaration} that is referenced
from the \ic{StructType}. The following scope definition illustrates this:

 
\begin{lstlisting}[language=mps]
link {attribute} 
  search scope: 
    (model, scope, referenceNode, linkTarget, enclosingNode)->join(ISearchScope | sequence<node< >>) { 
      node<> exprType = referenceNode.expression.type; 
      if (exprType.isInstanceOf(StructType)) { 
        return (exprType as StructType).struct.attributes;
      } else { 
        return null; 
      } 
    } 
\end{lstlisting}
 

\noindent 
As we will discuss in the chapter on language extension and composition, MPS
supports incremental extension of existing languages. Extensions may also
introduce new types, and, specifically, may allow existing operators to be used
with these new types. This is facilitated by MPS' use for pattern matching in
the type system, specifically for binary operators such as \ic{+}, \ic{>} or
\ic{==}. As an example consider the introduction of complex numbers into C. It
should be possible to write code like this:
 
\begin{lstlisting}[morekeywords={complex}]
complex c1 = (1, 2i);
complex c2 = (3, 5i);
complex c3 = c1 + c2; // results in (4, 7i)
\end{lstlisting}
 

\noindent 
The \ic{+} in \ic{c1 + c2} should be the \ic{+} defined by the original C
language\footnote{Alternatively, we could define a new \ic{+} for complex
numbers. While this would work technically (remember there is no parser
ambiguity problems), it would mean that users, when entering a \ic{+}, would
have to decide between the original plus and the new plus for complex numbers.
This would not be very convenient from a usability perspective. By reusing the
original plus we avoid this problem.}. Reusing the original \ic{+} requires that
the typing rules defined for \ic{PlusExpression} in the original C language will
now have to accept complex numbers; the original typing rules must be extended.
To enable this, MPS supports so-called overloaded operations containers. The
following container, taking from the mbeddr C core language, defines the type of
\ic{+} and \ic{-} if both arguments are \ic{int} or \ic{double}.
 
\begin{lstlisting}[language=mps, morekeywords={left, right, type, concepts}]
overloaded operations rules binaryOperation                                                                          
                                                                                                                     
operation concepts: PlusExpression | MinusExpression
left operand type: <int>                                                   
right operand type: <int>                                                  
operation type: (operation, leftOperandType, rightOperandType)->node<> { 
  <int>; 
}                                            
operation concepts: PlusExpression | MinusExpression
left operand type: <double>                                                   
right operand type: <double>                                                  
operation type: (operation, leftOperandType, rightOperandType)->node<> { 
  <double>; 
}                                            
\end{lstlisting}
 

\noindent 
To integrate these definitions with the regular typing rules, the following
typing rule must be written\footnote{Note that only one such rule must be
written for all binary operations. Everything else will be handled with the
overloaded operations containers}. Using the \ic{operation type} construct, the
typing rules ties in with overloaded operation containers.

 
\begin{lstlisting}[language=mps]
rule typeof_BinaryExpression {                                                                                                                                                                                                                                                                                                                                           
  applicable for concept = BinaryExpression as binex                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                         
  do {                                                                                                                                                                                                                                                                                                                                                                   
    node<> optype = operation type( binex , left , right ); 
    if (optype != null) { 
        typeof(binex) :==: optype; 
    } else { 
        error "operator " + be.concept.name + " cannot be applied to " +
              left.concept.name + "/" + right.concept.name -> be; 
    } 
  } 
}                                                                                                                                                                                                                                                                                                                                                                    
\end{lstlisting}
 

\noindent 
The important aspect of this approach is that overloaded operation containers
are \emph{additive}. Language extensions can simply contribute \emph{additional}
containers. For the complex number example, this could look like the following:
we declare that as soon as one of the arguments is of type complex, the
resulting type will be complex as well.
 
\begin{lstlisting}[language=mps, morekeywords={one, type}]
operation concepts: PlusExpression | MinusExpression                                     
one operand type: <complex>      
operation type: (operation, leftOperandType, rightOperandType)->node<> { 
  <complex>; 
}                       
\end{lstlisting}

\noindent 
The type system DSL in MPS covers a large fraction of the type system rules
encountered in practice. The type system for BaseLanguage, which is an extension
of Java, is implemented this way. However, for exceptional cases, procedural
BaseLanguage code can be used to implement typing rules as well.

\section{Spoofax Example}

Spoofax' rewrite rules support both the recursive approach and pattern matching
in specifying type systems. However, in most projects the recursive approach
will be found. Therefore we will focus on it in the remainder of the
section.

\parhead{Typing Rules in Spoofax} For typing rules in Spoofax, the basic idea is
to use rewrite rules to rewrite language constructs to their types. For example,
the following rule rewrites integer numbers to the integer type:
\begin{lstlisting}[language=stratego]
  type-of: Int(value) -> IntType()
\end{lstlisting}

\noindent 
This is an example for assigning a fixed type to a language element. Similarly,
we can rewrite a \ic{+} expression to the integer type:
\begin{lstlisting}[language=stratego]
  type-of: Add(exp1, exp2) -> IntType()
\end{lstlisting}

\noindent 
However, it is good practice to assign types only to well-typed language 
constructs. Thus, we should add type checks for the subexpressions:

\begin{lstlisting}[language=stratego]
  type-of:
    Add(exp1, exp2) -> IntType()
    where
      <type-of> exp1 => IntType() ;
      <type-of> exp2 => IntType()
\end{lstlisting}

\noindent 
Spoofax allows for multiple typing rules for the same language construct.
This is particular useful for typing overloaded operators, since each case can 
be handled by a separate typing rule. For example, when the operator \ic{+} is 
overloaded to support string concatenation, we can add the following typing rule:

\begin{lstlisting}[language=stratego]
  type-of:
    Add(exp1, exp2) -> StringType()
    where
      <type-of> exp1 => StringType() ;
      <type-of> exp2 => StringType()
\end{lstlisting}


\parhead{Persistence of Typing Information} As we discussed earlier, Spoofax
stores information about the definition sites of names in an in-memory data structure called the
index. This typically includes information about types. 
For example, to determine the type of property and variable references, 
Spoofax needs to store the type of the corresponding declarations.
Consider the following typing rules, which rewrites property and variable declarations to their
declared types:

\begin{lstlisting}[language=stratego]
  type-of: Property(name, type) -> type
  type-of: VarDecl(name, type) -> type
  type-of: VarDeclInit(name, type, init-exp) -> type
  type-of: Param(name, type) -> type
\end{lstlisting}

\noindent 
Spoofax uses these rules to determine the type of a property or variable declaration. 
This type is stored as an information about the property or variable name.
The storing itself is implemented by the following generic rewrite rule:

\begin{lstlisting}[language=stratego]
  adjust-index-def-data(store-results |namespace, path):
    def -> <store-results> DefData([namespace | path], Type(), type)
    where
      type := <type-of> def
\end{lstlisting}

\noindent Spoofax tries to apply this rule for every definition site according to the name binding definition. 
If the definition has a type, \ic{type-of} will succeed and the returned type is stored in the index. 
If the definition has no type, \ic{type-of} will fail. 
By this, the whole rule will fail and nothing is stored. 
The stored type information can then be used in the typing rules for variable references and property accesses:

\begin{lstlisting}[language=stratego]
  type-of:
    Var(name) -> <index-lookup-type> name
  
  type-of:
    PropAccess(exp, name) -> <index-lookup-type> name
\end{lstlisting}

\noindent 
Both rules rewrite references to the type of their definition sites. First, the
definition of a reference is looked-up in the index. Next, this definition is
rewritten to its type. This uses the \ic{index-lookup-type} rule, which is
another generic rewrite rule:

\begin{lstlisting}[language=stratego]
  index-lookup-type:
    ref -> type
    where
      def  := <index-get-data(|Type())> ref ;
      type := <index-lookup> def 
\end{lstlisting}


\parhead{Additional Types} In Spoofax, types are represented as terms. The
constructors for these terms are specified in the syntax definition as labels to
productions. Without the ability to define additional constructors, type systems
are restricted to types which users can explicitly state in programs, for
example in variable declarations. But many type systems require additional types
which do not originate from the syntax of the language. Typical examples are top
and bottom types in type hierarchies\footnote{A \emph{top} type is a supertype
of every other type, a \emph{bottom} type is a subtype of every other type.}.
For example, Java's type system has a special type for \ic{null} values at the
bottom of its type hierarchy, which cannot be used as a type in Java programs.Spoofax allows to define constructors for additional types in signatures:

\begin{lstlisting}[morekeywords={signature, constructors}]
signature constructors 
  FunType: List(Type) * Type -> FunType
\end{lstlisting}

\noindent 
This defines a binary constructor \ic{FunType} for function types. The first
subterm of a function type is a list of parameter types (\ic{List(Type)}). The
second subterm is the return type. We can employ the so defined function type in
the typing rules for function definitions and calls:

\begin{lstlisting}[language=stratego]
  type-of:
    Function(name, param*, type) -> FunType(type*, type)
    with
      type* := <map(type-of)> param*

  type-of:
    Call(name, arg*) -> type
    where
      <index-lookup-type> name => FunType(type*, type)
\end{lstlisting}


\parhead{Type Constraints} Like any other constraint, type constraints are
specified in Spoofax by rewrite rules which rewrite language constructs to
errors, warnings, or notes. For example, we can define a constraint on
additions:

\begin{lstlisting}[language=stratego]
  constraint-error:
    exp -> (exp, $[Operator + cannot be applied to arguments [<pprint> type1], [<pprint> type2].])
    where
      !exp  => Add(exp1, exp2) ;
      <not(type-of)> exp ;
      type1 := <type-of> exp1 ;
      type2 := <type-of> exp2 
\end{lstlisting}

\noindent 
Basically, an expression is non-well-typed or \emph{ill-typed}, if it cannot be 
rewritten to a type. But reporting an error on all ill-typed expressions will 
make it hard to discover the root cause of the error, since every expression 
with an ill-typed subexpression is also ill-typed. That is why we also check 
the subexpressions of the addition to be well-typed. The types of the 
subexpressions are then used to construct a meaningful error message.




\parhead{Type Compatibility} Whether two types are compatible is again defined
by rewrite rules. These rules rewrite a pair of types to the second element of
the pair, if the first one is compatible to it. In the simplest case, both types
are the same:

\begin{lstlisting}[language=stratego]
  is-compatible-to: (type, type) -> type
\end{lstlisting}    

\noindent 
A type might also be compatible to a type, to which its supertype is compatible:

\begin{lstlisting}[language=stratego]
  is-compatible-to: 
    (subtype, type) -> type
    where
      supertype := <supertype> subtype ;
      <is-compatible-to> (supertype, type)
\end{lstlisting}    

\noindent 
For this case, the subtype relation is defined by a rewrite rule, which 
rewrites a type to its supertype:

\begin{lstlisting}[language=stratego]
  supertype: IntType() -> FloatType()
\end{lstlisting}    

\noindent 
This approach only works for type systems where each type has at most one 
supertype. When a type system allows for multiple supertypes, we have to use 
lists of supertypes and need to adapt the rule for \ic{is-compatible-to} 
accordingly:
 
\begin{lstlisting}[language=stratego]
  supertypes: IntType() -> [ FloatType() ]
  
  is-compatible-to: 
    (subtype, type) -> type
    where
      supertype* := <supertypes> subtype ;
      <fetch-elem(is-compatible-to(|type))> supertype*
\end{lstlisting}    

\noindent 
Here, \ic{fetch-elem} tries to find an element in a list of supertypes, 
which is compatible to \ic{type}. It uses a variant of \ic{is-compatible-to} 
in order to deal with a list of types. This variant does not rewrite a pair of 
types but only the first type. The second type is passed as a parameter to the 
rewrite rule. It can be defined in terms of the variant for pairs:

\begin{lstlisting}[language=stratego]
  is-compatible-to(|type2): type1 ->  <is-compatible-to> (type1, type2)
\end{lstlisting}

\noindent 
The compability of types can easily be extended to compability of lists of types:

\begin{lstlisting}[language=stratego]
  is-compatible-to: 
    (type1*, type2*) -> type*
    where
      type* := <zip(is-compatible-to)> (type1*, type2*)
\end{lstlisting}    

\noindent 
A list \ic{type1*} of types is compatible to another list \ic{type2*} of types, 
if each type in \ic{type1*} is compatible to the corresponding type in 
\ic{type2*}. Thereby, \ic{zip} pairs up the types from both lists, rewrites 
each of these pairs by applying \ic{is-compatible-to} to them, and collects the 
results in a new list \ic{type*}.

With the extension on lists, we can define a constraint for function calls, 
which ensures that the types of the actual arguments are compatible to the 
types of the formal parameters:

\begin{lstlisting}[language=stratego]
  constraint-error: 
    Call(name, arg*) -> (arg*, $[Function [name] cannot be applied to arguments [<pprint> arg-type*].])
    where
      fun-type  := <index-lookup-type> name ;
      !fun-type => FunType(para-type*, type) ;
      arg-type* := <map(type-of)> arg* ;
      <not(is-compatible-to)> (arg-type*, par-type*)
\end{lstlisting}

% \parhead{Degrees of Type Compability}
% While typing rules should be named \ic{type-of} in order to work correctly with
% the index, Spoofax imposes no restrictions on the names of compatibility rules.
% This allows us to use different rule names to define different degrees of type
% compability, as they occur in many type systems. In Java, for example, \ic{"a" +
% 42} is a well-typed expression of type \ic{String}. The integer number
% (primitive type \ic{int}) is autoboxed to an object (class type \ic{Integer})
% which is then implicitly converted into a string (class type \ic{String}) by
% calling \ic{toString()} on it. Notably, autoboxing and implicit conversion work
% without establishing a subtype relationship between types. Though in
% assignments, only autoboxing but no implicit conversion might take place. While
% \ic{Integer i = 42} is a valid assignment, \ic{String s = 42} results in a type
% error. In Spoofax, we can capture this with different compatibility rules:
% 
% 
% \begin{lstlisting}
%   boxed-type: IntType() -> ClassType("Integer")
%   
%   is-compatible: 
%     (type1, type2) -> type2
%     where
%       boxed := <boxed-type> type1 ;
%       <is-compatible> (boxed, type2)
%       
%   is-convertible: 
%     (ClassType(_), ClassType("String")) -> ClassType("String")
%   
%   is-convertible: 
%     (type1, type2) -> type2
%     where
%       boxed := <boxed-type> type1 ;
%       <is-convertible> (boxed, type2)
% \end{lstlisting}

