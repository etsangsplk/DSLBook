\chapter{Scoping and Linking}		
\label{Ch:scopes}

\chapterabstract{Linking refers to the resolution of name-based references to
the references symbols in parser-based languages. In projectional systems this
is not necessary since every reference is stored as a direct pointer to the
target element. However, in both cases we have to define which elements are
actually visible from a given reference site. The set of visible elements is
called the scope.}
 
\noindent
As we have elaborated in the previous section, the abstract syntax in its
simplest form is a tree. However, the information represented by the program is
semantically almost always a graph, i.e.\ in addition to the tree's containment
hierarchy, it contains non-containment cross-references. Examples abound and
include variable references, procedure calls and target states in transitions of
state machines. The challenge thus is: how to get from the "syntactic tree" to
the "semantic graph", or: how to establish the cross-links. There is a marked
difference between the projectional and parser-based approach:

\begin{itemize}

  \item In parser-based systems, the cross-references have to be
  \emph{resolved}, from the parsed text after the AST has been created. An IDE
  may provide the candidates in a code completion menu, but after selecting a
  target, the resulting textual representation of the reference must contain all
  the information to \emph{re-resolve} the reference each time the program is
  parsed.

  \item In projectional editors where every program element has a unique ID, a
  reference is simply a pointer to that ID. Once a reference is established, it
  can always be re-resolved trivially based on the ID. The reference is established directly as
  the program is edited: the code completion menu shows candidate target
  elements for a reference in the code completion menu and selection of one of
  them creates the reference. Of The code completion menu shows some
  human-readable (qualified) name of the target, but the persisted program uses
  the unique ID once the user makes a selection.

\end{itemize}

\noindent Typically, a language's structure definition specifies which concepts
constitute valid target concepts for references (e.g.,~a \ic{Function}, a \ic{Variable}, or
a \ic{State}), but this is usually too imprecise. Language-specific visibility
rules determine which \emph{instances} of these concepts are actually permitted
as a reference target. For example, only the function and variables \emph{in the
local module} or the states \emph{in the same state machine as the transition}
may be valid targets.

The collection of model elements which are valid targets of a particular
semantic cross-reference is called the \emph{scope} of that cross-reference.
Typically, the scope of a particular cross-reference not only depends on the
target concept of the cross-reference but also on its surroundings, e.g.\ the
namespace within which the element lives, the location inside the larger
structure of the site of the cross-reference or something that's essentially
non-structural in nature.

A scope, the collection of valid targets for a reference, has two uses. First,
it can be used to populate the code completion menu in the IDE if the user
presses \keystroke{Ctrl-Space} at the reference site. Second, independent of the
IDE, the scope is used for checking the validity of an existing reference: if
the reference target is not among the elements in the scope, the reference is
invalid.


Scopes can be hierarchical, in which case they are organized as a stack of
collections -- confusingly, these collections are often called scopes
themselves. During resolution of a cross-reference, the lowest or
\emph{innermost} collection is searched first. If the reference cannot be
resolved to match any of its elements, the parent of the innermost collection is
queried, and so forth.

The hierarchy can follow or mimic the structure of the language itself: e.g.,
the innermost scope of a reference consists of all the elements present in the
directly-encompassing "block" while the outermost scope is the \emph{global}
scope. This provides a mechanism to disambiguate target elements having the same
reference syntax (usually the target element's name) by always choosing the
element from the innermost scope -- this is often called "shadowing".

Instead of looking at scopes from the perspective of the reference (and hence
calculating a set of candidate target elements), one can also look at scopes
from the perspective of visibility. In this case, we (at least conceptually)
compute for each location in the program, the set of visible elements. A
reference is then restricted to refer to any element from those visible at the
particular location. Our notion is more convenient from the cross-reference
viewpoint, however, as it centers around resolving particular cross-references
one at a time. From an implementation point of view, both perspective are
exchangable.


\section{Scoping in Spoofax}

In the previous chapter we described how to specify a grammar for a subset of
the mobl language. This chapter shows how to specify name resolution  for this
language by means of declarative name binding rules.
Spoofax' name binding rules are based on five concepts: namespaces, definitions,
references, scopes, and imports.
We will introduce each of these concepts separately, going from simple to more
complicated examples.

\subsection{Namespaces}

To understand naming in Spoofax, the notion of a \emph{namespace} is essential.
Some languages such as C\# provide namespaces as a language concept to scope the names of declarations such as classes.
It is important to distinguish these namespaces as a language concept from 
Spoofax' namespaces as a language definition concept.
In Spoofax, a namespace is a collection of names and is not necessarily connected to a specific language concept. 
Different concepts can contribute names to a single namespace. 
For example, in Java classes and interfaces contribute to the same namespace.
Namespaces are declared in a \ic{namespace} section. For mobl, we have separate
namespaces for modules, entities, properties, functions, and local variables.

\begin{lstlisting}[language=nbl]
namespaces Module Entity Property Function Variable
\end{lstlisting}

\subsection{Definitions and References}

Once we defined namespaces, we can define name bindings with rules of the
form \ic{pattern : clause*}, where \ic{pattern} is a term pattern\footnote{A term
pattern is a term that may contain variables~(\ic{x}) and wildcards~(\ic{\_}).}.
and \ic{clause*} is a list of name binding declarations about the language
construct that matches with \ic{pattern}.
For example, the following rules declare definition sites for module and entity
names:

\begin{lstlisting}[language=nbl]
Module(m, _): defines non-unique Module m
Entity(e, _): defines unique Entity e
\end{lstlisting}

\noindent
The patterns in these rules match module and entity declarations,
binding variables \ic{m} and \ic{e} to module and entity names,
respectively.
While entity declarations are unique definition sites, module declarations are
non-unique definition sites.
That is, multiple module declarations can share the same name.
This allows mobl users to spread the content of a module over several files,
similar to Java packages.
The \ic{unique} keyword is only optional and can be obmitted.
For example, the following rules declares unique definition sites for property
and variable names:

\begin{lstlisting}[language=nbl]
Property(p, _): defines Property p
Param(p, _)   : defines Variable p
Declare(v, _) : defines Variable v
\end{lstlisting}

\noindent
Note how Spoofax distinguishes the name of a namespace from the sort and the
constructor of a program element:
in the last rule above,  
the sort of the program element is \ic{Statement}, its
constructor is \ic{Declare}, and it lives in the \ic{Variable} namespace.
By distinguishing these three things, it becomes easy to add or exclude program
elements from a namespace. 
For example, \ic{Return} statements are also of syntactic type \ic{Statement},
but they do not live in any namespace. 
On the other hand, function parameters live in the \ic{Type} namespace, even
though they are syntactically a different concept from statements.

Use sites which refer to definition sites of names can be declared similarly.
For example, the following rule declares use sites of entity names:

\begin{lstlisting}[language=nbl]
Type(t): refers to Entity t
\end{lstlisting}

\noindent
Use sites might refer to different names from different namespaces.
For example, a variable might refer either to a \ic{Variable} or a
\ic{Property}.
In Spoofax, this can be specified by exclusive resolution options:

\begin{lstlisting}[language=nbl]
Var(x): 
  refers to Variable x otherwise
  refers to Property x
\end{lstlisting}

\subsection{Scoping}

\parhead{Simple Scopes} 
%
\emph{Scopes} restrict the visibility of definition sites\footnote{In Spoofax,
the term \emph{scope} is used in a slightly different way.}. 
For example, an entity declaration scopes property declarations that are not
visible from outside the entity.

\begin{lstlisting}[language=webdsl]
entity Customer {
  name : String // Customer.name
}

entity Product {
  name : String // Product.name
}
\end{lstlisting}

\noindent In this example, the two \ic{name} properties both live the
\ic{Property} namespace, but we can still distinguish them: 
if \ic{name} is referenced in a function inside \ic{Customer},
then it references the first one, not the one in \ic{Product}. 

Scopes can be nested and name resolution typically looks for definition sites
from inner to outer scopes.
In mobl, modules scope entities, entities scope properties and functions, and
functions scope local variables.
This can be specified in Spoofax in terms of \ic{scopes} clauses:

\begin{lstlisting}[language=nbl]
Module(m, _)  : defines Module m scopes Entity
Entity(e, _)  : defines Entity e scopes Property, Function 
Function(f, _): defines Function f scopes Variable
\end{lstlisting}

\noindent 
As these examples illustrate, scopes are often also definition sites.
However, this is not a requirement.
For example, a block statement has no name, but scopes variables:

\begin{lstlisting}[language=nbl]
Block(_): scopes Variable
\end{lstlisting}

\parhead{Definition Sites with Limited Scope} 
%
So far we have seen examples where definitions are visible in their enclosing
scope:
entities are visible in the enclosing module,
properties and functions are visible in the enclosing entity,
and parameters are visible in the enclosing function.
However, this does not hold for variables declared inside a function.
Their visibility is limited to statements that follow the declaration.
Thus, we need to restrict the visibility in the name binding rule for
\ic{Declare} to the \emph{subsequent scope}:

\begin{lstlisting}[language=nbl]
Declare(v, _) : defines Variable v in subsequent scope
\end{lstlisting}

\noindent
Similarly, the iterator variable in a \ic{for} loop is only visible in its
condition, the update, and the loop's body, but not in the initializing expression.
This can be declared as follows:

\begin{lstlisting}[language=nbl]
For(v, t, init, cond, update, body): defines Variable v in cond, update, body
\end{lstlisting}

\parhead{Scoped References}
%
Typically, use sites refer to names which are declared in its surrounding
scopes.
But a use site might refer to definition sites which reside outside its scope.
For example, a property name in a property access expression might refer to a
property in another entity:

\begin{lstlisting}[language=webdsl]
entity Customer { 
  name : String 
}

entity Order {
  customer : Customer
  function getCustomerName(): String {
    return customer.name;
  }
}
\end{lstlisting}

\noindent
Here, \ic{name} in \ic{customer.name} refers to the property in
entity \ic{Customer}.
The following name binding rule is a first attempt to specify this:

\begin{lstlisting}[language=nbl]
PropAccess(exp, p): refers to Property p in Entity e
\end{lstlisting}

\noindent
But this rule does not specify which entity \ic{e} is the right one.
This requires interaction with the type system\footnote{We will discuss type
systems in \sect{spoofaxtypes}.}:

\begin{lstlisting}[language=nbl]
PropAccess(exp, p): 
  refers to Property p in Entity e 
  where exp has type EntityType(e)
\end{lstlisting}

\parhead{Imports}
%
Many languages offer import facilities to include definitions from another scope into the current scope.
For example, a Mobl module can import other modules, making entities from the imported modules available in the importing module:

\begin{lstlisting}[language=webdsl]
module order

import banking

entity Customer {
  name   : String
  account: BankAccount
}
\end{lstlisting}

\noindent
Here, \ic{BankAccount} is not declared in the scope of module \ic{order}.
However, module \ic{banking} declares an entity \ic{BankAccount} which is imported into module \ic{order}.
The type of property \ic{account} should refer to this entity.
This can be specified by the following name binding rule:

\begin{lstlisting}[language=nbl]
Import(m): imports Entity from Module m
\end{lstlisting}

\noindent
This rule has two effects.
First, \ic{m} is interpreted as a name referring to a module.
Second, every entity declared in this module becomes visible in the current scope.

\subsection{URIs for Program Elements}

Each program element that defines a name is assigned a URI. 
The URI uniquely identifies the element across a project. 
By default, these URIs are constructed automatically, based on the name binding
rules. As an example, consider the following entity.


\begin{lstlisting}[language=webdsl]
module storage
entity Store {
  name    : String
  address : Address
}
\end{lstlisting}

\noindent 
Following the name binding rules discussed so far, there are two scope levels in
this fragment:
one at the module level and one at the entity level. 
We can assign names to these scopes (\ic{storage} and \ic{Store}) by using the
naming rules for modules and entities. 
By creating a hierarchy of these names, Spoofax creates URIs: 
the URI for \ic{Store} is \ic{Entity://storage.Store}, and the one for \ic{name}
is \ic{Property://}\linebreak[0]\ic{storage.}\linebreak[0]\ic{Store.name}.
URIs are represented internally as lists of terms, that start with the
namespace, followed by a reverse hierarchy of the path names\footnote{The
reverse order used in the representation makes it easier to efficiently store
and manipulate URIs in memory: every tail of such a list can share the same
memory space.}:

\begin{lstlisting}
[Property(), "name", "Store", "storage"]
\end{lstlisting}


\noindent 
In most cases, parts of a path are simple strings, such as \ic{"Store"}, but
they can be complex terms if needed. An example is \emph{anonymous} scopes that
do not have a name associated with them, but can still become part
of a URI. 
Instead of a name, that part will then have the form \ic{Anon(n)} where \ic{n}is a generated number that identifies the scope. 
\ic{Anon(n)} is an example of a complex term.

URIs can be inspected using the default hover help popups, or using Spoofax' analyzed
syntax view. This view shows the abstract syntax with all URIs as annotations\footnote{To obtain this view, press \emph{Show analyzes syntax(selection)} in the \emph{Transform} menu of the Spoofax editor. Spoofax will open a new editor which updates automatically when the content of the original editor changes}.
Consider the following example with both named and anonymous blocks:

\begin{lstlisting}[language=webdsl]
module banking

entity BankAccount {
  name   : String
  number : Num
  
  function toString() : String {
    { // anonymous block
      var result = name + number.toString();
      return result;
    } 
  }
}
\end{lstlisting}

\noindent 
The analyzed abstract syntax for this example is the following:

\begin{lstlisting}
Module(
  "banking"{[Module(),"banking"]},
  [ Entity(
      "BankAccount"{[Entity(),"BankAccount","banking"]},
      [ Property(
          "name"{[Property(),"name","BankAccount","banking"]},
          StringType()
        ),
        Property(
          "number"{[Property(),"number","BankAccount","banking"]},
          NumType()
        ),
        Function(
          "toString"{[Function(),"toString","BankAccount","banking"]},
          [],
          StringType(),
          Block([
            Declare(
              "result"{[Var(),"result",Anon(125),Anon(124),"toString","BankAccount","banking"]},
              Add(
                Var("name"{[Property(),"name","BankAccount","banking"]}), 
                MethodCall(..., "toString"{[Unresolved(Function()),"toString", "BankAccount", "banking"]})
              )
            ),
            Return(
              Var("result"{[Var(),"result",Anon(125),Anon(124),"toString","BankAccount","banking"]})
            )
          ])
        )
      ]
    )
  ]
) 
\end{lstlisting}

\noindent 
The annotations indicate the URIs of each definition and reference.
They can be used to get an unrefined view of all URIs at a glance, but
also have a role in transformations on abstract syntax, as we discuss later.

Any references that cannot be resolved are annotated with a special
\ic{Unresolved} constructor. For example, a variable \ic{nonexistent} could be
represented as
\ic{Var("nonexistent"\curlies{[Unresolved(Var()),"non\-existent",...]})}. This
makes it easy to recognize any unresolved references in constraints.
We discuss constraints in \sect{Sec:spoofax-constraints}.

\subsection{Persistence of Naming Information}
\label{Sec:spoofax-index}

Spoofax stores all definitions and references in an in-memory data structure
called the index\footnote{It can also store information about definitions, such
as type information, as we show in the next chapter.}. By collecting all this
summary information about files in a project together, it ensures fast access to
global information. The index is updated automatically with changes to the file
system (e.g.,~files being deleted or removed) and is persisted as Eclipse exits.
All entries in the index have a URI as we showed previously. Index entries can
be represented in the ATerm format (see \sect{Sec:spoofax-aterm}). For example,
\ic{Def([Module(),"banking"])} is a definition entry for a banking module.
In the form of terms, they can be used in the same way as abstract syntax tree
fragments in transformations and analyses. \sect{Sec:spoofax-constraints} shows how
the index can be used for such tasks.

Internally, index entries are stored in tables for efficient random access. They
also contain meta-data such as the file name and line number of the definition.
With this meta-data, Spoofax can provide editor services such as reference
resolving. Note that there is no requirement that file names correspond to the
URIs: a \ic{banking.Bank} entity could be defined in any file, as long as there
are no constraints in the language that prevent that.


% \subsection{The Default Name Resolution Strategy}
% 
% The structure of URIs forms the basis of the default name resolution strategy of
% Spoofax\footnote{The default strategy can be customized, but we first take a
% closer look at how name resolution works just based on the annotations in the
% grammar.}. Consider the \ic{address} property in the \ic{Store} entity:
% 
% \begin{lstlisting}[language=webdsl]
% module storage
% 
% entity Store {
%   name    : String
%   address : Address
% }
% \end{lstlisting}
% 
% \noindent 
% The \ic{address} property references something named \ic{Address}. According to
% the grammar, that something lives in the \ic{Type} namespace. Spoofax resolves
% this name by looking at the context: is there an \ic{Address} in
% \ic{Type://storage.Store}? If not, it will keep trying the parent URI:
% \ic{Type://storage} and finally \ic{Type://}. If it is successful in finding it
% this way, it can resolve the reference, otherwise it displays an error marker in
% the editor.
% 
% 
% The default resolution strategy is designed to be generic and makes few
% assumptions about a specific language\footnote{Spoofax expects language
% designers to \emph{manage by exception}.}. By default, it does not care about
% file boundaries: if an \ic{Address} is defined in a different file, it will
% still find it. There is also no default constraint for duplicate names: two
% definitions of \ic{Address} are fine (in which case a reference will resolve to one of them). 
% Lastly,
% the default strategy knows nothing about import definitions for a specific language, as these can vary quite a bit among languages.


% \subsection{Customizing the Name Resolution Strategy}
% 
% To customize the name resolution strategy, Spoofax language definitions can
% include \ic{adjust-index-lookup} rules. These rules have a specific signature,
% and are invoked by the name resolution strategy for each reference that is
% resolved\footnote{This is a rewriting rule with a predefined name and signature
% so it can be invoked by Spoofax. It can be redefined to apply to specific
% language concepts.}. As an example, consider how a reference to a local
% property is resolved in mobl:
% 
% \begin{lstlisting}[language=webdsl]
% entity BankAccount {
%   function getNumber() : Num {
%     return number;
%   }
%   
%   name   : String
%   number : Num
% }
% \end{lstlisting}
% 
% \noindent 
% Here, the function \ic{getNumber} references the local \ic{number} property.
% The production rule we previously specified for these kinds of references
% used an underscore to indicate that we would manually specify how to resolve
% it\footnote{Because properties and variables can be referenced.}:
% 
% \begin{lstlisting}
% _@ID -> Exp {"Var"}
% \end{lstlisting}
% 
% \noindent 
% So, we need to specify a \ic{adjust-index-lookup} rule for the variables:
% 
% \begin{lstlisting}[language=stratego]
% adjust-index-lookup(target |namespace, path, name):
%   Var(x) -> adjusted-uris
%   where
%     <target> x
%   with 
%     adjusted-uris := ...
% \end{lstlisting}
% 
% \noindent 
% Each \ic{adjust-index-lookup} rule has this exact signature: it gets a
% \ic{target} rule argument, and term arguments with the \ic{namespace},
% \ic{path}, and \emph{name} of the reference to be resolved. 
% On the left-hand side, it specifies what construct it matches against.
% In this case, we want to resolve a variable.
% Next, we need to specify which part of the node is the name we want to resolve.
% \footnote{There might be nodes with more than one name to resolve, for example in a qualified package name, each segment refers to a package.}
% In a variable reference \ic{Var(x)}, the \ic{x} is the name we want to resolve.
% We specify this explicitely as the first condition of the rule: \ic{where <target> x}.
% On the right-hand side, the rule returns a list of adjusted URIs.
% Spoofax will then use these URIs to further resolve the element.
% 
% A variable might refer either to a variable (namespace \ic{Var}) or a property (namespace \ic{Property}).
% Since we got the current \ic{path} of the variable as a parameter, we can construct two possible URIs, where the definition site can be found: \ic{Var://path} and \ic{Property://path}\footnote{Remember that URIs are represented as lists. We use the namespace as the head of the list and the path as the tail. The variable name is not part of these URIs.}:
% 
% \begin{lstlisting}[language=stratego]
% adjust-index-lookup(target |namespace, path, prefix):
%   Var(x) -> adjusted-uris
%   where
%     <target> x
%   with
%     var-uri       := [Var() | path];
%     property-uri  := [Property() | path];  
%     adjusted-uris := [var-uri, property-uri]
% \end{lstlisting}
% 
% \noindent Note, that the URIs do not contain the variable name \ic{x}.
% This is, because the URIs specify containers telling Spoofax where to look for the variable.
% We return both URIs in a list of adjusted URIs.
% The order in this list is important.
% Spoofax will first look only for variables, before it will look for properties.
% 
% The example code we have seen so far is pretty verbose for explanation.
% A typical shorter way to adjust variable lookup, would look like this:
% 
% \begin{lstlisting}[language=stratego]
% adjust-index-lookup(target |namespace, path, prefix):
%   Var(<target>) -> [[Var() | path], [Property() | path]]
% \end{lstlisting}
% 
% \noindent Here, the \ic{target} is marked in the left-hand side of the rule. On
% the right-hand side, we construct the list of adjusted URIs right away.

% \begin{lstlisting}
% "import" Module@ID -> Decl {"Import"}
% \end{lstlisting}
% 
% \ic{Import("customers")}
% 
% \begin{lstlisting}
%   adjust-index-lookup(target |namespace, path, prefix): 
%     Type(<target>) -> <concat> [primitives, [[Type() | path]], importPaths]
%     with
%       importPaths := <filter(import-to-path)> <index-get-all-in-file(|Import)> <index-get-current-file>;
%       primitives := <map(type-of; type-to-def)> <primitive-types>
%     
%   import-to-path:
%     Def([Import(), EntityImport(mod, ent)|_]) -> Def([Type(), ent, mod])
% \end{lstlisting}




%unifying Var and Property namespace?
%
%
%When needed, the path elements that are created for a scope can be customized
%using a rewrite rule:
%
%\begin{lstlisting}
%adjust-index-path(is-def | namespace, path, prefix):
%  Entity(name, body) -> [Entity(), name]
%\end{lstlisting}
%
%%
%
%
%\begin{lstlisting}
%adjust-index-path(target | namespace, path, prefix):
%  Var(<target>) -> 
%\end{lstlisting}





\section{Scoping in Xtext}

Xtext provides Java APIs for implementing all aspects of languages except the
grammar\footnote{In fact, you can use any JVM-based language for implementing
these language aspects, including Xtend}. Language developers typically provide
Java classes that implement aspect-specific interfaces and then contribute those
to Xtext using Google Guice, a dependency injection
framework\footnote{\icsn{http://code.google.com/p/google-guice/}}. For most language
aspects, Xtext comes with various default implementations developers can build
on. A lot of functionality is provided out-of-the-box with minimal
configuration, but it's easy to swap out specific parts by binding another or a
custom class through Guice.

\subsection{Simple, Local Scopes}

To implement scopes, language developers have to contribute a class that
implements the \ic{IScopeProvider} interface. It has one method called
\ic{getScope} that returns an \ic{IScope} for a given reference. An \ic{IScope}
is basically a collection of candidate reference targets, together with the
textual representation by which these may be referenced from the current
reference site (the same target may be referenced by different text strings from
different program locations). The \ic{getScope} method has two arguments: the
first one, \ic{context}, is the current program element for which a reference
should be scoped; the second one, \ic{reference}, identifies the reference for
which the scope that needs to be calculated.

\begin{lstlisting}[language=java] 
public interface IScopeProvider {
    IScope getScope(EObject context, EReference reference);
}
\end{lstlisting}

\noindent 
To make the scoping implementation easier, Xtext provides so-called declarative
scope providers through the \ic{AbstractDeclarativeScopeProvider} base class:
instead of having to inspect the \ic{reference} and \ic{context} object
manually to decide how to compute the scope, the language implementor can
express this information via the name of the method (using a naming convention).
Two different naming conventions are available:


\begin{lstlisting}[language=java]
// <X>, <R>: scoping the <R> reference of the <X> concept 
public IScope scope_<X>_<R>(<X> ctx, EReference ref );

// <X>: the language concept we are looking for as a reference target
// <Y>: the concept from under which we try to look for the reference 
public IScope scope_<X>(<Y> ctx, EReference ref);
\end{lstlisting}

 
\noindent 
Let's assume we want to scope the \ic{targetState} reference of the
\ic{ChangeStateStatement}. Its definition in the grammar looks as follows:

\begin{lstlisting}[language=xtextgrammar]
ChangeStateStatement:
    "state" targetState=[State];
\end{lstlisting}

\noindent 
We can use the following two alternative methods:

\begin{lstlisting}[language=java]
public IScope scope_ChangeStateStatement_targetState
              (ChangeStateStatement ctx, EReference ref ) {
    ...            
}
            
public IScope scope_State(ChangeStateStatement ctx, EReference ref) {
    ...
}
\end{lstlisting}


\noindent 
The first alternative is specific for the \ic{targetState} reference of the
\ic{ChangeStateStatement}. It is invoked by the declarative scope provider only
for that reference. The second alternative is more generic. It is invoked
whenever we are trying to reference a \ic{State} (or any subconcept of
\ic{State}) from any reference of a \ic{ChangeStateStatement} and \emph{all its
descendants}. So we could write an even more general alternative, which scopes
the visible \ic{State}s from anywhere in a \ic{CoolingProgram}, independent of
the actual reference\footnote{Depending on the structure of your language, Xtext
may have a hard time finding out the current location, and hence, the reference
that needs to be scoped. In this case, the tighter versions of the scoping
method (\icsn{scope\_ChangeStateStatement\_targetState} in the example) might not
be called in all the places you expect it to be called. This can be remedied
either by changing the syntax (often not possible or not desired), or by using
the more general variants of the scoping function
\icsn{scope\_State(CoolingProgram ctx, ... )}. It is a good idea to always use the
most general variants, unless you specifically want to scope one specific
reference.}.

\begin{lstlisting}[language=java]
public IScope scope_State(CoolingProgram ctx, EReference ref) {
    ...
}
\end{lstlisting}


\noindent 
The implementation of the scopes is simple, and relatively similar in all three
cases. We write Java code that crawls up the containment hierarchy until we
arrive at a \ic{CoolingProgram} (in the last alternative, we already get the
\ic{CoolingProgram} as an argument, so we don't need to move up the tree), and
then construct an \ic{IScope} that contains the \ic{State}s defined in that
\ic{CoolingProgram}. Here is a possible implementation:


\begin{lstlisting}[language=java]
public IScope scope_ChangeStateStatement_targetState
            (ChangeStateStatement ctx, EReference ref ) {
    CoolingProgram owningProgram = Utils.ancestor( ctx, CoolingProgram.class );
    return Scopes.scopeFor(owningProgram.getStates());
}
\end{lstlisting}

\noindent 
The \ic{Scopes} class provides a couple of helper methods to create \ic{IScope}
objects from collections of elements. The simple \ic{scopeFor} method 
will use the \ic{name} of the target element as the text by which it will be
referenced\footnote{You can pass in code that creates other strings than then
name from the target element.}. So if a state is called \ic{normalCooling}, then
we'd have to write \ic{state normalCooling} in a \ic{ChangeStateStatement}. The
text \ic{normalCooling} acts as the reference -- pressing \keystroke{Ctrl-F3}
on that program element will go to the referenced state. 




\subsection{Nested Scopes} 

The approach to scoping shown above is suitable for simple cases, such as the
\ic{targetState} reference shown above. However, in languages with nested blocks
a different approach is recommended. Here is an example of a program expressed in
a language with nested blocks:


\begin{lstlisting}[morekeywords={var, int, function, return, foreach, in}]
var int x;		
var int g;
 
function add( int x, int y ) {
    int sum = x + y;               // 1
    return sum;
}

function addAll( int es ... ) {
    int sum = 0;                 
    foreach( e in es ) { 
        sum += e;                // 2
    }
    x = sum;                     // 3
}
\end{lstlisting}


\noindent 
At \ic{1}, the local variable \ic{sum}, the arguments \ic{x} and \ic{y} and the
global variables \ic{x} and \ic{g} are visible, although the global variable
\ic{x} is shadowed by the argument of the same name. At \ic{2}, we can see
\ic{x}, \ic{g}, \ic{sum} and \ic{es}, but also the iterator variable \ic{e}. At
\ic{3}, \ic{x} refers to the global since it is not shadowed by a parameter or
local variable of the same name. In general, certain program elements introduce
blocks (often statement lists surrounded by curly braces). A block can
declare new symbols. References from within these blocks can see the symbols
defined in that block, as well as all ancestor blocks. Symbols in inner blocks
typically hide symbols with the same name in outer blocks. The symbols in outer
blocks are either not accessible at all, or a special name has to be used, for
example, by prefixing them with some \ic{outer} keyword (for example,
\ic{outer.x}).

Xtext's scopes support this scenario. \ic{IScopes} can reference outer scopes.
If a symbol is not found in any given scope, that scope delegates to its outer
scope (if it has one) and asks it for a symbol of the respective name. Since
inner scopes are searched first, this implements shadowing as expected.

Also, scopes are not just collections of elements. Instead, they are maps
between a string and an element\footnote{In addition, the text shown in the code
completion window can be different from the text that will be used as the
reference once an element is selected. In fact, it can be a rich string that
includes formatting, and it can contain an icon.}. The string is used as the
reference text. By default, the string is the same as the target element's
\ic{name}. So if a variable is called \ic{x}, it can be referenced by the string
\ic{x}. However, this reference string can be changed as part of the scope
definition. This can be used to make shadowed variables visible under a
different name, such as \ic{outer.x} if it is referenced from location \ic{1}.
The following is pseudo-code that implements this behavior:


\begin{lstlisting}[language=java]
// recursive method to build nested scopes
private IScope collect( StatementList ctx ) { 
    IScope outer = null
    if ( ctx is within another StatementList parent ) {
        outer = collect(parent)
    }
    IScope scope = new Scope( outer )
    for( all symbols s in ctx ) {
        scope.put( s.name, s )
        if ( outer.hasSymbolNamed( s.name ) ) {
            scope.put( "outer."+s.name, outer.getSymbolByName( s.name ) )
        }
    } 
    return scope
}

// entry method, according to naming convention 
// in declarative scope provider
public IScope scope_Symbol( StatementList ctx ) {
    return collect( ctx )
}	
\end{lstlisting}


\subsection{Global Scopes} 

There is one more aspect of scoping that needs to be discussed. Programs can be
separated into several files and references can cross file boundaries. That is,
an element in file \ic{A} can reference an element in file \ic{B}. In earlier
versions of Xtext file \ic{A} had to explicity import file \ic{B} to make the
elements in \ic{B} available as reference targets. This resulted in several
problems. First, for internal reasons, scalability was limited. Second, as a
consequence of the explicit file imports, if the referenced element was moved
into another file, the import statements in all referencing files had to be
updated.

Since Xtext 1.0 both of these problems are solved using the so-called
index\footnote{This is similar to Spoofax'es index discussed above}.
The index is a data structure that stores
(\ic{String},\ic{IEObjectDescription})-pairs.
The first argument is the qualified name of the object and the second one, the
\ic{IEObjectDescription}, contains information about a model element, including
a URI (a kind of global pointer that also includes the file in which the element
is stored) as well as arbitrary additional data provided by the language
implementation. By default, all references are checked against this name in the
index, not against the actual object. If the actual object has to be resolved,
the URI stored in the index is used. Only then is the respective file
loaded\footnote{This is what improved scalability; files are only loaded if a
reference target is accessed, not to check a reference for validity}. The index
is updated whenever a file is changed (even when it has not been saved, so
references against dirty editors work). This way, if an element is moved to a
different file while keeping its qualified name (which is based on the logical
program structure) constant, the reference remains valid.
Only the URI in the index is updated.

There are two ways to customize what gets stored in the index, and how. The
\ic{IQualifiedNameProvider} returns a qualified name for each program element.
If it returns \ic{null}, the element is not stored in the index, which means it
is not referencable. The other way is the
\ic{IDefaultResourceDescriptionStrategy} which allows language developers to
build their own \ic{IEObjectDescription} for program elements. This is important
if custom user data has to be stored in the \ic{IEObjectDescription} for later
use during scoping.

The \ic{IGlobalScopeProvider} is activated if a local scope returns \ic{null} or
no applicable methods can be found in the declarative scope provider class (or
if they return \ic{null}). By default, the
\ic{ImportNamespacesAwareGlobalScopeProvider} is configured\footnote{The
specific implementation is configured through a Guice binding.}, which provides
the possibility to reference model elements outside of the current file either
through their (fully) qualified name or through their unqualified name using an
\ic{import} statement\footnote{That \icsn{import} statement is different from
the one mentioned earlier: it makes the contents of the respective namespace
visible, it does not refer to the a particular file.}.




\parhead{Polymorphic References} In the cooling language, expressions also
include references to various other entities, such as configuration parameters,
variables and hardware elements (compressors or fans defined in a different
model). All of these referenceble elements extend the \ic{SymbolDeclaration}
meta class. This means that all of them can be referenced by the single
\ic{SymbolRef} construct.
\begin{lstlisting}[language=xtextgrammar]
AtomicLevel returns Expression:
    ...
    ({SymbolRef} symbol=[SymbolDeclaration|QID]);
\end{lstlisting}  

\noindent 
The problem with this situation is that the reference itself does not encode the
kind of thing that is referenced. By looking at the reference alone we only know
that we reference some kind of symbol. This makes writing code that processes
the model cumbersome, since the target of a \ic{SymbolRef} has to be taken into
account when deciding how to treat (translate, validate) a symbol reference. A
more natural design of the language would use different reference constructs for
the different referencable elements. In this case, the reference itself is
specific to the referenced element, making processing much easier\footnote{It
would also make writing the scopes and extending the language simpler}:

\begin{lstlisting}[language=xtextgrammar] 
AtomicLevel returns Expression:
    ...
    ({VariableRef} var=[Variable]);
    ({ParameterRef} param=[Parameter]);
    ({HardwareBuildingBlockRef} hbb=[HardwareBuildingBlock]);
\end{lstlisting}  

\noindent 
However, this is not possible with Xtext, since the parser cannot distinguish
the three cases syntactically. In all three cases, the reference syntax itself
is just an \ic{ID}. Only during the linking phase could the system check which
kind of element is actually referenced, but this is too late for the parser,
which needs an unambiguous grammar. The grammar could be disambiguated by using
a different syntax for each element:

\begin{lstlisting}[language=xtextgrammar]  
AtomicLevel returns Expression:
    ...
    ({VariableRef} var=[Variable]);
    ({ParameterRef} "%" param=[Parameter]);
    ({HardwareBuildingBlockRef} "#" hbb=[HardwareBuildingBlock]);
\end{lstlisting}  

\noindent 
While this approach will technically work, it would lead to an awkward syntax
and is hence typically not used. The only remaining alternative is to make all
referencable elements extend \ic{SymbolDeclaration} and use a single reference
concept, as shown above.





\section{Scoping in MPS}

Making references work in MPS requires several ingredients. First of all,
developers define a reference as part of the language structure. Then, an editor
is defined that determines how the referenced element is rendered at the
referencing site\footnote{We have shown this in the previous chapter.}. To
determine which instances of the referenced concept are allowed, a scoping
function has to be implemented. It simply returns a list of all the elements
that are considered valid targets for the reference, as well a an optional text
string used to represent the respective element in the code completion menu.

As we have explained above (\sect{projed}), smart references are an important
ingredient to make this work conveniently. They make sure that users can simply
type the name (or whatever else is put into the code completion menu by the
language developer) of the targeted element; once something is selected, the
corresponding reference concept is instantiated, and the selected target is set.

\parhead{Simple Scopes} As an example, we begin with the scope definition for
the target reference of the \ic{Transition} concept. To recap, it is defined as:

\begin{lstlisting}[language=mps] 
concept Transition      
  // ...                                        
  references:                           
    State   target  1       
\end{lstlisting}

\noindent The scope itself is defined via the search scope constraint below. The
system provides an anonymous function \ic{search scope} that has a number of
arguments that describe the context including the enclosing node and the
referencing node. As the signature shows, the function has to return either an
\ic{ISearchScope} or simply a sequence of nodes of type \ic{State}. The scope of
the target state is simply the set of states of the state machine that
(transitively) contains the transition. To implement this, the expression in the
body of this function crawls up the containment hierarchy\footnote{Note that for
a smart reference, where the reference object is created only \emph{after}
selecting the target, the \icsn{referenceNode} argument is \icsn{null}! This is
why we write the scope using the \icsn{enclosingNode} argument.
} until it finds a \ic{Statemachine} and then returns its
\ic{states}\footnote{The code used to express scopes can be arbitrarily complex
and is implemented in MPS' BaseLanguge, an extended version of Java.}.
\begin{lstlisting}[language=mps] link {target}
  referent set handler:
    <none>
  search scope:
    (model, scope, referenceNode, linkTarget, enclosingNode)
             ->join(ISearchScope | sequence<node<State>>) {
      enclosingNode.ancestor<concept = Statemachine>.states;
    }
  validator:
    <default>
  presentation :
    <none>
;\end{lstlisting}

 

\noindent In addition to the search scope, language developers can provide code
that should be executed if a new reference target is set (\ic{referent set handler}),
additional validation (\ic{validator}), as well as customized
presentation in the code completion menu (\ic{presentation}).


\parhead{Nested Scopes} In a more complex, block oriented language with
nested scopes, a different implementation pattern is recommended\footnote{In
this section we describe the approach as we have implemented it for mbeddr C.
Since version 2.5, MPS supports this approach out of the box. For example, an
interface similar to \icsn{IScopeProvider} ships with MPS, and scopes
can be inherited from parent nodes.}:

\begin{itemize}
  \item All program elements that contribute elements that can be referenced
  (such as blocks, functions or methods) implement an interface \ic{IScopeProvider}.
  \item This interface provides a method \ic{getVisibleElements(concept<> c)}
  that returns all elements of type \ic{c} that are available in that scope. 
  \item The search scope function simply calls this method on the owning
  \ic{IScopeProvider}, passing in the concept whose instances it wants to see 
  (\ic{State} in the above example).
  \item The implementation of the method recursively calls the method on its
  owning \ic{IScopeProvider}, as long as there is one. It also removes 
  elements that are shadowed from the result.
\end{itemize}
\noindent This approach is used in the mbeddr C language, for example for local
variables, because those are affected by shadowing from blocks. Here is the code for the
\ic{variable} reference of the \ic{LocalVariableReference} concept:

\begin{lstlisting}[language=mps]
link {variable} 
  search scope: 
    (model, scope, referenceNode, linkTarget, enclosingNode, operationContext)->join(ISearchScope | sequence<node<LocalVariableDeclaration>>) {
      // find the statement that contains this (future) local variable reference 
      node<Statement> s = enclosingNode.ancestor<concept = Statement, +>; 
      
      // find the first containing ILocalVariableScopeProvider; this is
      // typically next next higher statement that owns a StatementList, such
      // as a ForStatement or an IfStatement
      node<ILocalVarScopeProvider> scopeProvider = 
             enclosingNode.ancestor<concept = ILocalVarScopeProvider, +>;
      
      // if we are not in a Statement or there is no ILocalVarScopeProvider,
      // we return an empty list - no variables visible
      if (s == null || scopeProvider == null) { 
         return new nlist<LocalVariableDeclaration>; 
      }
      
      // we now retrieve the position of the current Statement in the 
      // context StatementList. This is important because we only want to 
      // see those variables that are defined before the reference site 
      int pos = s != scopeProvider ? s.index : LocalVarScope.NO_POSITION;
      
      // finally we create the scope and get the visible variables; 
      scopeProvider.getLocalVarScope(s, pos).getVisibleLocalVars(); 
    } 
\end{lstlisting}


\parhead{Polymorphic References} We have explained above how references work in
principle: they are real pointers to the referenced element, based on the
target's unique ID. In the section on Xtext we have seen how from a given
location only one kind of reference for any given syntactic form can be
implemented. Consider the following example, where we refer to a global variable
\ic{a} and an event parameter (\ic{timestamp}) from within expressions:

\begin{lstlisting}[language=mbeddr]
int a;
int b;

statemachine linefollower {                                                         
  in event initialized(int timestamp);
  states (initial=initializing) {                                                                
    state initializing {                                                      
      on initialized [now() - timestamp > 1000 && a > 3] -> running                                                   
    }     
    state running {
    }
  }                                                                            
}                                                                                   
\end{lstlisting}

\noindent 
Both references to local variables and to event parameters use the same
syntactic form: simply a text string that represents the name of the respective
target element. In Xtext, this has to be implemented with a single reference
concept, typically called \ic{SymbolReference}, that can reference to any kind
of \ic{Symbol}. \ic{LocalVariableDefintions} and \ic{EventParameters} would both
extend \ic{Symbol}, and scopes would make sure both kinds are visible from
within guard expressions. The problem with this approach is that the reference
itself contains no type information about what it references, it is simply a
\ic{SymbolReference}. Processing code has to inspect the type of the referenced
symbol to find out what a particular \ic{SymbolReference} actually
means\footnote{It can also be a problem regarding modularity, because every
referencable concept must extend \icsn{Symbol}. Referencable elements
contributed by an independently developed language which we may want to embed
into the C language will \emph{not} extend \icsn{Symbol}, though! We discuss
language modularization and composition in \sect{mpsmodular}.}.

In projectional editors this is done differently. To solve the example above,
one would create a \ic{LocalVariableReference} and an
\ic{EventParameterReference}. The former references variables and the latter
references event parameters. Both have an editor that simply renders the name
of the referenced element, and each of them has \ic{their own} scope definition! 
So adding new kinds of references to existing expression languages can be done
in a modular fashion, since the new reference expression comes with its own,
independent scoping rule. The following is the respective code for the
\ic{EventArgRef} expression:

\begin{lstlisting}[language=mps]
concept EventArgRef extends Expression // this is the Expression concept from C

...

link {arg} 
  search scope: 
    (model, scope, referenceNode, linkTarget, enclosingNode, operationContext)
                               ->join(ISearchScope | sequence<node<EventArg>>) { 
      enclosingNode.ancestor<concept = Transition, +>.trigger.event.args; 
    } 
;
\end{lstlisting} 

\noindent 
Entering the reference happens by typing the name of the referenced element (cf.
the concept of smart references introduced above). In the case where there's a
\ic{LocalVariable} and a \ic{EventParameter} of the same name, the user has to
make an explicit decision, at the time of entry (the name won't bind, and the
code completion menu requires a choice). It is important to understand that,
although the names are similar, the tool still knows whether a particular
reference refers to a \ic{LocalVariable} or to an \ic{EventParameter}, because
the reference is encoded using the ID of the target\footnote{It may not,
however, be obvious to the user, so use this approach with caution and/or use
different syntax highlighting to distinguish the two. The real benefit of this
approach is that if two independent language extensions define such scopes
independently, there will not be any ambiguity if these extensions are used
together in a single program.}.

