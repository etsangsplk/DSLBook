\chapter{Scoping and Linking}		
\label{Ch:scopes}

\chapterabstract{Linking refers to the resolution of name-based references to
the references symbols in parser-based languages. In projectional systems this
is not necessary since every reference is stored as a direct pointer to the
target element. However, in both cases we have to define which elements are
actually visible from a given reference site. The set of visible elements is
called the scope.}
 
\noindent
As we have elaborated in the previous section, the abstract syntax in its
simplest form is a tree. However, the information represented by the program is
semantically almost always a graph, i.e.\ in addition to the tree's containment
hierarchy, it contains non-containment cross-references. Examples abound and
include variable references, procedure calls and target states in transitions of
state machines. The challenge thus is: how to get from the "syntactic tree" to
the "semantic graph", or: how to establish the cross-links. There is a marked
difference between the projectional and parser-based approach:

\begin{itemize}

  \item In parser-based systems, the cross-references have to be
  \emph{resolved}, from the parsed text after the AST has been created. An IDE
  may provide the candidates in a code completion menu, but after selecting a
  target, the resulting textual representation of the reference must contain all
  the information to \emph{re-resolve} the reference each time the program is
  parsed.

  \item In projectional editors where every program element has a unique ID, a
  reference is simply a pointer to that ID. Once a reference is established, it
  can always be re-resolved trivially based on the ID. The reference is established directly as
  the program is edited: the code completion menu shows candidate target
  elements for a reference in the code completion menu and selection of one of
  them creates the reference. Of The code completion menu shows some
  human-readable (qualified) name of the target, but the persisted program uses
  the unique ID once the user makes a selection.

\end{itemize}

\noindent Typically, a language's structure definition specifies which concepts
constitute valid target concepts for references (e.g.,~a \ic{Function}, a \ic{Variable}, or
a \ic{State}), but this is usually too imprecise. Language-specific visibility
rules determine which \emph{instances} of these concepts are actually permitted
as a reference target. For example, only the function and variables \emph{in the
local module} or the states \emph{in the same state machine as the transition}
may be valid targets.

The collection of model elements which are valid targets of a particular
semantic cross-reference is called the \emph{scope} of that cross-reference.
Typically, the scope of a particular cross-reference not only depends on the
target concept of the cross-reference but also on its surroundings, e.g.\ the
namespace within which the element lives, the location inside the larger
structure of the site of the cross-reference or something that's essentially
non-structural in nature.

A scope, the collection of valid targets for a reference, has two uses. First,
it can be used to populate the code completion menu in the IDE if the user
presses \keystroke{Ctrl-Space} at the reference site. Second, independent of the
IDE, the scope is used for checking the validity of an existing reference: if
the reference target is not among the elements in the scope, the reference is
invalid.


\todofig{Add a picture on the right showing a hierarchy of scopes}
Scopes can be hierarchical, in which case they are organized as a stack of
collections --- confusingly, these collections are often called scopes
themselves. During resolution of a cross-reference, the lowest or
\emph{innermost} collection is searched first. If the reference cannot be
resolved to match any of its elements, the parent of the innermost collection is
queried, and so forth.

The hierarchy can follow or mimic the structure of the language itself: e.g.,
the innermost scope of a reference consists of all the elements present in the
directly-encompassing "block" while the outermost scope is the \emph{global}
scope. This provides a mechanism to disambiguate target elements having the same
reference syntax (usually the target element's name) by always choosing the
element from the innermost scope --- this is often called "shadowing".

Instead of looking at scopes from the perspective of the reference (and hence
calculating a set of candidate target elements), one can also look at scopes
from the perspective of visibility. In this case, we (at least conceptually)
compute for each location in the program, the set of visible elements. A
reference is then restricted to refer to any element from those visible at the
particular location. Our notion is more convenient from the cross-reference
viewpoint, however, as it centers around resolving particular cross-references
one at a time. From an implementation point of view, both perspective are
exchangable.


\section{Scoping in Spoofax}

In Spoofax, each language concept has its own private namespace. For example,
functions may live in the \ic{Functions} namespace and properties may live in
the \ic{Property} namespace. Namespaces can be defined as part of a grammar
definition by adding annotations to productions. Spoofax supports three
different forms of annotations: annotations for language elements that define
something in a namespace, for elements that reference something in a namespace,
and for block constructs.

\subsection{Definitions and References}

In the previous chapter we described how to specify a grammar for a subset of
the mobl language. This chapter shows how to add annotations and rules to define
name resolution for this language.

To understand naming in Spoofax, the notion of a \emph{namespace} is essential.
Some languages such as C\# provide namespaces as a language concept to scope the names of declarations such as classes.
It is important to distinguish these namespaces as a language concept from 
Spoofax' namespaces as a language definition concept.
In Spoofax, a namespace is a collection of names and is not necessarily connected to a specific language concept. 
Different concepts can contribute names to a single namespace. 
During reference resolution, names are resolved against namespaces.

Language elements that contribute names to a a namespace can be annotated with
\ic{Namespace@=Symbol}, where \ic{Namespace} is the namespace of the definition,
and \ic{Symbol} is the grammatical symbol that represents the name of the
concept, and that is contributed to the namespace. As an example, wecan add this annotation to the production for \ic{Entity} definitions:
\begin{lstlisting}[language=sdf]
"entity" Type@=ID "{" EntityBodyDecl* "}" -> Decl {"Entity"}
\end{lstlisting}

\noindent 
The annotation indicates that every program element that corresponds to this
production defines a name in the \ic{Type} namespace. It also indicates the name
of the program element: the identifier \ic{ID} that follows after the
\ic{entity} keyword.

Note how Spoofax distinguishes the name of a namespace from the type of a
program element: the type of the program element above is \ic{Decl}, but it
lives in the \ic{Type} namespace. By distinguishing these two things, it becomes
easy to add or exclude program elements from a namespace. For example,
\ic{import} statements are also of syntactic type \ic{Decl}, but they do not
live in the \ic{Type} namespace. Likewise, we could add the primitive integer
and string types to the \ic{Type} namespace, even though they are syntacticallya very different concept from entity declarations.

References to definitions are defined in a similar fashion, using the notation
\ic{Namespace@Symbol}:
\begin{lstlisting}[language=sdf]
Property@=ID ":" Type@ID -> EntityBodyDecl {"Property"}
\end{lstlisting}

\noindent 
The first annotation here says that the production defines something in the 
\ic{Property} namespace, while the second says that the \ic{ID} after the 
colon references something in the \ic{Type} namespace.

\subsection{Basic Scoping Rules}

Scoping annotations\footnote{Unfortunately the term \emph{scope} is used in a
slightly different way in Spoofax.} define the block structures of a language.
Block structures can be nested and determine the visibility of names. For
example, functions are block structures that can contain local variable
definitions that are not visible from outside the function. Internally, the
local variables are then assigned a qualified name based on the name of the
function. The same principle applies to fields in a Java class, properties in a
mobl entity, and so on. Block structures can be specified by adding
\ic{scope(Namespace)} at the end of a production:

\begin{lstlisting}[language=sdf]
"entity" Type@=ID "{" EntityBodyDecl* "}" -> Entity {"Entity", scope(Property)}
\end{lstlisting}

\noindent 
Here, the \ic{scope} annotation indicates that every entity scopes the
properties inside it. These scopes are used to qualify the names of every
property inside an entity:

\begin{lstlisting}[language=webdsl]
entity Customer {
  name : String		// Customer.name
}

entity Product {
  name : String 	// Product.name
}
\end{lstlisting}

\noindent 
In this example, the two \ic{name} properties both live the \ic{Property}
namespace, but we can still distinguish them: one can be reached as
\ic{Customer.name}, the other as \ic{Product.name}. This means that if \ic{name}
is referenced in a function inside \ic{Customer}, then it references the first
one, not the one in \ic{Product}\footnote{Note that Spoofax does not require
each name inside a block structure to be unique: by default, it is not an error
if users add an additional property called name to \icsn{Product}. However, in
most languages it is desirable to prevent assigning duplicate (qualified) names.
We show how to specify a constraint for that later on \todoref{}.}. The full
grammar of the mobl entities language with annotations is the following (leaving
out the lexical syntax):

\guido{
I am not sure if this should be discussed here, it requires more adjustment rules.

how are the fully qualified names built?
how can "private" properties be implemented?}

\begin{lstlisting}[language=sdf]
module MoblEntities

context-free start symbols

  Module
  
context-free syntax

  "module" Module@=ID Decl* -> Module {"Module", scope(Entity)}
  "entity" Type@=ID "{" EntityBodyDecl* "}"
                              -> Decl {"Entity", scope(Property,Function)}
  "import" Module@ID          -> Decl {"import"}
  Property@=ID ":" Type@ID    -> EntityBodyDecl {"Property"}

  "function" Function@=ID "(" {Param ","}* ")" ":" Type@ID "{" Statement* "}"
                              -> EntityBodyDecl {"Function", scope(Var)}
  Var@=ID ":" Type@ID         -> Param {"Param"}
  "var" Var@=ID "=" Expr ";"  -> Statement {"Declare"}
  "return" Exp ";"            -> Statement {"Return"}

  Exp "." Function@ID "(" Exp  ")" -> Exp {"MethodCall"}
  Exp "." Property@ID              -> Exp {"FieldAccess"}
  Exp "+" Exp                      -> Exp {"Plus"}
  Exp "*" Exp                      -> Exp {"Mul"}
  _@ID                             -> Exp {"Var"}
  INT                              -> Exp {"Int"}
\end{lstlisting}

\noindent 
A special case in this grammar is the rule for \ic{"Var"}, which can refer to
multiple namespaces (the underscore represents a wildcard). Consider the
statement \ic{return x.y;}. In such a statement, \ic{x} can be a local variable
(\ic{Var}) or a local property (\ic{Property}). In the full mobl language, it
can even be a type (\ic{Type}). As this more complicated scenario is not covered
by the annotations, we specify an \ic{\_} in the grammar instead.
The \ic{\_} indicates that we specify additional, manual rules for resolving
this case. We show how to specify these at the end of this section. \todoref{}

\subsection{URIs for Program Elements}

Each program element that defines something is assigned a URI. The URI uniquely
identifies the element across a project. By default, these URIs are constructed
automatically, based on the namespace and scope annotations in the grammar. As
an example, consider the following entity.


\begin{lstlisting}[language=webdsl]
module storage
entity Store {
  name    : String
  address : Address
}
\end{lstlisting}

\noindent 
Following the annotated mobl grammar, there are two block constructs in this
fragment: one at the module level and one at the entity level. We can assign
names to these blocks (\ic{storage} and \ic{Store}) by using the namespace
definition annotations. By creating a hierarchy of these names, Spoofax creates
URIs: the URI for \ic{Store} is \ic{Type://storage.Store}, and the one for
\ic{name} is
\ic{Property://}\linebreak[0]\ic{storage.}\linebreak[0]\ic{Store.name}.
URIs are represented internally as lists of terms, that start with the
namespace, followed by a reverse hierarchy of the path names\footnote{The
reverse order used in the representation makes it easier to efficiently store
and manipulate URIs in memory: every tail of such a list can share the same
memory space.}:

\begin{lstlisting}
[Property(), "name", "Store", "storage"]
\end{lstlisting}


\noindent 
In most cases, parts of a path are simple strings, such as \ic{"Store"}, but
they can be complex terms if needed. An example is \emph{anonymous} blocks that
do not have a name associated with them. Block statements in C-like languages 
are an example of this. These scopes are handled differently from named scopes. 
We can add a block statement to our grammar by adding the following production:

\begin{lstlisting}[language=sdf]
"{" Stm* "}" -> Stm {"Block", Scope(Var)}
\end{lstlisting}

\noindent 
The block statement does not define a definition name, but can still become part
of a URI. Instead of a name, that part will then have the form \ic{Anon(n)}
where \ic{n} is a generated number that identifies the block. \ic{Anon(n)} is anexample of a complex term.

URIs can be inspected using the default hover help popups, or using Spoofax' analyzed
syntax view. This view shows the abstract syntax with all URIs as annotations\footnote{To obtain this view, press \emph{Show analyzes syntax(selection)} in the \emph{Transform} menu of the Spoofax editor. Spoofax will open a new editor which updates automatically when the content of the original editor changes}.
Consider the following example with both named and anonymous blocks:

\begin{lstlisting}[language=webdsl]
module banking

entity BankAccount {
  name   : String
  number : Num
  
  function toCapitals() : String {
    { // anonymous block
      var result = name.toUpperCase();
      return result;
    } 
  }
}
\end{lstlisting}

\noindent 
The analyzed abstract syntax for this example is the following:

\begin{lstlisting}
Module(
  "banking"{[Module(),"banking"]},
  [ Entity(
      "BankAccount"{[Type(),"BankAccount","banking"]},
      [ Property(
          "name"{[Property(),"name","BankAccount","banking"]},
          "String"{[Type(),"String","mobl"]}
        ),
        Property(
          "number"{[Property(),"number","BankAccount","banking"]},
          "Num"{[Type(),"Num","mobl"]}
        ),
        Function(
          "toCapitals"{[Function(),"toCapitals","BankAccount","banking"]},
          [],
          "String"{[Type(),"String","mobl"]},
          Block([
            Declare(
              "result"{[Var(),"result",Anon(125),"toCapitals","BankAccount","banking"]},
              MethodCall(..., ...{[Function(),"toUpperCase","String","mobl"]})
            ),
            Return(
              Var("result"{[Var(),"result",Anon(125),"toCapitals","BankAccount","banking"]})
            )
          ])
        )
      ]
    )
  ]
) 
\end{lstlisting}

\noindent 
The annotations indicate the URIs of each definition and reference.
They can be used to get an unrefined view of all URIs at a glance, but
also have a role in transformations on abstract syntax, as we discuss later.

Any references that cannot be resolved are annotated with a special
\ic{Unresolved} constructor. For example, a variable \ic{nonexistent} could be
represented as
\ic{Var("nonexistent"\curlies{[Unresolved(Var()),"non\-existent",...]})}. This
makes it easy to recognize any unresolved references in analyses or
transformations

\guido{code? text?

give some examples of analyses + transformations}.


\subsection{Persistence of Naming Information}
\label{Sec:spoofax-index}

Spoofax stores all definitions and references in an in-memory data structure
called the index\footnote{It can also store information about definitions, such
as type information, as we show in the next chapter.}. By collecting all this
summary information about files in a project together, it ensures fast access to
global information. The index is updated automatically with changes to the file
system (e.g.,~files being deleted or removed) and is persisted as Eclipse exits.
All entries in the index have a URI as we showed previously. Index entries can
be represented in the ATerm format (see \todoref{}). For example,
\ic{Def([Module(),"banking"])} is a definition entry for a banking module.
In the form of terms, they can be used in the same way as abstract syntax tree
fragments in transformations and analyses. \sect{ch:constraints} shows how
the index can be used for such tasks.

Internally, index entries are stored in tables for efficient random access. They
also contain meta-data such as the file name and line number of the definition.
With this meta-data, Spoofax can provide editor services such as reference
resolving. Note that there is no requirement that file names correspond to the
URIs: a \ic{banking.Bank} entity could be defined in any file, as long as there
are no constraints in the language that prevent that.


\subsection{The Default Name Resolution Strategy}

The structure of URIs forms the basis of the default name resolution strategy of
Spoofax\footnote{The default strategy can be customized, but we first take a
closer look at how name resolution works just based on the annotations in the
grammar.}. Consider the \ic{address} property in the \ic{Store} entity:

\begin{lstlisting}[language=webdsl]
module storage

entity Store {
  name    : String
  address : Address
}
\end{lstlisting}

\noindent 
The \ic{address} property references something named \ic{Address}. According to
the grammar, that something lives in the \ic{Type} namespace. Spoofax resolves
this name by looking at the context: is there an \ic{Address} in
\ic{Type://storage.Store}? If not, it will keep trying the parent URI:
\ic{Type://storage} and finally \ic{Type://}. If it is successful in finding it
this way, it can resolve the reference, otherwise it displays an error marker in
the editor.


The default resolution strategy is designed to be generic and makes few
assumptions about a specific language\footnote{Spoofax expects language
designers to \emph{manage by exception}.}. By default, it does not care about
file boundaries: if an \ic{Address} is defined in a different file, it will
still find it. There is also no default constraint for duplicate names: two
definitions of \ic{Address} are fine (in which case a reference will resolve to one of them). 
Lastly,
the default strategy knows nothing about import definitions for a specific language, as these can vary quite a bit among languages.

\subsection{Rewrite Rules}
\label{Sec:rewrite-rules}

Spoofax provides support for adding constraints and for customization of the
behavior of the default resolution strategy by means of \emph{rewrite rules}.
Rewrite rules are functions that operate on terms, transforming one term to
another. We provide a primer on rewrite rules here, and show how they can be
used to customize name resolution\footnote{Rewrite rules are used for all
kinds of other purposes in Spoofax, and we will encounter them again, for
example in the chapter on transformation and code generation \todoref{}. This
is why we explain them in quite some detail here.}.


\guido{
This was exactly done in the paragraph before the subsection. Moved it into.

Please explain why we need all this detail here AT THIS LOCATION (along
the lines of: we need a general intro to rewriting somewhere, because we'll use
rewriting later. So we decided to put it here, because we need some of it for linking
and scoping).}

Rewrite rules in Spoofax are provided as part of the Stratego program
transformation language. A basic rewrite rule that transforms a term pattern
\ic{term1} to a term pattern \ic{term2} has the following form:

\begin{lstlisting}[language=stratego]
rule-name:
  term1 -> term2
\end{lstlisting}

\noindent 
Term patterns have the same form as terms: any term is a legal term pattern.
In addition to the basic constructors, string literals, integer literals, and so
on, they also support variables (e.g.,~\ic{v} or \ic{name}) and wildcards
(indicated by \ic{\_}). As an example, the following rewrite rule rewrites an
\ic{Entity} to the list of properties contained in that entity:

\begin{lstlisting}[language=stratego]
get-properties-types:
  Entity(name, properties) -> properties
\end{lstlisting}

\noindent 
So, for an entity \ic{Entity("User", [Property("name", String)])}, it binds
\ic{"User"} to the variable \ic{name}, and \ic{[Property("name", "String")]}
to the variable \ic{properties}. It then returns \ic{properties}. While rewrite
rules can be viewed as functions, they have one important difference:
they can be defined multiple times for different patterns\footnote{This is
comparable to polymorphic overloading.}. In the case of \ic{get-properties}, we
could add another definition that works for property access expressions:

\begin{lstlisting}[language=stratego]
get-properties:
  FieldAccess(expr, property) -> property
\end{lstlisting} 

\noindent 
Rules can have complex patterns. For example, it is possible to write a rule
that succeeds only for entities with \emph{only} a \ic{name}
property\footnote{Note how this rule uses a wildcard since it doesn't care about
the name of the entity.}:

\begin{lstlisting}[language=stratego]
is-name-only-entity:
  Entity(_, [Property("name", "String")]) -> True()
\end{lstlisting}


\noindent 
Rewrite rules can be invoked using the syntax \ic{<rule-name> term}. For
example, \ic{<get-properties> Entity("Unit", [])} would return an empty list of
properties. The angle brackets make it easy to distinguish rule invocations
from terms, and makes it possible to use invocations in term expressions.

Stratego provides a \ic{with} clause that can be used for additional code that
should be considered for rewrite rules. The \ic{with} clause is most commonly
used for assignments and calls to other rules. As an example, we can write the
rule above using a \ic{with}. This rule assigns the value of \ic{get-properties}
to a variable \ic{result} and returns that as the result value of the rule:

\begin{lstlisting}[language=stratego]
invoke-get-properties:
  Entity(name, properties) -> result
  with
    result := <get-properties> Entity(name, properties)
\end{lstlisting}

\noindent 
Rules can also have conditions. These can be specified using
\ic{where}\footnote{If the pattern of a rule does not match, or if its
conditions do not succeed, a rule is said to \emph{fail}.}. These clauses
typically use the operators listed in \fig{Fig:stratego-operators}.
An example of a rule with a \ic{where} clause is the following:

\begin{lstlisting}[language=stratego]
has-properties:
  Entity(name, properties) -> True()
  with
    properties := <get-properties> Entity(name, properties);
  where
    not(!properties => [])  
\end{lstlisting}

\noindent 
This rule only succeeds for entities where the condition \ic{not(!properties =>
[])} holds. That is, it succeeds as long as an entity does not have an empty
list (indicated by \ic{[]}) of properties. Rewrite rules can have any number of
\ic{where} and \ic{with} clauses, and they are evaluated in the order they
appear.

\begin{figure}[t]
\begin{tabular}{|l|l|}
\hline
\textbf{Expression} & \textbf{Description} \\ 
\hline
\ic{<e> t} & Applies \ic{e} to \ic{t}, or fails if \ic{e} is unsuccessful. \\
\ic{v := t} & Assign a term expression \ic{t} to a variable \ic{v}. \\ 
\ic{!t => p} & Match a term \ic{t} against a pattern \ic{p}, or fail. \\
\ic{not(e)} & Succeeds if \ic{e} does not succeed. \\
\ic{e1; e2} & Sequence: apply \ic{e1}. If it succeeds, apply \ic{e2}. \\ % Fail if either \ic{e1} or \ic{e2} fails. \\
\ic{e1 <+ e2} & Choice: apply \ic{e1}, if it fails apply {e2} instead. \\
%\ic{if e then e1 else e2 end} & If \ic{e} succeeds, then apply \ic{e1}, else \ic{e2}. \\
\hline
\end{tabular}
\caption{Operators in Stratego expressions.}
\label{Fig:stratego-operators}
\vspace{2mm}
\end{figure}



\noindent 
Like functions or methods in other languages, rewrite rules can have parameters.
Stratego distinguishes between parameters that pass other rules and parameters
that pass terms, using a vertical bar to separate them two separate lists. Rules
that take both rule and term parameters have a signature of the form
\ic{rule(r|t)}, those with only rule parameters use \ic{rule(r)}, and those with
only term parameters use \ic{rule(|t)}. The Stratego standard library provides a
number of higher-order rules, i.e.\ rules that take other rules as their
argument. These rules are used for common operations on abstract syntax trees:
for example, \ic{map(r)} applies a rule \ic{r} to all elements of a list:

\begin{lstlisting}[language=stratego]
get-property-types:
  Entity(_, properties) -> types
  with
    types := <map(get-property-type)> properties

get-property-type:
  Property(_, type) -> type
\end{lstlisting}

\noindent 
Rules like \ic{map} specify a \emph{traversal} on a certain term structure: they
specify how a certain rule should be applied to a term and its subterms. Rules
that specify traversals are also called \emph{strategies}\footnote{This is where
the name of the \emph{Stratego} transformation language comes from.}.
In Spoofax, strategies are used to control traversals in constraints,
transformation, and code generation.

\guido{Not sure how to handle this, need to discuss this

this section is extremely dense -- to me it is now unclear what the
intention is: to provide a manual about Spoofax? or to present more abstract concepts?
}

\subsection{Customizing the Name Resolution Strategy}

To customize the name resolution strategy, Spoofax language definitions can
include \ic{adjust-index-lookup} rules. These rules have a specific signature,
and are invoked by the name resolution strategy for each reference that is
resolved\footnote{This is a rewriting rule with a predefined name and signature
so it can be invoked by Spoofax. It can be redefined to apply to specific
language concepts.}. As an example, consider how a reference to a local
property is resolved in mobl:

\begin{lstlisting}[language=webdsl]
entity BankAccount {
  function getNumber() : Num {
    return number;
  }
  
  name   : String
  number : Num
}
\end{lstlisting}

\noindent 
Here, the function \ic{getNumber} references the local \ic{number} property.
The production rule we previously specified for these kinds of references
used an underscore to indicate that we would manually specify how to resolve
it\footnote{Because properties and variables can be referenced.}:

\begin{lstlisting}
_@ID -> Exp {"Var"}
\end{lstlisting}

\noindent 
So, we need to specify a \ic{adjust-index-lookup} rule for the variables:

\begin{lstlisting}[language=stratego]
adjust-index-lookup(target |namespace, path, name):
  Var(x) -> adjusted-uris
  where
    <target> x
  with 
    adjusted-uris := ...
\end{lstlisting}

\noindent 
Each \ic{adjust-index-lookup} rule has this exact signature: it gets a
\ic{target} rule argument, and term arguments with the \ic{namespace},
\ic{path}, and \emph{name} of the reference to be resolved. 
On the left-hand side, it specifies what construct it matches against.
In this case, we want to resolve a variable.
Next, we need to specify which part of the node is the name we want to resolve.
\footnote{There might be nodes with more than one name to resolve, for example in a qualified package name, each segment refers to a package.}
In a variable reference \ic{Var(x)}, the \ic{x} is the name we want to resolve.
We specify this explicitely as the first condition of the rule: \ic{where <target> x}.
On the right-hand side, the rule returns a list of adjusted URIs.
Spoofax will then use these URIs to further resolve the element.

A variable might refer either to a variable (namespace \ic{Var}) or a property (namespace \ic{Property}).
Since we got the current \ic{path} of the variable as a parameter, we can construct two possible URIs, where the definition site can be found: \ic{Var://path} and \ic{Property://path}\footnote{Remember that URIs are represented as lists. We use the namespace as the head of the list and the path as the tail. The variable name is not part of these URIs.}:

\begin{lstlisting}[language=stratego]
adjust-index-lookup(target |namespace, path, prefix):
  Var(x) -> adjusted-uris
  where
    <target> x
  with
    var-uri       := [Var() | path];
    property-uri  := [Property() | path];  
    adjusted-uris := [var-uri, property-uri]
\end{lstlisting}

\noindent Note, that the URIs do not contain the variable name \ic{x}.
This is, because the URIs specify containers telling Spoofax where to look for the variable.
We return both URIs in a list of adjusted URIs.
The order in this list is important.
Spoofax will first look only for variables, before it will look for properties.

The example code we have seen so far is pretty verbose for explanation.
A typical shorter way to adjust variable lookup, would look like this:

\begin{lstlisting}[language=stratego]
adjust-index-lookup(target |namespace, path, prefix):
  Var(<target>) -> [[Var() | path], [Property() | path]]
\end{lstlisting}

\noindent Here, the \ic{target} is marked in the left-hand side of the rule. On
the right-hand side, we construct the list of adjusted URIs right away.

% \begin{lstlisting}
% "import" Module@ID -> Decl {"Import"}
% \end{lstlisting}
% 
% \ic{Import("customers")}
% 
% \begin{lstlisting}
%   adjust-index-lookup(target |namespace, path, prefix): 
%     Type(<target>) -> <concat> [primitives, [[Type() | path]], importPaths]
%     with
%       importPaths := <filter(import-to-path)> <index-get-all-in-file(|Import)> <index-get-current-file>;
%       primitives := <map(type-of; type-to-def)> <primitive-types>
%     
%   import-to-path:
%     Def([Import(), EntityImport(mod, ent)|_]) -> Def([Type(), ent, mod])
% \end{lstlisting}




%unifying Var and Property namespace?
%
%
%When needed, the path elements that are created for a scope can be customized
%using a rewrite rule:
%
%\begin{lstlisting}
%adjust-index-path(is-def | namespace, path, prefix):
%  Entity(name, body) -> [Entity(), name]
%\end{lstlisting}
%
%%
%
%
%\begin{lstlisting}
%adjust-index-path(target | namespace, path, prefix):
%  Var(<target>) -> 
%\end{lstlisting}





\section{Scoping in Xtext}

Xtext provides Java APIs for implementing all aspects of languages except the
grammar\footnote{In fact, you can use any JVM-based language for implementing
these language aspects, including Xtend}. Language developers typically provide
Java classes that implement aspect-specific interfaces and then contribute those
to Xtext using Google Guice, a dependency injection
framework\footnote{http://code.google.com/p/google-guice/}. For most language
aspects, Xtext comes with various default implementations developers can build
on. A lot of functionality is provided out-of-the-box with minimal
configuration, but it's easy to swap out specific parts by binding another or a
custom class through Guice.

\subsection{Simple, Local Scopes}

To implement scopes, language developers have to contribute a class that
implements the \ic{IScopeProvider} interface. It has one method called
\ic{getScope} that returns an \ic{IScope} for a given reference. An \ic{IScope}
is basically a collection of candidate reference targets, together with the
textual representation by which these may be referenced from the current
reference site (the same target may be referenced by different text strings from
different program locations). The \ic{getScope} method has two arguments: the
first one, \ic{context}, is the current program element for which a reference
should be scoped; the second one, \ic{reference}, identifies the reference for
which the scope that needs to be calculated.

\begin{lstlisting}[language=java] 
public interface IScopeProvider {
    IScope getScope(EObject context, EReference reference);
}
\end{lstlisting}

\noindent 
To make the scoping implementation easier, Xtext provides so-called declarative
scope providers through the \ic{AbstractDeclarativeScopeProvider} base class:
instead of having to inspect the \ic{reference} and \ic{context} object
manually to decide how to compute the scope, the language implementor can
express this information via the name of the method (using a naming convention).
Two different naming conventions are available:


\begin{lstlisting}[language=java]
// <X>, <R>: scoping the <R> reference of the <X> concept 
public IScope scope_<X>_<R>(<X> ctx, EReference ref );

// <X>: the language concept we are looking for as a reference target
// <Y>: the concept from under which we try to look for the reference 
public IScope scope_<X>(<Y> ctx, EReference ref);
\end{lstlisting}

 
\noindent 
Let's assume we want to scope the \ic{targetState} reference of the
\ic{ChangeStateStatement}. Its definition in the grammar looks as follows:

\begin{lstlisting}[language=xtextgrammar]
ChangeStateStatement:
    "state" targetState=[State];
\end{lstlisting}

\noindent 
We can use the following two alternative methods:

\begin{lstlisting}[language=java]
public IScope scope_ChangeStateStatement_targetState
              (ChangeStateStatement ctx, EReference ref ) {
    ...            
}
            
public IScope scope_State(ChangeStateStatement ctx, EReference ref) {
    ...
}
\end{lstlisting}


\noindent 
The first alternative is specific for the \ic{targetState} reference of the
\ic{ChangeStateStatement}. It is invoked by the declarative scope provider only
for that reference. The second alternative is more generic. It is invoked
whenever we are trying to reference a \ic{State} (or any subconcept of
\ic{State}) from any reference of a \ic{ChangeStateStatement} and \emph{all its
descendants}. So we could write an even more general alternative, which scopes
the visible \ic{State}s from anywhere in a \ic{CoolingProgram}, independent of
the actual reference\footnote{Depending on the structure of your language, Xtext
may have a hard time finding out the current location, and hence, the reference
that needs to be scoped. In this case, the tighter versions of the scoping
method (\icsn{scope\_ChangeStateStatement\_targetState} in the example) might not
be called in all the places you expect it to be called. This can be remedied
either by changing the syntax (often not possible or not desired), or by using
the more general variants of the scoping function
\icsn{scope\_State(CoolingProgram ctx, ... )}. It is a good idea to always use the
most general variants, unless you specifically want to scope one specific
reference.}.

\begin{lstlisting}[language=java]
public IScope scope_State(CoolingProgram ctx, EReference ref) {
    ...
}
\end{lstlisting}


\noindent 
The implementation of the scopes is simple, and relatively similar in all three
cases. We write Java code that crawls up the containment hierarchy until we
arrive at a \ic{CoolingProgram} (in the last alternative, we already get the
\ic{CoolingProgram} as an argument, so we don't need to move up the tree), and
then construct an \ic{IScope} that contains the \ic{State}s defined in that
\ic{CoolingProgram}. Here is a possible implementation:


\begin{lstlisting}[language=java]
public IScope scope_ChangeStateStatement_targetState
            (ChangeStateStatement ctx, EReference ref ) {
    CoolingProgram owningProgram = Utils.ancestor( ctx, CoolingProgram.class );
    return Scopes.scopeFor(owningProgram.getStates());
}
\end{lstlisting}

\noindent 
The \ic{Scopes} class provides a couple of helper methods to create \ic{IScope}
objects from collections of elements. The simple \ic{scopeFor} method 
will use the \ic{name} of the target element as the text by which it will be
referenced\footnote{You can pass in code that creates other strings than then
name from the target element.}. So if a state is called \ic{normalCooling}, then
we'd have to write \ic{state normalCooling} in a \ic{ChangeStateStatement}. The
text \ic{normalCooling} acts as the reference --- pressing \keystroke{Ctrl-F3}
on that program element will go to the referenced state. 




\subsection{Nested Scopes} 

The approach to scoping shown above is suitable for simple cases, such as the
\ic{targetState} reference shown above. However, in languages with nested blocks
a different approach is recommended. Here is an example of a program expressed in
a language with nested blocks:


\begin{lstlisting}[morekeywords={var, int, function, return, foreach, in}]
var int x;		
var int g;
 
function add( int x, int y ) {
    int sum = x + y;               // 1
    return sum;
}

function addAll( int es ... ) {
    int sum = 0;                 
    foreach( e in es ) { 
        sum += e;                // 2
    }
    x = sum;                     // 3
}
\end{lstlisting}


\noindent 
At \ic{1}, the local variable \ic{sum}, the arguments \ic{x} and \ic{y} and the
global variables \ic{x} and \ic{g} are visible, although the global variable
\ic{x} is shadowed by the argument of the same name. At \ic{2}, we can see
\ic{x}, \ic{g}, \ic{sum} and \ic{es}, but also the iterator variable \ic{e}. At
\ic{3}, \ic{x} refers to the global since it is not shadowed by a parameter or
local variable of the same name. In general, certain program elements introduce
blocks (often statement lists surrounded by curly braces). A block can
declare new symbols. References from within these blocks can see the symbols
defined in that block, as well as all ancestor blocks. Symbols in inner blocks
typically hide symbols with the same name in outer blocks. The symbols in outer
blocks are either not accessible at all, or a special name has to be used, for
example, by prefixing them with some \ic{outer} keyword (for example,
\ic{outer.x}).

Xtext's scopes support this scenario. \ic{IScopes} can reference outer scopes.
If a symbol is not found in any given scope, that scope delegates to its outer
scope (if it has one) and asks it for a symbol of the respective name. Since
inner scopes are searched first, this implements shadowing as expected.

Also, scopes are not just collections of elements. Instead, they are maps
between a string and an element\footnote{In addition, the text shown in the code
completion window can be different from the text that will be used as the
reference once an element is selected. In fact, it can be a rich string that
includes formatting, and it can contain an icon.}. The string is used as the
reference text. By default, the string is the same as the target element's
\ic{name}. So if a variable is called \ic{x}, it can be referenced by the string
\ic{x}. However, this reference string can be changed as part of the scope
definition. This can be used to make shadowed variables visible under a
different name, such as \ic{outer.x} if it is referenced from location \ic{1}.
The following is pseudo-code that implements this behavior:


\begin{lstlisting}[language=java]
// recursive method to build nested scopes
private IScope collect( StatementList ctx ) { 
    IScope outer = null
    if ( ctx is within another StatementList parent ) {
        outer = collect(parent)
    }
    IScope scope = new Scope( outer )
    for( all symbols s in ctx ) {
        scope.put( s.name, s )
        if ( outer.hasSymbolNamed( s.name ) ) {
            scope.put( "outer."+s.name, outer.getSymbolByName( s.name ) )
        }
    } 
    return scope
}

// entry method, according to naming convention 
// in declarative scope provider
public IScope scope_Symbol( StatementList ctx ) {
    return collect( ctx )
}	
\end{lstlisting}


\subsection{Global Scopes} 

There is one more aspect of scoping that needs to be discussed. Programs can be
separated into several files and references can cross file boundaries. That is,
an element in file \ic{A} can reference an element in file \ic{B}. In earlier
versions of Xtext file \ic{A} had to explicity import file \ic{B} to make the
elements in \ic{B} available as reference targets. This resulted in several
problems. First, for internal reasons, scalability was limited. Second, as a
consequence of the explicit file imports, if the referenced element was moved
into another file, the import statements in all referencing files had to be
updated.

Since Xtext 1.0 both of these problems are solved using the so-called
index\footnote{This is similar to Spoofax'es index discussed above}.
The index is a data structure that stores
(\ic{String},\ic{IEObjectDescription})-pairs.
The first argument is the qualified name of the object and the second one, the
\ic{IEObjectDescription}, contains information about a model element, including
a URI (a kind of global pointer that also includes the file in which the element
is stored) as well as arbitrary additional data provided by the language
implementation. By default, all references are checked against this name in the
index, not against the actual object. If the actual object has to be resolved,
the URI stored in the index is used. Only then is the respective file
loaded\footnote{This is what improved scalability; files are only loaded if a
reference target is accessed, not to check a reference for validity}. The index
is updated whenever a file is changed (even when it has not been saved, so
references against dirty editors work). This way, if an element is moved to a
different file while keeping its qualified name (which is based on the logical
program structure) constant, the reference remains valid.
Only the URI in the index is updated.

There are two ways to customize what gets stored in the index, and how. The
\ic{IQualifiedNameProvider} returns a qualified name for each program element.
If it returns \ic{null}, the element is not stored in the index, which means it
is not referencable. The other way is the
\ic{IDefaultResourceDescriptionStrategy} which allows language developers to
build their own \ic{IEObjectDescription} for program elements. This is important
if custom user data has to be stored in the \ic{IEObjectDescription} for later
use during scoping.

The \ic{IGlobalScopeProvider} is activated if a local scope returns \ic{null} or
no applicable methods can be found in the declarative scope provider class (or
if they return \ic{null}). By default, the
\ic{ImportNamespacesAwareGlobalScopeProvider} is configured\footnote{The
specific implementation is configured through a Guice binding.}, which provides
the possibility to reference model elements outside of the current file either
through their (fully) qualified name or through their unqualified name using an
\ic{import} statement\footnote{That \icsn{import} statement is different from
the one mentioned earlier: it makes the contents of the respective namespace
visible, it does not refer to the a particular file.}.




\parhead{Polymorphic References} In the cooling language, expressions also
include references to various other entities, such as configuration parameters,
variables and hardware elements (compressors or fans defined in a different
model). All of these referenceble elements extend the \ic{SymbolDeclaration}
meta class. This means that all of them can be referenced by the single
\ic{SymbolRef} construct.
\begin{lstlisting}[language=xtextgrammar]
AtomicLevel returns Expression:
    ...
    ({SymbolRef} symbol=[SymbolDeclaration|QID]);
\end{lstlisting}  

\noindent 
The problem with this situation is that the reference itself does not encode the
kind of thing that is referenced. By looking at the reference alone we only know
that we reference some kind of symbol. This makes writing code that processes
the model cumbersome, since the target of a \ic{SymbolRef} has to be taken into
account when deciding how to treat (translate, validate) a symbol reference. A
more natural design of the language would use different reference constructs for
the different referencable elements. In this case, the reference itself is
specific to the referenced element, making processing much easier\footnote{It
would also make writing the scopes and extending the language simpler}:

\begin{lstlisting}[language=xtextgrammar] 
AtomicLevel returns Expression:
    ...
    ({VariableRef} var=[Variable]);
    ({ParameterRef} param=[Parameter]);
    ({HardwareBuildingBlockRef} hbb=[HardwareBuildingBlock]);
\end{lstlisting}  

\noindent 
However, this is not possible with Xtext, since the parser cannot distinguish
the three cases syntactically. In all three cases, the reference syntax itself
is just an \ic{ID}. Only during the linking phase could the system check which
kind of element is actually referenced, but this is too late for the parser,
which needs an unambiguous grammar. The grammar could be disambiguated by using
a different syntax for each element:

\begin{lstlisting}[language=xtextgrammar]  
AtomicLevel returns Expression:
    ...
    ({VariableRef} var=[Variable]);
    ({ParameterRef} "%" param=[Parameter]);
    ({HardwareBuildingBlockRef} "#" hbb=[HardwareBuildingBlock]);
\end{lstlisting}  

\noindent 
While this approach will technically work, it would lead to an awkward syntax
and is hence typically not used. The only remaining alternative is to make all
referencable elements extend \ic{SymbolDeclaration} and use a single reference
concept, as shown above.





\section{Scoping in MPS}

Making references work in MPS requires several ingredients. First of all,
developers define a reference as part of the language structure. Then, an editor
is defined that determines how the referenced element is rendered at the
referencing site\footnote{We have shown this in the previous chapter.}. To
determine which instances of the referenced concept are allowed, a scoping
function has to be implemented. It simply returns a list of all the elements
that are considered valid targets for the reference, as well a an optional text
string used to represent the respective element in the code completion menu.

As we have explained above \todoref{}, smart references are an important
ingredient to make this work conveniently. They make sure that users can simply
type the name (or whatever else is put into the code completion menu by the
language developer) of the targeted element; once something is selected, the
corresponding reference concept is instantiated, and the selected target is set.

\parhead{Simple Scopes} As an example, we begin with the scope definition for
the target reference of the \ic{Transition} concept. To recap, it is defined as:

\begin{lstlisting}[language=mps] 
concept Transition      
  // ...                                        
  references:                           
    State   target  1       
\end{lstlisting}

\noindent The scope itself is defined via the search scope constraint below. The
system provides an anonymous function \ic{search scope} that has a number of
arguments that describe the context including the enclosing node and the
referencing node. As the signature shows, the function has to return either an
\ic{ISearchScope} or simply a sequence of nodes of type \ic{State}. The scope of
the target state is simply the set of states of the state machine that
(transitively) contains the transition. To implement this, the expression in the
body of this function crawls up the containment hierarchy\footnote{Note that for
a smart reference, where the reference object is created only \emph{after}
selecting the target, the \icsn{referenceNode} argument is \icsn{null}! This is
why we write the scope using the \icsn{enclosingNode} argument.
} until it finds a \ic{Statemachine} and then returns its
\ic{states}\footnote{The code used to express scopes can be arbitrarily complex
and is implemented in MPS' BaseLanguge, an extended version of Java.}.
\begin{lstlisting}[language=mps] link {target}
  referent set handler:
    <none>
  search scope:
    (model, scope, referenceNode, linkTarget, enclosingNode)
             ->join(ISearchScope | sequence<node<State>>) {
      enclosingNode.ancestor<concept = Statemachine>.states;
    }
  validator:
    <default>
  presentation :
    <none>
;\end{lstlisting}

 

\noindent In addition to the search scope, language developers can provide code
that should be executed if a new reference target is set (\ic{referent set handler}),
additional validation (\ic{validator}), as well as customized
presentation in the code completion menu (\ic{presentation}).


\parhead{Nested Scopes} In a more complex, block oriented language with
nested scopes, a different implementation pattern is recommended\footnote{In
this section we describe the approach as we have implemented it for mbeddr C.
Since version 2.5, MPS supports this approach out of the box. For example, an
interface similar to \icsn{IScopeProvider} ships with MPS, and scopes
can be inherited from parent nodes.\todo{Is this good enough for the new
scopes?}}:

\begin{itemize}
  \item All program elements that contribute elements that can be referenced
  (such as blocks, functions or methods) implement an interface \ic{IScopeProvider}.
  \item This interface provides a method \ic{getVisibleElements(concept<> c)}
  that returns all elements of type \ic{c} that are available in that scope. 
  \item The search scope function simply calls this method on the owning
  \ic{IScopeProvider}, passing in the concept whose instances it wants to see 
  (\ic{State} in the above example).
  \item The implementation of the method recursively calls the method on its
  owning \ic{IScopeProvider}, as long as there is one. It also removes 
  elements that are shadowed from the result.
\end{itemize}
\noindent This approach is used in the mbeddr C language, for example for local
variables, because those are affected by shadowing from blocks. Here is the code for the
\ic{variable} reference of the \ic{LocalVariableReference} concept:

\begin{lstlisting}[language=mps]
link {variable} 
  search scope: 
    (model, scope, referenceNode, linkTarget, enclosingNode, operationContext)->join(ISearchScope | sequence<node<LocalVariableDeclaration>>) {
      // find the statement that contains this (future) local variable reference 
      node<Statement> s = enclosingNode.ancestor<concept = Statement, +>; 
      
      // find the first containing ILocalVariableScopeProvider; this is
      // typically next next higher statement that owns a StatementList, such
      // as a ForStatement or an IfStatement
      node<ILocalVarScopeProvider> scopeProvider = 
             enclosingNode.ancestor<concept = ILocalVarScopeProvider, +>;
      
      // if we are not in a Statement or there is no ILocalVarScopeProvider,
      // we return an empty list - no variables visible
      if (s == null || scopeProvider == null) { 
         return new nlist<LocalVariableDeclaration>; 
      }
      
      // we now retrieve the position of the current Statement in the 
      // context StatementList. This is important because we only want to 
      // see those variables that are defined before the reference site 
      int pos = s != scopeProvider ? s.index : LocalVarScope.NO_POSITION;
      
      // finally we create the scope and get the visible variables; 
      scopeProvider.getLocalVarScope(s, pos).getVisibleLocalVars(); 
    } 
\end{lstlisting}


\parhead{Polymorphic References} We have explained above how references work in
principle: they are real pointers to the referenced element, based on the
target's unique ID. In the section on Xtext we have seen how from a given
location only one kind of reference for any given syntactic form can be
implemented. Consider the following example, where we refer to a global variable
\ic{a} and an event parameter (\ic{timestamp}) from within expressions:

\begin{lstlisting}[language=mbeddr]
int a;
int b;

statemachine linefollower {                                                         
  in event initialized(int timestamp);
  states (initial=initializing) {                                                                
    state initializing {                                                      
      on initialized [now() - timestamp > 1000 && a > 3] -> running                                                   
    }     
    state running {
    }
  }                                                                            
}                                                                                   
\end{lstlisting}

\noindent 
Both references to local variables and to event parameters use the same
syntactic form: simply a text string that represents the name of the respective
target element. In Xtext, this has to be implemented with a single reference
concept, typically called \ic{SymbolReference}, that can reference to any kind
of \ic{Symbol}. \ic{LocalVariableDefintions} and \ic{EventParameters} would both
extend \ic{Symbol}, and scopes would make sure both kinds are visible from
within guard expressions. The problem with this approach is that the reference
itself contains no type information about what it references, it is simply a
\ic{SymbolReference}. Processing code has to inspect the type of the referenced
symbol to find out what a particular \ic{SymbolReference} actually
means\footnote{It can also be a problem regarding modularity, because every
referencable concept must extend \icsn{Symbol}. Referencable elements
contributed by an independently developed language which we may want to embed
into the C language will \emph{not} extend \icsn{Symbol}, though! We discuss
language modularization and composition in \todoref{}.}.

In projectional editors this is done differently. To solve the example above,
one would create a \ic{LocalVariableReference} and an
\ic{EventParameterReference}. The former references variables and the latter
references event parameters. Both have an editor that simply renders the name
of the referenced element, and each of them has \ic{their own} scope definition! 
So adding new kinds of references to existing expression languages can be done
in a modular fashion, since the new reference expression comes with its own,
independent scoping rule. The following is the respective code for the
\ic{EventArgRef} expression:

\begin{lstlisting}[language=mps]
concept EventArgRef extends Expression // this is the Expression concept from C

...

link {arg} 
  search scope: 
    (model, scope, referenceNode, linkTarget, enclosingNode, operationContext)
                               ->join(ISearchScope | sequence<node<EventArg>>) { 
      enclosingNode.ancestor<concept = Transition, +>.trigger.event.args; 
    } 
;
\end{lstlisting} 

\noindent 
Entering the reference happens by typing the name of the referenced element (cf.
the concept of smart references introduced above). In the case where there's a
\ic{LocalVariable} and a \ic{EventParameter} of the same name, the user has to
make an explicit decision, at the time of entry (the name won't bind, and the
code completion menu requires a choice). It is important to understand that,
although the names are similar, the tool still knows whether a particular
reference refers to a \ic{LocalVariable} or to an \ic{EventParameter}, because
the reference is encoded using the ID of the target\footnote{It may not,
however, be obvious to the user, so use this approach with caution and/or use
different syntax highlighting to distinguish the two. The real benefit of this
approach is that if two independent language extensions define such scopes
independently, there will not be any ambiguity if these extensions are used
together in a single program.}.

