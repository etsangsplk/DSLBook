\section{MPS Example}


With MPS two of these challenges outlined above --- composability of
concrete syntax and modular IDEs --- are solved to a large degree. Modular
type systems are reasonably well supported. Semantic interactions are hard to
solve in general, but can be handled reasonably in many relevant cases, as we
show in this section as well. However, as we will see, in many cases, languages
have to be designed \emph{explicitly for reuse}, in order to make them reusable.
After-the-fact reuse, without considering it during the design of the reusable
language, is possible only in limited cases. However, this is true for reuse in
software generally.

We describe \lmrc with MPS based on examples. At the center of this section is a
simple \ic{entities} language. We then build additional languages to illustrate
\lmrc. \fig{languagestructure} illustrates these additional languages. The
\ic{uispec} (user interface specification)  language illustrates
\emph{referencing} with \ic{entities}. \ic{relmapping} (relational database
mapping) is an example of \emph{reuse} with separated generated code. \ic{rbac}
(role-based access control) illustrates reuse with intermixed generated code.
\ic{uispec\_validation} demonstrates \emph{extension} (of the \ic{uispec} language)
and \emph{embedding} with regards to the expressions language.


\begin{figure}[htp]
\begin{center}
  \includegraphics[width=110mm]{figures-impl/9/a/languagestructure2.png}
  \caption[]{\icsn{entities} is the central language. \icsn{uispec} defines UI
  forms for the entities. \icsn{uispec\_validation} adds validation rules, and composes
  a reusable expressions language. \icsn{relmapping} provides a reusable database
  mapping language, \icsn{relmapping\_entities} adapts it to the entities language.
  \icsn{rbac} is a reusable language for specifying permissions; \icsn{rbac\_entities} adapts
  this language to the \icsn{entities} language. }
  \label{languagestructure}  
\end{center}
\end{figure}

\subsection{Implementing the Entities Language}
\label{entitiesLanguage}

At the center of the language extensions we will build later, we use a simple
\ic{entities} language. Below is an example model. \emph{Modules} are root
nodes. They live as top level elements in models\footnote{Referring back to the
terminology introduced in the DSL design section \todoref{}, root nodes (and
their descendants) are considered \emph{fragments}, while the models are partitions
(actually, they are XML files).}. 

\begin{lstlisting}[language=mpsmodex]
module company {          
  entity Employee {     
    id : int            
    name : string    
    role : string       
    worksAt : Department
    freelancer : boolean
  }                     
  entity Department {   
    id : int            
    description : string
  }   
}                  
\end{lstlisting}


\phead{Structure and Syntax} \fig{entities} shows a UML diagram of the structure
of the \ic{entities} language. Each box represents a language concept.

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=\columnwidth]{figures-impl/9/a/entities2.png}
  \caption[]{The abstract syntax of the entities language. Entities
  have attributes, those have types and names. \icsn{EntityType} extends 
  \icsn{Type} and references \icsn{Entity}. This "adapts" entities to types 
  (cf. the Adapter pattern).}
  \label{entities} 
\end{center}
\end{figure}

\noindent 
The following code shows the definition of the \ic{Entity} concept\footnote{This
is not the complete definition, concepts can have more characteristics. This is
simplified to show the essentials.}. \ic{Entity} implements the
\ic{INamedConcept} interface to inherit a \ic{name} property. It declares a list
of children of type \ic{Attribute} in the \ic{attributes} collection. 
\fig{editordefinition} shows the definition of the editor for \ic{Entity}.

 
\begin{lstlisting}[language=mps]
concept Entity extends BaseConcept implements INamedConcept        
  can be root: true
  children:                                     
    Attribute 	attributes 		0..n
\end{lstlisting}                                               


\begin{figure}[h]
\fbox{
\begin{minipage}{105mm}
  \includegraphics[scale=0.6]{figures-impl/9/a/editordefinition.png}
\end{minipage}
}
  \caption[]{The editor for \icsn{Entity}. The outermost cell is a
  vertical list. In the first line, we use a horizontal list that contains
  the "keyword" \icsn{entity}, the value of the \icsn{name} property and an opening
  curly brace. In the second line we use indentation and a vertical arrangements
  of the contents of the \icsn{attributes} collection. Finally, the third line
  contains the closing curly.}
  \label{editordefinition} 
\end{figure}

\phead{Type System} For the \ic{entities} language, we specify two simple typing
rules. The first one specifies that the type of the primitives (\ic{int},
\ic{string}) is a clone of themselves:

\begin{lstlisting}[language=mps]
rule typeof_Type applicable for concept = Type as type {
  do {                                 
    typeof(type) :==: type.copy;       
  }                                    
}                                      
\end{lstlisting}

\noindent 
The only other typing rule is an equation that defines the type of the attribute
as a whole to be the type of the attribute's \ic{type} property, defined as
\ic{typeof(attribute) :==: typeof(attribute.type);}.


\phead{Generator} From \ic{entities} models we generate Java Beans expressed in
MPS' \ic{BaseLanguage}. For the \ic{entities} language, we need a \emph{root
mapping rule} and \emph{reduction rules}. Root mapping rules can be used to
create new top level artifacts from existing top level artifacts (they map a
fragment to another fragment). In our case we generate a Java class from an
\ic{Entity}. Reduction rules are in-place transformations. Whenever the
transformation engine encounters an instance of the specified source concept
somewhere in a program tree, it replaces that source node with
the result of the associated template. In our case we have to reduce the various
types (\ic{int}, \ic{string}, etc.) to their Java counterparts. \fig{entitiesmc}
shows a part of the mapping configuration for the \ic{entities} language.


\begin{figure}[htp]
\fbox{
\begin{minipage}{105mm}
  \includegraphics[scale=0.55]{figures-impl/9/a/entitiesmc.png}
\end{minipage}
}
  \caption[]{The mapping configuration for the \icsn{entities} language. The
  root mapping rule for \icsn{Entity} specifies that instances of \icsn{Entity} should
  be transformed with the \icsn{map\_Entity} template. The reduction rules use
  inline templates. For example, the \icsn{IntType} is replaced with the Java
  \icsn{int} and the \icsn{EntityRefType} is reduced to a reference to the class
  generated from the target entity. The \icsn{->\$} is a reference macro. It 
  contains code (not shown) that "rewires" the reference to
  \icsn{Double} to a reference to the class generated from the referenced
  \icsn{Entity}.}
  \label{entitiesmc} 
\end{figure}

\noindent \fig{entitytemplate} shows the \ic{map\_Entity} template. It generates
a Java class --- notice the complete structure of a Java class is present,
because that is how BaseLanguage defines the editor for a Java class. We then
generate a field for each entity \ic{Attribute}. To do this we first create a
prototype field in the class (\ic{private int aField;}). Then we use macros to
"transform" this prototype into an instance for each \ic{Entity} attribute. We
first attach a \ic{LOOP} macro to the whole field. It contains an expression
\ic{node.attributes;} where \ic{node} refers to the input
\ic{Entity}\footnote{This code is entered in the Inspector window and is not
shown in the screenshot}. We then use a \ic{COPY\_SRC} macro to transform the
type. \ic{COPY\_SRC} copies the input node (the inspector specifies the current
attribute's type as the input here) and applies reduction rules. So instances of
the types defined as part of the \ic{entities} language are transformed into a
Java type using the reduction rules defined in the mapping configuration above.
Finally we use a property macro (the \ic{\$} sign) to change the \ic{name}
property of the field we generate from the dummy value \ic{aField} to the name
of the attribute we currently transform (once again via an expression in the
inspector).


\begin{figure}[htp]
\fbox{
\begin{minipage}{105mm}
  \includegraphics[scale=0.55]{figures-impl/9/a/entitytemplate.png}
\end{minipage}
}
  \caption[]{The template for creating a Java class from an \icsn{Entity}.
  The running text explains the details. The \icsn{<<placeholder>>} is a special
  concept used later.}
  \label{entitytemplate} 
\end{figure}




\subsection{Referencing}


\phead{Structure and Syntax} We define a language \ic{uispec} for defining user
interface forms based on the \ic{entities}. \fig{uispec} shows the abstract syntax
and below is an example model. Note how the form is another, separate fragment.
It is a \emph{dependent} fragment, since it references elements from another
fragment (expressed in the \ic{entities} language). Both fragments are
\emph{homogeneous} since they consist of sentences expressed in a single
language.

\begin{lstlisting}[language=mpsmodex]
form CompanyStructure                                                                                                                                  
  uses Department                                                                                                                                      
  uses Employee                                                                                                                                        
  field Name: textfield(30) -> Employee.name                                                                      
  field Role: combobox(Boss, TeamMember) -> Employee.role                                                                                              
  field Freelancer: checkbox -> Employee.freelancer
  field Office: textfield(20) -> Department.description                                                                                                
\end{lstlisting}

\begin{figure}[h]
\begin{center}
  \includegraphics[width=110mm]{figures-impl/9/a/uispec2.png}
  \caption[]{The abstract syntax of the \icsn{uispec} language. Dotted lines
  represent classes from another language (here: the \icsn{entities} language). A
  \icsn{Form} contains \icsn{EntityReference}s that connect to an \icsn{entities} model. A
  form also contains \icsn{Field}s, each referencing an \icsn{Attribute} from an
  \icsn{Entity} and containing a \icsn{Widget}.}
  \label{uispec} 
\end{center}
\end{figure}

\noindent 
The \ic{uispec} language extends\footnote{MPS uses the term "extension" whenever the
definition of one language uses or referes to concepts defined in another
language. This is not necessarily an example of language extension as defined in
this book.} the \ic{entities} language. This means, that concepts from the \ic{entities}
language can be used in the definition of language concepts in the \ic{uispec}
language. A \ic{Form} owns a number of \ic{EntityReferences}, which in turn
reference the \ic{Entity} concept. Also, \ic{Field}s refer to the \ic{Attribute}
that shall be edited via the field. Below is the definition of the \ic{Field}
concept. It owns a \ic{Widget} and refers to an \ic{Attribute}.

 
\begin{lstlisting}[language=mps]
concept Field extends BaseConcept implements <none>               
  properties:                                 
    label : string                              
  children:                                   
    Widget      widget      1      
  references:                                 
    Attribute   attribute   1
\end{lstlisting}                                                                                            


\phead{Type System} The language enforces  limitations regarding which widget
can be used with which attribute type (a \ic{checkbox} widget requires a Boolean
type, a \ic{ComboWidget} requires a \ic{string} type). The necessary typing rule
is defined in the \ic{uispec} language and references types from the \ic{entities} language.
The following is the code for the type check. 

\begin{lstlisting}[language=mps]
checking rule checkTypes {                                                                                                                                                                                                                                                                                                                        
  applicable for concept = Field as field                                                                                                                                                                                                                                                                                                                
  overrides false                                                                                                                                                                                                                                                                                                                                        
  do {                                                                                                                                                                                                                                                                                                                                                   
    if (field.widget.isInstanceOf(CheckBoxWidget) 
         && !(field.attribute.type.isInstanceOf(BooleanType))) { 
      error "only use checkbox with booleans" -> field.widget; 
    } 
    if (field.widget.isInstanceOf(ComboWidget) 
         && !(field.attribute.type.isInstanceOf(StringType))) { 
      error "cannot use combobox with strings" -> field.widget; 
    } 
  } 
}
\end{lstlisting}


\phead{Generation} The defining characteristic of language referencing is that
the two languages only \emph{reference} each other, and the instance fragments
are dependent, but \emph{homogeneous}. No syntactic integration is necessary in
this case. In this example, the generated code exhibits the same separation.
From the \ic{Form} definition, we generate a Java class that uses Java Swing to
build the UI form. It \emph{uses} the beans generated from the entities: the
classes are instantiated, and the setters are called (to get values from the
bean when the form is populated and to set the values into the bean if they have
been changed in the form). The generators are separate, but they are
\emph{dependent} because they share information.
Specifically, the \ic{uispec} generator knows about the names of the generated
entity classes, as well as the names of the setters and getters. This dependency
is implemented by defining a couple of behavior methods on the \ic{Attribute}
concept that are called from both generators (the colon represents the node cast
operator and binds tightly; the code below casts the attribute's parent to
\ic{Entity} and then accesses the \ic{name} property):


\begin{lstlisting}[language=mps]
concept behavior Attribute {                                                 
  public string qname() {                                                    
    this.parent : Entity.name + "." + this.name;                             
  }                                                                          
  public string setterName() {                                               
    "set" + this.name.toFirstUpper();
  }                                                                          
  public string getterName() {                                               
    "get" + this.name.toFirstUpper();
  }                                                                          
}                                                                            
\end{lstlisting}


\noindent 
The original \ic{entities} fragment is still \emph{sufficient} for the transformation
that generates the Java Bean. The \ic{uispec} fragment is not sufficient for
generating the UI, it needs the \ic{entities} fragment. This is not surprising since
\emph{dependent} fragments can never be sufficient for a transformation, the
transitive closure of all dependencies has to be made available.



\subsection{Extension}

We extend the MPS base language with block expressions and placeholders. These
concepts make writing generators \emph{that generate base language code} much
simpler. \fig{expressionBlock} shows an example. 

\begin{figure}[htp]
\fbox{
\begin{minipage}{105mm}
  \includegraphics[width=\columnwidth]{figures-impl/9/a/expressionBlock.png}
\end{minipage}
}
  \caption[]{block expressions (in blue) are basically anonymous
  inline methods. Upon transformation, a method is generated that contains the
  block content, and the block expression is replaced with a call to this
  method. Block expressions are used mostly when implementing generators; this
  screenshot shows a generator that uses a block expressions.}
  \label{expressionBlock} 
\end{figure}

\phead{Structure and Syntax} A block expression is a block that can be used
where an \ic{Expression} is expected\cite{BravenboerVVV05}. The block can
contain any number of statements; \ic{yield} can be used to "return" values from
within the block\sidenote[][10mm]{So, in some sense, a block expression is an
"inlined method", or a closure that is defined and called directly.}. An optional name property of
a block expression is used as the name of the generated method. The generator
of the block expression in \fig{expressionBlock} transforms it into this
structure:


\begin{lstlisting}[language=java]
// the argument to setName is what was the block expression,
// it is replaced by a method call to the generated method
aEmployee.setName(retrieve_name(aEmployee, widget0));
  
...
 
public String retrieve_name(Employee aEmployee, JComponent widget0) {
  String newValue = ((JTextField) widget0).getText();
  return newValue;
}
\end{lstlisting}




\noindent The \ic{jetbrains.mps.baselanguage.exprblocks} language extends MPS'
BaseLanguage. To make a block expression valid where BaseLanguage expects an
\ic{Expression}, \ic{BlockExpression} extends \ic{Expression}. Consequently,
fragments that use the \ic{exprblocks} language, can now use
\ic{BlockExpression}s in addition to the concepts provided by the BaseLanguage.
The fragments become \emph{heterogeneous}, because languages are
syntactically mixed.

\begin{lstlisting}[language=mps]
concept BlockExpression extends Expression implements INamedConcept
  children:                                     
    StatementList body 1      
\end{lstlisting}
          
          
\phead{Type System} The type of the \ic{yield} statement is the type of the
expression that is yielded, specified by 
\ic{typeof(yield) :==: typeof(yield.result);} (the type of \ic{yield 1;}
would be \ic{int}). Since the \ic{BlockExpression} is used as an \ic{Expression}, it
has to have a type as well. Since it is not explicitly specified, the type of
the \ic{BlockExpression} is the common super type of the types of the types
of all \ic{yield}s. The following typing rule computes this type. Note how we
use the \ic{:>=:} operator to express that the result type must be the same or a
supertype of the right argument.

\begin{lstlisting}[language=mps]
typevar resultType ; 
for (node<BlockExpressionYield> y : 
        blockExpr.descendants<concept = BlockExpressionYield>) { 
  resultType :>=: typeof(y.result); 
} 
typeof(blockExpr) :==: resultType;
\end{lstlisting}
          
          
\phead{Generator} The generator for \ic{BlockExpression}s reduces the new
concept to pure BaseLanguage: it performs assimilation. It transforms a
\emph{heterogeneous} fragment (using BaseLanguage and \ic{exprblocks}) to a \emph{homogeneous}
fragment (using only BaseLanguage). The first step is the creation of the
additional method for the block expression (\fig{expressionBlockGenerator1}).


\begin{figure}[h]
\fbox{
\begin{minipage}{105mm}
  \includegraphics[width=\columnwidth]{figures-impl/9/a/expressionBlockGenerator1.png}
\end{minipage}
}
  \caption[]{We use a weaving rule to create an additional method for
  this. A weaving rule processes an input element (\icsn{BlockExpression}) by creating
  another node in a different place. The context function defines this
  other place. In this case, it simply gets the class in which we have defined
  the block expression.} 
  \label{expressionBlockGenerator1} 
\end{figure}
 

\noindent The template shown in \fig{expressionBlockGenerator2} shows the
creation of the method. It assigns a mapping label to the created method. The mapping label
creates a mapping between the \ic{BlockExpression} and the created method. We
will use this label to refer to this generated method when we generate the
method call that replaces the \ic{BlockExpression}
(shown in \fig{expressionBlockGenerator3}).


\begin{figure}[htp]
\fbox{
\begin{minipage}{105mm}
  \includegraphics[scale=0.5]{figures-impl/9/a/expressionBlockGenerator2.png}
\end{minipage}
}
  \caption[]{The generator creates a method from the \icsn{BlockExpression}. It
  uses \icsn{COPY\_SRC} macros to replace the \icsn{string} type with the computed
  return type of the block expression, inserts a computed name, adds a parameter
  for each referenced variable outside the block, and inserts all the statements
  from the block expression into the body of the method (using the
  \icsn{COPY\_SRCL} macro that iterates over all of the statements in the
  \icsn{ExpressionBlock}). The \icsn{blockExprToMethod} mapping label is used later in the method call.}
  \label{expressionBlockGenerator2} 
\end{figure}



\noindent A second concept introduced by the \ic{exprblocks} language is the
\ic{Place- holderStatement}. It extends \ic{Statement} so it can be used inside
method bodies. It also has a name. It is used to mark locations at which
subsequent generators can add additional code. These subsequent generators will
use a reduction rule to replace the placeholder with whatever they want to put
at this location. It is a means of building extensible generators.

\begin{figure}[h]
\fbox{
\begin{minipage}{105mm}
  \includegraphics[scale=0.6]{figures-impl/9/a/expressionBlockGenerator3.png}
\end{minipage}
}
  \caption[]{Here we generate the call to the previously generated
  method. We use the mapping label \icsn{blockExprToMethod} (not shown; happens
  inside the \icsn{->\$} macro) to refer to the correct method. We pass in the
  environment variables as actual arguments.}
  \label{expressionBlockGenerator3} 
\end{figure}


Both, \ic{BlockExpression} and \ic{PlaceholderStatement} will be used in
subsequent examples of \lmrc.



A particularly interesting feature of MPS is the ability to use several
extensions of the same base language in a given program \emph{without defining a
combining language}. For example, a user could decide to use the block
expression language defined above together with the \ic{dispatch} extension
discussed in \sect{mpsinterpreter}. This is a consequence of MPS' projectional
nature\footnote{These same benefits are also exploited in case of embedding 
multiple independent languages.}. Let us consider the potential cases for 
ambiguity\footnote{The cases discussed here all are related to thesyntax and the editor. There are also conflicts that can arise fromincompatible semantics in terms of the transformation or the type system.}:

\begin{description}
  \item[Same Concept Name:] The used languages may define concepts with the same
  name as the host language. This will not lead to ambiguity because concepts
  have a unqiue ID  as well. A program element will use this ID to refer to the
  concept whose instance it represents.
  \item[Same Concrete Syntax:] The projected representation of a concept is not
  relevant to the functioning of the editor. The program would still be
  unambiguous to MPS even if \emph{all elements had the same notation}. Of
  course it would be confusing to the users.
  \item[Same Alias:] If two concepts that are valid at the same location use the
  same alias, then, as the user types the alias, it is not clear which of the
  two concepts should be instantiated. This problem is solved by MPS opening the
  code completion window and requiring the user to explicitly select which
  alternative to choose. Once the user has made the decision, the unique ID is
  used to create an unambiguous program tree. 
\end{description}





\subsection{Reuse with Separated Generated Code}

Language reuse covers the case where a language that has been developed
independent of the context in which it should be reused. The respective
fragments remain \emph{homogeneous}. In this chapter, we cover two alternative
cases: the first case (in this subsection) addresses a persistence mapping
language. The generated code is separate of the code generated from the entities
language. The second case (discussed in the next subsection) described a
language for role-based access control. The generated code has to be "woven
into" the \ic{entities} code to check permissions when setters are called.


\phead{Structure and Syntax} \ic{relmapping} is a reusable language for mapping
arbitrary data to relational tables. The \ic{relmapping} language supports the
definition of relational table structures, but leaves the actual mapping to the
source data unspecified. As you adapt the language to a specific reuse context,
you have to specify this mapping. The following code shows the reusable part: a
database is defined that contains tables with columns. Columns have
(database-specific) data types.

\begin{lstlisting}[language=mpsmodex]
database CompanyDB                          
  table Departments                         
    number id           
    char descr    
  table People                              
    number id                
    char name              
    char role              
    char isFreelancer
\end{lstlisting}

\noindent 
\fig{relmapping} shows the structure of the relmapping language. The abstract
concept \ic{ColumnMapper} serves as a hook: if we reuse this language
in a different context, we extend this hook by context-specific code. 

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=\columnwidth]{figures-impl/9/a/relmapping2.png}
  \caption[]{A \icsn{Database} contains \icsn{Tables} which contain
  \icsn{Columns}. A column has a name and a type. A column also has a
  \icsn{ColumnMapper}. This is an abstract concept that determines where the
  column gets its data from. It is a hook intended to be specialized in
  sublanguages that are context-specific.}
  \label{relmapping} 
\end{center}
\end{figure}

 
\noindent The \ic{relmapping\_entities} language extends \ic{relmapping} and
adapts it for reuse with the \ic{entities} language\footnote{Such a language
could be called an Adapter language in reference to the Adapter pattern from the
GoF book.}. To this end, it provides a subconcept of \ic{ColumnMapper}, the
\ic{AttributeColMapper}, which references an \ic{Attribute} from the
\ic{entities} language as a means of expressing the mapping from the attribute
to the column. The column mapper is projected on the right of the field
definition, resulting in the following (heterogeneous) code
fragment\footnote{This "mixed syntax" is pretty trivial since the
\icsn{AttributeColMapper} just references an attribute with a qualified name
(\icsn{Entity.attribute}). However, arbitrary additional syntax could be added,
and we could use arbitrary concepts from the \icsn{entities} language mixed into
the \icsn{relmapping} fragment.}:


\begin{lstlisting}[language=mpsmodex]
database CompanyDB                          
  table Departments                         
    number id <- Department.id              
    char descr <- Department.description    
  table People                              
    number id <- Employee.id                
    char name <- Employee.name              
    char role <- Employee.role              
    char isFreelancer <- Employee.freelancer
\end{lstlisting}


\phead{Type System} The type of a column is the type of its \ic{type} property.
In addition, the type of the column must also conform to the type of the column
mapper, so the concrete \ic{ColumnMapper} subtype must provide a type mapping as
well. This "typing hook" is implemented as an abstract behavior method
\ic{typeMappedToDB} on the \ic{ColumnMapper}. It is acceptable from a dependency
perspective to have this typing hook, since \ic{relmapping} is designed to be
reusable. With this in mind, the typing rules of the \ic{relmapping}
language look as follows:


\begin{lstlisting}[language=mps]
typeof(column) :==: typeof(column.type);
typeof(column.type) :==: typeof(column.mapper);
typeof(columnMapper) :==: columnMapper.typeMappedToDB();
\end{lstlisting}

\noindent 
The \ic{AttributeColMapping} concept from the \ic{relmapping\_entities} implements
this method by mapping \ic{int}s to \ic{number}s, and everything else to \ic{char}s.

\begin{lstlisting}[language=mps]
public node<> typeMappedToDB() overrides ColumnMapper.typeMappedToDB {                                                                          
  node<> attrType = this.attribute.type.type; 
  if (attrType.isInstanceOf(IntType)) { return new node<NumberType>(); } 
  return new node<CharType>();
}                                                                                                                                                  
\end{lstlisting}


\phead{Generator} The generated code is also separated into a reusable part (a
class generated by the generator of the \ic{relmapping} language) and a
context-specific subclass of that class, generated by the \ic{relmapping\_entities}
language. The generic base class contains code for creating the tables and for
storing data in those tables. It contains abstract methods that are used to
access the data to be stored in the columns. So the dependency structure of the
generated fragments, as well as the depdendencies of the respective generators,
resembles the dependency structure of the languages: the generated fragments
are dependent, and the generators are dependent as well (they share the name,
and implicitly, the knowledge about the structure of the class generated by the
reusable relmapping generator). A \ic{relmapping} fragment (without the 
concrete column mappers) is sufficient for generating the generic base
class.


\begin{lstlisting}[language=java]
public abstract class CompanyDBBaseAdapter {

  private void createTableDepartments() {
    // SQL to create the Departments table
  }

  private void createTablePeople() {
    // SQL to create the People table
  }

  public void storeDepartments(Object applicationData) {
    Insert i = new Insert("Departments");
    i.add( "id", getValueForDepartments_id(applicationData));
    i.add( "descr", getValueForDepartments_descr(applicationData));
    i.execute();
  }

  public void storePeople(Object applicationData) {
    // like above
  }

  public abstract String getValueForDepartments_id(Object applicationData);

  public abstract String getValueForDepartments_descr(Object applicationData);

  // abstract getValue methods for the People table
}
\end{lstlisting}

\noindent The subclass, generated by the generator in the
\ic{relmapping\_entities} language implements the abstract methods defined by
the generic superclass. The interface, represented by the \ic{applicationData}
object, has to be kept generic so any kind of user data can be passed in. 


\begin{lstlisting}[language=java]
public class CompanyDBAdapter extends CompanyDBBaseAdapter {
  public String getValueForDepartments_id(Object applicationData) {
    Object[] arr = (Object[]) applicationData;
    Department o = (Department) arr[0];
    String val = o.getId() + "";
    return val;
  }
  public String getValueForDepartments_descr(Object applicationData) {
    Object[] arr = (Object[]) applicationData;
    Department o = (Department) arr[0];
    String val = o.getDescription() + "";
    return val;
  }
}
\end{lstlisting}
 
 
Note how this class references the Beans generated from the \ic{entities}. So
the generator for \ic{entities} and the generator for \ic{relmapping\_entities}
are dependent, the information shared between the two generator is the names of
the classes generated from the entities. The code generated from the
\ic{relmapping} language is \emph{designed} to be extended by code generated
from a sublanguage (the abstract \ic{getValue} methods). This is acceptable,
since the \ic{relmapping} language itself is designed to be extended to adapt it
to a new reuse context.


\subsection{Reuse with Interwoven generated code}

\phead{Structure and Syntax} \ic{rbac} is a language for specifying role-based
access control, to specify access permissions for entities defined with the
\ic{entities} language. Here is some example code:

\begin{lstlisting}[language=mpsmodex]
RBAC                           
                               
users:                         
  user mv : Markus Voelter     
  user ag : Andreas Graf       
  user ke : Kurt Ebert         
                               
roles:                         
  role admin : ke              
  role consulting : ag, mv     
                               
permissions:                   
  admin, W : Department        
  consulting, R : Employee.name
\end{lstlisting}

\noindent 
The structure is shown in \fig{rbac}. Like \ic{relmapping}, it provides a
hook, in this case, \ic{Resource}, to adapt it to context languages: the
sublanguage \ic{rbac\_entities} provides two subconcepts of \ic{Resource}, namely
\ic{AttributeResource} to reference to an attribute, and \ic{EntityResource} to
refer to an \ic{Entity}, to define permissions for entities and their
attributes.
 

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=9cm]{figures-impl/9/a/rbac2.png}
  \caption[]{Language structure of the \icsn{rbac} language. An \icsn{RBACSpec}
  contains \icsn{Users}, \icsn{Roles} and \icsn{Permissions}. Users can be members 
  in several roles. A permission assigns a right to a \icsn{Resource}.}
  \label{rbac}  
\end{center}
\end{figure}



\phead{Type System} No type system rules apply here.

\phead{Generator} What distinguishes this case from the \ic{relmapping} case is
that the code generated from the \ic{rbac\_entities} language is \emph{not}
separated from the code generated from \ic{entities}. Instead, inside the setters
of the Java beans, a permission check is required.


\begin{lstlisting}[language=java]
public void setName(String newValue) {
  // check permissions (from rbac_entities) 
  if (!new RbacSpecEntities().currentUserHasWritePermission("Employee.name")) { 
    throw new RuntimeException("no permission");
  }
  this.name = newValue;
}
\end{lstlisting}

\noindent 
The generated fragment is homogeneous (it is all Java code), but it is
\emph{multi-sourced}, since several generators contribute to the same fragment.
To implement this, several approaches are possible:


\begin{itemize}
  \item We could use AspectJ (\footnote{http://www.eclipse.org/aspectj/}). This
  way, we could generate separate Java artifacts (all single-sourced) and then use the aspect weaver to "mix" them.
  However, we don't want to introduce the complexity of yet another tool,
  AspectJ, here, so we will not use this approach. 
  \item An interceptor
  (\footnote{http://en.wikipedia.org/wiki/Interceptor\_pattern}) framework could
  be added to the generated Java Beans, with the generated code contributing specific interceptors (effectively building a custom AOP solution). 
  We will not use this approach either, since it would require the addition of a 
  whole interceptor framework to the \ic{entities}. This seems like overkill.
  \item We could "inject" additional code generation templates to the existing
  \ic{entities} generator from the \ic{rbac\_entities} generator. This would make the
  generators \emph{woven} as opposed to just dependent. Assuming this would work
  in MPS, this would be the most elegant solution. But it does not.
  \item We could define a hook in the generated Java Beans code and then have
  the \ic{rbac\_entities} generator contribute code to this hook. This is the
  appraoch we will use. The generators remain dependent, they have to agree on
  the way the hook works.
\end{itemize}


\noindent Notice that only the AspectJ solution can work without any preplanning
from the perspective of the \ic{entities} language, because it avoids mixing the generated
code artifacts (it is handled "magically" by AspectJ). All other solutions
require the original \ic{entities} generator to "expect" certain extensions.

In our case, we have modified the original generator in the \ic{entities} language to
contain a \ic{PlaceholderStatement} (\fig{placeholder}). In every setter, the
placeholder acts as a hook at which subsequent generators can add statements.
So while we have to preplan \emph{that} we want to extend the generator in this
place, we don't have to predefine \emph{how}. 
% The placeholder contains a
% key into the session object that points to the currently processed attribute.
% This way, the subsequent generator can know from which attribute the method with
% the placeholder in it was generated.


\begin{figure}[htp] 
\fbox{
\begin{minipage}{105mm}
  \includegraphics[scale=0.55]{figures-impl/9/a/placeholder.png}
\end{minipage}
}
  \caption[]{This generator fragment creates a setter method for each
  attribute of an entity. The \icsn{LOOP} iterates over all attributes. The \icsn{\$} macro
  computes the name of the method, and the \icsn{COPY\_SRC} macro on the argument type
  computes the type. The placeholder is used to mark the location at which the 
  permission check will be inserted by a subsequent generator.}
  \label{placeholder}  
\end{figure}

\noindent 
The \ic{rbac\_entities} generator contains a reduction rule for
\ic{PlaceholderStatement}s. So when it encounters a placeholder (that has been
put there by the \ic{entities} generator) it removes it and inserts the code that
checks for the permission (\fig{placeholderreduction}). To make this work we
have to make sure that this generator runs \emph{after} the \ic{entities} generator
(since the \ic{entities} generator has to create the placeholder first) and
\emph{before} the BaseLanguage generator (which transforms BaseLanguage code into Java text
for compilation). We use generator priorities, i.e.~a partial ordering, to
achieve this.


\begin{figure}[h] 
\fbox{
\begin{minipage}{105mm}
  \includegraphics[width=\columnwidth]{figures-impl/9/a/placeholderreduction.png}
\end{minipage}
}
  \caption[]{This reduction rule replaces \icsn{PlaceholderStatement}s
  with a permission check. Using the condition, we only match those
  placeholders whose identifier is \icsn{pre-set} (notice how we have defined
  this identifier in \fig{placeholder}). The inserted code queries another
  generated class that contains the actual permission check. A runtime
  exception is thrown if the check fails.}
  \label{placeholderreduction}  
\end{figure}


\subsection{Embedding}

\phead{Structure and Syntax} \ic{uispec\_validation} extends \ic{uispec}, it is a
sublanguage of the \ic{uispec} language. It supports writing code such as
the following in the UI form specifications:


\begin{lstlisting}[language=mpsmodex, deletekeywords={role}]
form CompanyStructure                                                                                                                                  
  uses Department                                                                                                                                      
  uses Employee                                                                                                                                        
                                                                                                                                                       
  field Name: textfield(30) -> Employee.name validate lengthOf(Employee.name) < 30                                                                     
  field Role: combobox(Boss, TeamMember) -> Employee.role                                                                                              
  field Freelancer: checkbox -> Employee.freelancer 
        validate if (isSet(Employee.worksAt)) Employee.freelancer == false else
                    Employee.freelancer == true 
  field Office: textfield(20) -> Department.description                                                                                                
\end{lstlisting}

\noindent Writing the expressions is supported by embedding an
\ic{expressions} language. \fig{uival} shows the structure. To be able to use
the expressions, the user has to use a \ic{ValidatedField} instead of a \ic{Field}.
\ic{ValidatedField} is also defined in \ic{uispec\_validation} and is a
subconcept of \ic{Field}.

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=100mm]{figures-impl/9/a/uival2.png}
  \caption[]{The uispec\_validation language defines a subtype of
  \icsn{uispec.Field} that contains an \icsn{Expression} from an embeddable
  expression language. The language also defines a couple of additional expressions,
  specifically the \icsn{AttributeRefExpr}, which can be used to refer to
  attributes of entities.}
  \label{uival}  
\end{center}
\end{figure}

\noindent To support the migration of existing models that use \ic{Field}
instances, we provide an intention: the user can press \ic{Alt-Enter} on a
\ic{Field} and select \ic{Make Validated Field}. This transforms an existing
\ic{Field} into a \ic{ValidatedField}, so that validation expressions can be
entered\footnote{Alternatively it could be arranged (with 5 lines of code) that
users could simply type \icsn{validate} on the right of a field definition to
trigger the transformation code below.}. The core of the intention is the
following script, which performs the actual transformation:

\begin{lstlisting}[language=java, deletekeywords={label}]
execute(editorContext, node)->void { 
    node<ValidatedField> vf = new node<ValidatedField>(); 
    vf.widget = node.widget; 
    vf.attribute = node.attribute; 
    vf.label = node.label; 
    node.replace with(vf); 
}
\end{lstlisting}


\noindent The \ic{uispec\_validation} language extends the \ic{uispec} language.
We also extend the existing, embeddable \ic{expressions} language, so we can use
\ic{Expressions} in the definition of our language. \ic{ValidatedField} has a
property \ic{expr} that contains the validation expression. As a consequence of
polymorphism, we can use any existing subconcept of \ic{Expression} in
validations. So without doing anything else, we could write \ic{20 + 40 > 10},
since integer literals and the \ic{+} and \ic{>} operators are defined as part
of the composed \ic{expressions} language. However, to write anything useful, we have
to be able to reference entity attributes from within expressions\footnote{We
argued in the design part (\todoref{}) that, in order to make an embedded
language useful with its host language, it has to be extended: the following
expressions are examples of this.}. To achieve this, we create the
\ic{AttributeRefExpr} as shown in \fig{uival}. We also create \ic{LenghtOf} and
\ic{IsSetExpression} as further examples of how to adapt an embedded language to
its new context --- i.e.~the \ic{uispec} and \ic{entities} languages.


The \ic{AttributeRefExpr} references an \ic{Attribute} from the \ic{entities}
language; however, it may only reference those attributes of those entities that
are used in the form in which we define the validation expression.
The following is the code for the search scope:

\begin{lstlisting}[language=mps, morekeywords={join}]
(model, scope, referenceNode, linkTarget, enclosingNode)
                             ->join(ISearchScope | sequence<node< >>) { 
  nlist<Attribute> res = new nlist<Attribute>; 
  node<Form> form = enclosingNode.ancestor<concept = Form, +>; 
  for (node<EntityReference> er : form.usedEntities) { 
    res.addAll(er.entity.attributes); 
  } 
  res; 
}
\end{lstlisting}

\noindent Notice that the actual syntactic embedding of the \ic{expressions}
language in the \ic{uispec\_validation} language is no problem at all as a
consequence of how projectional editors work. We simply define \ic{Expression}
to be a child of the \ic{ValidatedField}.


\phead{Type System} The general challenge here is that primitive types such as
\ic{int} and \ic{string} are defined in the \ic{entities} language \emph{and} in the
embeddable \ic{expressions} language. Although they have the same names, they
are not the same types. So the two sets of types must be mapped. Here are a couple of
examples. The type of the \ic{IsSetExpression} is by definition
\ic{expressions.BooleanType}. The type of the \ic{LengthOf}, which takes an
\ic{AttrRefExpression} as its argument, is \ic{expressions.IntType}.
The type of an attribute reference is the type of the attribute's \ic{type} property, as in
\ic{typeof(are) :==: typeof(are.attr.type);}. However, consider now the
following code:

\begin{lstlisting}[language=mpsmodex]
field Freelancer: checkbox -> Employee.freelancer 
      validate if (isSet(Employee.worksAt)) Employee.freelancer == false else
                  Employee.freelancer == true 
\end{lstlisting}

\noindent This code states that if the \ic{worksAt} attribute of an employee is
set, then its \ic{freelancer} attribute must be \ic{false} else it must be
\ic{true} (freelancers dont \ic{workAt} anything). It uses the \ic{==} operator
from the \ic{expressions} language. However, that operator expects two
\ic{expressions.BooleanType} arguments, but the type of the
\ic{Employee.freelancer} is \ic{entities.BooleanType}\footnote{It is probably
a good idea to use the same set of primitive types (and expressions) for all
languages to avoid mappings like these. This could be achieved ba
requiring all languages to use a common base language (similar to Xbase). However, 
if the to-be-composed languages are developed by
independent people, then it is hard to enforce a common base language. So the 
ability to have such mappings is useful.}.
In effect, we have to override the typing rules for the expressions languages's \ic{==} operator. Here
is how we do it:

In the \ic{expressions} language, we define so-called overloaded operation
rules. We specify the resulting type for an \ic{EqualsExpression} depending on
its argument types. Here is the code in the \ic{expressions} language that defines
the resulting type to be \ic{boolean} if the two arguments are \ic{Equallable}:

\begin{lstlisting}[language=mps, morekeywords={type, left, right, concepts}]
operation concepts: EqualsExpression                                                     
  left operand type: new node<Equallable>() 
  right operand type: new node<Equallable>() 
operation type:                                                                          
  (operation, leftOperandType, rightOperandType)->node< > { 
    <boolean>; 
  }               
\end{lstlisting}

\noindent 
In addition to this code, we have to specify that \ic{expressions.BooleanType}
is a subtype of \ic{Equallable}, so this rule applies if we use equals with two 
\ic{expressions.BooleanType} arguments. We have to tie this overloaded operation
specification into a regular type inference rule.

\begin{lstlisting}[language=mps, morekeywords={type, concepts},
deletekeywords={concept}] 
rule typeof_BinaryExpression {                                                                                                                                                                                                                                                                                                                                                                                                                                                   
  applicable for BinaryExpression as binex                                                                                                                                                                                                                                                                                                                                                                                                                  
  do {                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
    node<> opType = operation type( binex , left , right ); 
      if (opType != null) { 
        typeof(binex) :==: opType; 
      } else { 
        error "operator " + binex.concept.name + 
              " cannot apply to these argument types " + 
              left.concept.name + "/" + right.concept.name 
           -> binex; } 
      }  
  } 
\end{lstlisting}

\noindent 
To override these typing rules to work with \ic{entities.BooleanType}, we simply
provider another overloaded operation specification in the \ic{uispec\_validation}
language:

\begin{lstlisting}[language=mps, morekeywords={type, concepts, one},
deletekeywords={concept}] 
operation concepts: EqualsExpression                                       
  one operand type: <boolean> // this is the entities.BooleanType!     
operation type:                                                            
  (op, leftOperandType, rightOperandType)->node< > { 
    <boolean>;  // this is the expressions.BooleanType 
  } 
\end{lstlisting}


\phead{Generator} The generator has to create BaseLanguage code, which is then
subsequently transformed into Java text. To deal with the transformation of the
expressions language, we can do one of two things:

\begin{itemize}
  \item Either we can use the \ic{expressions} language existing to-text generator
  and wrap the expressions in some kind of \ic{TextHolderStatement}\footnote{Remember
  that we cannot simply embed text in BaseLanguage, since that would not work
  structurally: no concept in BaseLanguage expects "text" as children. A wrapper
  is necessary.}.
  \item Alternatively, we can write a (reusable) transformation from expressions
  code to BaseLanguage code; these rules would get used as part of the
  transformation of \ic{uispec} and \ic{uispec\_validation} code to
  BaseLanguage.
\end{itemize}

\noindent Since many DSLs will likely transform code to BaseLanguage, it is
worth the effort to write a reusable generator from \ic{expressions} to
BaseLanguage\footnote{In fact, it would be useful if a simple language with
types and expression would already come with MPS. This language could either be
used as part of BaseLanguage as well (so no transformation would be needed) or
the transformation to BaseLanguage could ship with MPS as well.}. So we choose
this second alternative. The generated Java code is multi-sourced, since it is
generated by two independent code generators.


Expression constructs from the reusable \ic{expressions} language and those of
BaseLanguage are almost identical, so this generator is trivial. We create a new language
project \ic{de.voelter.mps.expressions.blgen} and add reduction
rules\sidenote[][-20mm]{In MPS, all "meta stuff" is called a language. So even
though \icsn{de.voelter.mps.expressions.blgen} only contains a generator (from
\icsn{expressions} to BaseLanguage) it is still a \emph{language} in MPS
terminology.}. \fig{expr2blgen} shows some of these reduction rules.


\begin{figure}[h]
\fbox{
\begin{minipage}{105mm}
  \includegraphics[width=\columnwidth]{figures-impl/9/a/expr2blgen.png}
\end{minipage}
}
  \caption[]{A number of reduction rules that map the reusable
  \icsn{expressions} language to BaseLanguage (Java). Since the languages are very
  similar, the mapping is trivial. For example, a \icsn{PlusExpression} is mapped
  to a \icsn{+} in Java, the \icsn{left} and \icsn{right} arguments are reduced recursively through
  the \icsn{COPY\_SRC} macro.}
  \label{expr2blgen}  
\end{figure}

\noindent In addition to these, we also need reduction rules for those new
expressions that we have added specifically in the \ic{uispec\_validation}
language (\ic{AttrRefExpression, isSetExpression, LengthOf}). Those
transformations are defined in \ic{uispec\_validation}, since this language is
\emph{not} reusable --- it is specifically designed to integrate the \ic{uispec}
and the \ic{expressions} languages. As an example, \fig{reductionAttributeRef}
shows the rule for handling the \ic{AttrRefExpression}. The validation code
itself is "injected" into the UI form via the same placeholder reduction as in
the case of the \ic{rbac\_entities} language.


\begin{figure}[h]
\fbox{
\begin{minipage}{105mm}
  \includegraphics[width=\columnwidth]{figures-impl/9/a/reductionAttributeRef.png}
\end{minipage}
}
  \caption[]{References to entity attributes are mapped to a call to
  their getter method. The tempalte fragment (inside the TF) uses two reference
  macros (->\$) to "rewire" the object reference to the Java bean instance, and
  the \icsn{toString} method call to a call to the getter.}
  \label{reductionAttributeRef}  
\end{figure}

\noindent 
Language extension can also be used to prohibit the use of certain concepts of
the base language in the sublanguage, at least in certain contexts. As a simple
(but admittedly relatively useless) example, we restrict the use of certain
operators provided by the reusable expression language inside validation rules
in \ic{uispec\_validation}. This can be achieved by implementing a 
\ic{can be ancestor} constraint on \ic{ValidatedField}.

\begin{lstlisting}[language=mps, morekeywords={ancestor},
deletekeywords={scope}] 
can be ancestor:
  (operationContext, scope, node, childConcept)->boolean { 
    return !(childConcept == concept/GreaterEqualsExpression/ || 
             childConcept == concept/LessEqualsExpression/); 
  }
\end{lstlisting}


\subsection{Annotations}

In a projectional editor, the CS of a program is projected from the AST. A
projectional system always goes from AS to CS, never from CS to AS (as parsers
do). This has the important consequence that the CS does not have to contain all
the data necessary to build the AST (which in case of parsers, is necessary).
This has two consequences:

\begin{itemize}
  \item A projection may be \emph{partial} in the sense that the AS contains
  data that is not shown in the CS. The information may, for example, only be
  changeable via intentions (discussed in \sect{Embedding}), or the projection
  rule may project some parts of the program only in some cases, controlled by some kind
  of configuration data.
  \item It is also possible to project \emph{additional} CS that is
  not part of the CS definition of the original language. Since the
  CS is never used as the information source, such additional
  syntax does not confuse the tool (in a parser-based tool the grammar would
  have to be changed to take into account this additional syntax to not derail
  the parser).
\end{itemize}

\noindent In this section we discuss the second alternative since it constitutes
a form of language composition: the additional CS is composed with the original
CS defined for the language. The mechanism MPS uses for this is called
annotations. We have seen annotations when we discussed templates: an annotation
is something that can be attached to arbitrary program elements and can be shown
together with CS of the annotated element. In this section we use
this approach to implement an alternative approach for the entity-to-database
mapping. Using this approach, we can store the mapping from entity attributes to
database columns directly in the \ic{Entity}, resulting in the following code:


\begin{lstlisting}[language=mpsmodex]
module company                                 
  entity Employee {                            
    id : int -> People.id                      
    name : string -> People.name               
    role : string -> People.role               
    worksAt : Department -> People.departmentID        
    freelancer : boolean -> People.isFreelancer
  }                                            
                                            
  entity Department {                          
    id : int -> Departments.id                 
    description : string -> Departments.descr  
  }                                            
\end{lstlisting}


\noindent This is a heterogeneous fragment, consisting of code from
\ic{entities}, as well as the annotations (e.g.,~\ic{-> People.id}). From a CS perspective, the column
mapping is "embedded" in the \ic{Entity}. In the AST the mapping information is
also actually stored in the \ic{entities} model. However, the definition of the
\ic{entities} language does not know that this additional information is stored
and projected "inside" entities. No modification to the \ic{entities} language
is necessary.

\phead{Structure and Syntax} We define an additional language 
\ic{relmapping\_annotations} which extends the \ic{entities}
language as well as the \ic{relmapping} language. In this language we define the
following concept:

\begin{lstlisting}[language=mps]
concept AttrToColMapping extends NodeAnnotation  
  references:                               
    Column column 1       
  properties: 
    role = colMapping
  concept links:
    annotated = Attribute
\end{lstlisting}                                            

\noindent \ic{AttrToColMapping} concept extends \ic{NodeAnnotation}, a concept
predefined by MPS. Concepts that extend \ic{NodeAnnotation} have to provide a
\ic{role} property and an \ic{annotated} concept link.
Structurally, an annotation is a child of the node it annotates. So the
\ic{Attribute} has a new child of type \ic{AttrToColMapping}, and the reference
that contains the child is called \ic{@colMapping} --- the value of the
\ic{role} property. The \ic{annotated} concept link points to the concept
\emph{to which this annotation can be added}. \ic{AttrToColMapping}s can be
annotated to instances of \ic{Attribute}.

While structurally the annotation is a child of the annotated node, in the
CS the relationship is reversed: The editor for \ic{AttrToColMapping} wraps
the editor for \ic{Attribute}, as \fig{annotationeditor} shows. Since the
annotation is not part of the original language, it must be attached to nodes
via an intention.

\begin{figure}[htp]
\fbox{
\begin{minipage}{105mm}
  \includegraphics[width=\columnwidth]{figures-impl/9/a/annotationeditor.png}
\end{minipage}
}
  \caption[labelInTOC]{The editor for the \icsn{AttrToColMapping} embeds the
  editor of the concept it is annotated to (using the \icsn{attributed node}
  cell). It then projects the reference to the referenced column. This way the
  editor of the annotation has control of if and how the editor annotated
  element is projected.}
  \label{annotationeditor}  
  \vspace{-4mm}
\end{figure}

\phead{Type System} The same typing rules are necessary as in the
\ic{relmapping\_ entities} language described previously. They reside in
\ic{relmapping\_anno-} \\ \ic{tations}.

\phead{Generator} The generator is also broadly similar to the previous example
with \ic{relmapping\_entities}. It takes the \ic{entities} model as the input, and then
uses the column mappings in the annotations to create the entity-to-database
mapping code.


\vspace{10pt}
The annotations introduced above were typed to be specific to certain target
concepts (\ic{EntityAttribute} in this case). A particularly interesting use of
of annotations includes those that can be annotated to \emph{any} language
concept (formally targetting \ic{BaseConcept}). In this case, there is no
dependency between the language that contains the annotation and the language
that is annotated. This is very useful for "meta data", as well as anything that
can be processed generically.

An example of the first case is traceability links (\fig{requirementstrace}).
This annotation can be annotated to any language concept and adds pointers
(trace links) to requirements. As a consequence of the projectional approach,
the program can be shown with or without the annotations, controlled by a global
switch.

\begin{figure*}[htp]
  \includegraphics[scale=0.50]{figures-impl/9/a/trace.png} 
  \caption[]{\textbf{Left:}
  Requirements traces (green) can be annotated to any arbitrary program element.
  The annotation is targetted to \icsn{BaseConcept}, which means there is no
  explicit dependency any specific language. \textbf{Right:} Traces can then be
  queried in the reverse direction to find which requirements are traced from
  implementation code.}
  \label{requirementstrace} 
\end{figure*}

\noindent An example of the second case is product line variability annotations.
Boolean expressions over configuration switches can be annotated to any model
element (the colorful annotations in the left part of \fig{projection}). Such an
annotation means that the respective element is only in the program variant, if
the boolean expression is true for the given setting of configuration switches.
The generic transformation simply removes all elements whose annotation
evaluates to false. The expressions can also be evaluated as part of the
projection, showing the code for a given variant (the right part of
\fig{projection} shows an example variant). The code is of course still
editable. Details on this approach can be found in \cite{Voelter2010} and
\cite{VoelterVisser2011}.

\begin{figure*}[h]
  \includegraphics[width=180mm]{figures-impl/9/a/projection.png}
  \caption[][-50mm]{\textbf{Left:} Feature dependency annotations are boolean
  expresssions over configuration switches that determine whether the annotated program
  element is part of a program variant. The expressions can be annotated to
  arbitrary program elements. \textbf{Right:} The transformation removes all those
  elements for which the annotation evaluates to \icsn{false}. This can also be
  done in the editor to support variant-specific editing of programs.}
  \label{featuredependencies}  
\end{figure*}



 

