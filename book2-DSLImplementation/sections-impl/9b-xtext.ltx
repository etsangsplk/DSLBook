\section{Xtext Example}
\label{xtextmodular}

\vspace{3mm}
\noindent This section of the book has been written together with Christian
Dietrich. Reach him via \verb#christian.dietrich@itemis.de#.
\vspace{3mm}

\todo{active annotations}
% ACTIVE ANNOTATIONS
% Active Annotations allow you to participate in the translation step from 
% Xtend to Java source code. ItÕs a bit like JavaÕs annotation processing but 
% much more flexible and less complicated to integrate at the same time. 
% You basically declare an annotation and implement a processing method, 
% where you define how to translate annotated Xtend code to Java. 
% I'll write a separate blog post on this.


In this section we look at an example roughly similar to the one for MPS
discussed in the previous section. We start out with a DSL for entities.  Here
is an example program:

\begin{lstlisting}[language=mpsmodex, deletekeywords={role}]
module company {
    entity Employee {
        id : int
        name : string
        role : string
        worksAt : Department
        freelancer : boolean
    }
    entity Department {
        id : int
        description : string
    }
}
\end{lstlisting}

\noindent 
The grammar is straight forward and should be clear if you have read the
implementation part so far.


\begin{lstlisting}[language=xtextgrammar, morekeywords={}, deletekeywords={}]
grammar org.xtext.example.lmrc.entity.EntityDsl 
        with org.eclipse.xtext.common.Terminals

generate entityDsl "http://www.xtext.org/example/lmrc/entity/EntityDsl"

Module:
    "module" name=ID "{"
        entities+=Entity*
    "}";

Entity:
    "entity" name=ID "{"
        attributes+=Attribute*
    "}";

Attribute:
    name=ID ":" type=AbstractType;

Named: Module|Entity|Attribute;

AbstractType:
    BooleanType|IntType|StringType|EntityReference;

BooleanType: {BooleanType} "boolean";

IntType: {IntType} "int";

StringType: {StringType} "string";

EntityReference: ref=[Entity|FQN];

FQN: ID ("." ID)*;
\end{lstlisting}


\subsection{Referencing}

Referencing describes the case where programs written in one DSL reference (by
name) program elements written in another DSL, both programs reside in different
fragments and no syntactic composition is required. The example we use is the UI
specification language where a \ic{Form} defined in the UI model refers to
\ic{Entities} from the language defined above, and \ic{Field}s in a form refers
to entity \ic{Attribute}. Here is some example code:

\begin{lstlisting}[language=mpsmodex, morekeywords={}, deletekeywords={}]
form CompanyStructure
  uses Department // reference to Department entity
  uses Employee   // reference to Employee entity

field Name: textfield(30)              -> Employee.worksAt
field Role: combobox(Boss, TeamMember) -> Employee.role
field Freelancer: checkbox             -> Employee.freelancer
field Office: textfield(20)            -> Department.description
\end{lstlisting}

\parhead{Structure} Referencing concepts defined in another language works by
importing the target meta model then defining references to concepts defined in
this meta model\footnote{Note that the references to entities and fields do not
technically reference into an entity source file. Instead, these references
refer to the EMF objects in the AST that has been parsed from the source file.
So, a similar approach can be used to reference to other \icsn{EObject}s. It does
not matter whether these are created via Xtext or not. This is reflected by the
fact that the grammar of the \icsn{uispec} language does not refer to the
\emph{grammar} of the \icsn{entity} language, but to the derived meta model.}.
Here is the header of the \ic{uispec} language:

\begin{lstlisting}[language=xtextgrammar, morekeywords={}, deletekeywords={}]
grammar org.xtext.example.lmrc.uispec.UispecDsl with org.eclipse.xtext.common.Terminals

import "http://www.xtext.org/example/lmrc/entity/EntityDsl" as entity

generate uispecDsl "http://www.xtext.org/example/lmrc/uispec/UispecDsl"
\end{lstlisting}

\noindent 
Importing a meta model means that the respective \emph{meta classes} can now be
used. Note that the meta model import does not make the \emph{grammar rules}
visilble, so the meta classes can only be used in references and as base types
(as we will see later). In case of referencing, we use them in references:

\begin{lstlisting}[language=xtextgrammar, morekeywords={}, deletekeywords={}]
EntityReference:
    "uses" entity=[entity::Entity|FQN];

Field:
    "field" label=ID ":" widget=Widget "->" attribute=[entity::Attribute|FQN];
\end{lstlisting}

\noindent To make this work, no change is required in the \ic{entities}
language\footnote{This is true as long as the referenced elements are in the
index. The index is used by Xtext to resolve references against elements that
reside in a different model file. By default, all elements that have a \icsn{name}
attribute are in the index. \icsn{Entity} and \icsn{Attribute} have names, so this
works automatically.}. However, the workflow generating the \ic{uispec} language
has to be changed. The \ic{genmodel} file for the meta model has to be
registered in the \ic{StandaloneSetup}\sidenote{This is necessary so that the
EMF code generator, when generating the meta classes for the \icsn{uispec}
language knows where the generated Java classes for the \icsn{entities} languages
reside. This is an EMF technicality and we won't discuss it in any more detail}.
\begin{lstlisting}
bean = StandaloneSetup {
    ...
    registerGenModelFile = "platform:/resource/org.xtext.example.lmrc.entity/
                src-gen/org/xtext/example/lmrc/entity/EntityDsl.genmodel"
}
\end{lstlisting}

\noindent 
We have to do one more customization to make the language work smoothly. The
only \ic{Attribute}s that should be visible are those from the entities
referenced in the current \ic{Form}'s \ic{uses} clauses, and they should be
referenced with a qualified name (\ic{Employee.role} instead of just \ic{role}).
Scoping has to be customized to achieve this:

\begin{lstlisting}[language=java, morekeywords={}, deletekeywords={}]
public IScope scope_Field_attribute(Field context, EReference ref) {
    Form form = EcoreUtil2.getContainerOfType(context, Form.class);
    List<Attribute> visibleAttributes = new ArrayList<Attribute>();
    for (EntityReference useClause : form.getUsedEntities()) {
        visibleAttributes.addAll(useClause.getEntity().getAttributes());
    }
    Function<Attribute, QualifiedName> nameComputation = new Function<Attribute, QualifiedName>() {
        @Override
        public QualifiedName apply(Attribute a) {
            return QualifiedName.create(((Entity)a.eContainer()).getName(), a.getName());
        }
    };
    return Scopes.scopeFor(visibleAttributes, nameComputation , IScope.NULLSCOPE);
}
\end{lstlisting}

\noindent This scoping function performs two tasks: first, it finds all the
\ic{Attribute}s of all \ic{used} entities. We collect them into a list
\ic{visibleAttributes}. The second part of the scoping function defines a
\ic{Function} object\sidenote{Note how we have to use the ugly function object
notation, because Java does not provide support for closures or lambdas at this
point! Alternatively you could do this with Xtend, which does support closures.}
that represents a function from \ic{Attribute} to \ic{QualifiedName}. In the
implementation method \ic{apply} we create a qualified name made from two parts:
the entity name and the attribute name (the dot between the two is default
behavior for the \ic{QualifiedName} class). When we create the scope itself in
the last line we pass in the list of attributes as well as the function object.
Xtext's scoping framework uses the function object to determine the name by
which each of the attributes is referencable from this particular context.

\parhead{Type System} As we have discussed in \sect{challenges},
dealing with type systems in the referencing case is not particularly
challenging, since the type system of the referencing language can be built with
knowledge of the type system of the referenced language. 

\parhead{Generators} The same is true for generators. Typically 
they just share knowledge about the naming of generated code elements.


\subsection{Reuse}

Referencing concerns the case where the referencing language is built with the
knowledge about the referenced language, so it can have direct dependencies. In
the example above, the \ic{uispec} language uses \ic{Entity}
and \ic{Attribute} from the \ic{entities} language. It directly imports the meta
model, so it has a direct dependency.

\parhead{Structure} In case of reuse, such a direct dependency is not allowed.
Our goal is to combine two \emph{independent} languages. To show this case, we
again use the same example as in the MPS section. We first introduce a \ic{db}
language. It is a trivial DSL for defining relational table structures. These
can optionally be mapped to a data source, but the language makes no assumption
about how this data source looks (and which language is used to define it).
Consequently, the grammar has no dependency on another other one, and imports no
other meta model:

\begin{lstlisting}[language=java, morekeywords={}, deletekeywords={}]
grammar org.xtext.example.lmrc.db.DbDsl with org.eclipse.xtext.common.Terminals
generate dbDsl "http://www.xtext.org/example/lmrc/db/DbDsl"

Root:
      Database;

Database:
    "database" name=ID
    tables+=Table*;
    
Table:
    "table" name=ID
    columns+=Column*    ;
    
Column:
    type=AbstractDataType name=ID (mapper=AbstractColumnMapper)?;

AbstractColumnMapper: {AbstractColumnMapper}"not mapped";

AbstractDataType: 
    CharType | NumberType;

CharType: {CharType}"char";

NumberType: {NumberType}"number";        
\end{lstlisting}

\noindent Just as in the MPS example, the \ic{Column} rule has an optional
\ic{mapper} property of type \ic{AbstractColumnMapper}. Since it is not possible
to explicitly mark rules as generating abstract meta classes, we simply define
the syntax to be \ic{not mapped}\footnote{Since the \icsn{mapper} property in
\icsn{Column} is optional, you don't ever have to type this.}. This language has
been designed \emph{for} reuse, because it has this hook
\ic{AbstractColumnMapper}, which can be customized later. But the language is
still independent. In the next step, we want to be able to reference
\ic{Attribute}s from the \ic{entities} language:

\begin{lstlisting}[language=mpsmodex, morekeywords={}, deletekeywords={role}]
database CompanyDB

table Departments
  number id          <- Department.id
  char descr         <- Department.description
  
table People
  number id          <- Employee.id
  char name          <- Employee.name
  char role          <- Employee.role
  char isFreelancer  <- Employee.freelancer
\end{lstlisting}

\noindent 
To make this possible, we create a new language \ic{db2entity} which \emph{extends} the
\ic{db} language and \emph{references} the \ic{entities}
language\footnote{Notice that we only extend \icsn{DbDsl}. The \icsn{entities}
meta model is just \emph{referenced}. This is because Xtext can only extend one base
grammar. For this reason we cannot embed language concepts from
the \icsn{entities} language in a \icsn{db2entity} program, we can only \emph{reference}
them.}. This is reflected by the header of the \ic{db2entity} language (notice
the \ic{with} clause):

\begin{lstlisting}[language=xtextgrammar, morekeywords={}, deletekeywords={}]
grammar org.xtext.example.lmrc.db2entity.Db2EntityDsl 
        with org.xtext.example.lmrc.db.DbDsl

import "http://www.xtext.org/example/lmrc/db/DbDsl" as db
import "http://www.xtext.org/example/lmrc/entity/EntityDsl" as entity

generate db2EntityDsl "http://www.xtext.org/example/lmrc/db2entity/Db2EntityDsl"
\end{lstlisting}

\noindent 
We now have to overwrite the \ic{AbstractColumnMapper} rule defined in the
\ic{db} language. 

\begin{lstlisting}[language=xtextgrammar, morekeywords={}, deletekeywords={}]
AbstractColumnMapper returns db::AbstractColumnMapper:
    {EntityColumnMapper} "<-" entity=[entity::Attribute|FQN];
\end{lstlisting}

\noindent 
We create a rule that has the same name as the rule in the super-grammar. So
when the new grammar calls the \ic{AbstractColumnMapper} rule, our new
definition is used. Inside, we define the new syntax we would like to use, and
as part of it, we reference an \ic{Attribute} from the imported \ic{entity} meta
model. We then use the \ic{\{EntityColumnMapper\}} action to force instantiation
of an \ic{EntityColumnMapper} object: this also implicitly leads to the creation
of an \ic{EntityColumnMapper} class in the generated \ic{db2entity} meta model.
Since our new rule \ic{returns} an \ic{db::AbstractColumnMapper}, this new meta
class extends \ic{AbstractColumnMapper} from the \ic{db} meta model -- which is
exactly what we want.

There are two more things we have to do to make it work. First, we have to
register the two \ic{genmodel} files in the \ic{db2entity}'s
\ic{StandaloneSetup} bean in the workflow file. Second, we have to address the
fact that in Xtext, the first rule in a grammar file is the entry rule for the
grammar, i.e.~the parser starts consuming a model file using this rule. In our
\ic{db2entity} grammar, the first rule is \ic{AbstractColumnMapper}, so this
won't work. We have to add the real root, which is simply the same one as in the
\ic{db} language:

\begin{lstlisting}[language=xtextgrammar, morekeywords={}, deletekeywords={}]
Root returns db::Root :
    Database;
\end{lstlisting}

\parhead{Type System} The primary task of the type system in this example would
be mapping the primitive types used in the \ic{entities} language to those used in
the \ic{db} language to make sure we only map those fields to a particular column
that are type-compatible. Just as the column mapper itself, this code lives in
the adapter language. It is essentially just a constraint that checks for type
compatibility.

\parhead{Generator} Let us assume there is a generator the generates Java Beans
from the \ic{entities}. Further, we assume that there is a generator that
generates all the persistence management code from \ic{DbDSL} programs, except
the part of the code that fetches the data from whatever the data source is -- essentially we
leave the same "hole" as we do with the \ic{AbstractColumnMapper} in the
grammar. And just in the same way as we define the \ic{EntityColumnMapper} in
the adapter language, we have to adapt the executing code. We can use two
strategies.

The first one uses the composition techniques of the target language, i.e.~Java.
The generated code of the \ic{DbDsl} could for example generate an abstract
class that has an abstract method \ic{getColumnData} for each of the table
columns. The generator for the adapter language would generate a concrete
subclass that implements these methods to grab the data from
entities\footnote{This is how we did it in the MPS example.}. This way the
modularity (\ic{entities}, \ic{db}, \ic{db2entity}) is propagated into the
generated artifacts as well. No \emph{generator} composition is
required\sidenote{In a Java/Enterprise world this would most likely be the way
we'd do it in practice. The next alternative is a bit constructed.}.

However, consider a situation where we'd have to generate inlined code, for
reasons of efficiency e.g.,~in some kind of embedded system. In this case the
\ic{DbDsl} generator would have to be built in an extensible way. Assuming we
use Xtend for generation, this can be done easily by using dependency
injection\sidenote[][-1\baselineskip]{Sometimes people complain about the fact
that Xtend is a general purpose language, and not some dedicated code generation
language. However, the fact that one can use abstract classes, abstract methods
and dependency injection is a nice example of how and why a general purpose
language (with some dedicated support for templating) is useful for building
generators.}. Here is how you would do that:

\begin{itemize}
  \item In the generator that generates persistence code from a \ic{DbDsl}
  program, the code that generates the inlined "get data for column" code
  delegates to a class that is dependency-injected\footnote{This is a nice
  illustration of building a generator that is \emph{intended to be extended} in
  some way.}. The Xtend class we delegate to would be an abstract class that has
  one abstract method \ic{generateGetDataCodeFor(Column c)}. 
  
\begin{lstlisting}[language=xtend, morekeywords={}, deletekeywords={}]
class GetDataGenerator {
    def void generateGetDataCodeFor(Column c)
}


class DbDslGenerator implements IGenerator {

    @Inject GetDataGenerator gdg

    def someGenerationMethod(Column c) {
        // ...
        String getDataCode = gdg.generateGetDataCodeFor(c)
        // then embed getDataCode somewhere in the 
        // template that generates the DbDsl code
    }
}
\end{lstlisting}  
  
  
  \item The generator for the adapter language would contain a subclass of this
  abstract class that implements the \ic{generateGetDataCodeFor} generator
  method in a way suitable to the \ic{entities} language.
  \item The adapter language would also set up Google Guice dependency injection
  in a way to use this a singleton instance of this subclass when instances of
  the abstract class are expected.
\end{itemize}


\subsection{Extension}

We have already seen the mechanics of extension in the previous example, since,
as a way of building the reuse infrastructure, we have extended the \ic{db}
language. In this section we look at extension in more detail. Extension is
defined as syntactic integration with explicit dependencies. However, as we had
discussed in \sect{lext} there are two use cases that feel different:

\begin{enumerate}
  \item In one case we provide (small scale) additional syntax to an otherwise
  unchanged language. The \ic{db2entity} language shown above is an example of
  this. The \ic{db2entity} programs look essentially like programs written in
  the \ic{db} base language, but in one (or few) particular places, something is
  different. In the example, the syntax for referencing attributes is such a
  small scale change.
  \item The other case is where we create a completely new language, but reuse
  some of the syntax provided by the base language. This use case \emph{feels}
  like embedding (we embed syntax from the base language in our new language),
  but in the classification according to syntactic integration and dependencies,
  it is still extension. Embedding would prevent explicit dependencies. In this
  section we look at extension with an embedding flavor.
\end{enumerate}

\noindent To illustrate extension-with-embedding-flavor, we will show how to
embed bBase expressions in a custom DSL. Xbase is a reusable expression language that ships
with Xtext\footnote{It is also the functional core of Xtend.}. It provides
primitive types, various unary and binary operators, functions and closures. As
we will see it is very tightly integrated with Java\sidenote{This is a mixed
blessing. As long as you stay in a JVM world (use Java types, generate Java
code), it means that many things are very simple. However, as soon as you go
outside of the JVM world, a lot of things become quite complex and it is
questionable whether using Xbase makes sense in this case at all.}. As an
example, we essentially create another entity language; thanks to Xbase, we will
be able to write:

\begin{lstlisting}[language=mpsmodex, morekeywords={}, deletekeywords={}]
entity Person {
    lastname : String 
    firstname : String 
    String fullName(String from) {
        return "Hello " + firstname + " "  + lastname + " from " + from
    }
}
\end{lstlisting}

\noindent Below is the essential part of the grammar. Note how it extends the
Xbase grammar (the \ic{with} clause) and how it uses various elements from Xbase
throughout the code (those whose names start with an \ic{X}).

\begin{lstlisting}[language=xtextgrammar, morekeywords={}, deletekeywords={}]
grammar org.xtext.example.lmrc.entityexpr.EntityWithExprDsl 
        with org.eclipse.xtext.xbase.Xbase

generate entityWithExprDsl 
           "http://www.xtext.org/example/lmrc/entityexpr/EntityWithExprDsl"

Module:
    "module" name=ID "{"
        entities+=Entity*
    "}";

Entity:
    "entity" name=ID "{"
        attributes+=Attribute* operations+=Operation*
    "}";

Attribute:
    name=ID ":" type=JvmTypeReference;

Operation:
    type=JvmTypeReference name=ID "("  (parameters+=FullJvmFormalParameter
        (',' parameters+=FullJvmFormalParameter)*)? ")"
            body=XBlockExpression;
\end{lstlisting}

\noindent Let's look at some of the details. First, the \ic{type} properties of
the \ic{Attribute} and the \ic{Operation} are not defined by our grammar,
instead we use a \ic{JvmTypeReference}. This makes all Java types legal in this
place\footnote{Limiting this to the primitive types (or some other subset of the
JVM types) requires a scoping rule.}. We use an \ic{XBlockExpression} as the
body of \ic{Operation}, which essentially allows us to use the full Xbase
language inside the body of the \ic{Operation}. To make the \ic{parameters}
visible, we use the \ic{FullJvmFormalParameter} rule\footnote{Above we wrote
that Xbase is tightly integrated with the JVM and Java. The use of
\icsn{FullJvmFormalParameter} and \icsn{JvmTypeReference} is a sign of this.
However, the next piece of code makes this even clearer.}. The
\ic{JvmModelInferrer}, shown below, maps a model expressed with this language to
a structurally equivalent Java "model". By doing this, we get a number of
benefits "for free", including scoping, typing and a code generator. Let us look
at this crucial step in some detail.

\begin{lstlisting}[language=xtend, morekeywords={}, deletekeywords={}]
class EntityWithExprDslJvmModelInferrer extends AbstractModelInferrer {
    
    @Inject extension IQualifiedNameProvider
    @Inject extension JvmTypesBuilder
    
    def dispatch void infer(Entity entity, 
                            IAcceptor<JvmDeclaredType> acceptor, 
                            boolean isPrelinkingPhase) {
        ...    
    }
}    
\end{lstlisting}

\noindent This Xtend class extends \ic{AbstractModelInferrer} and implements its
\ic{infer} method to create structurally equivalent Java code as an EMF tree and
registers it with the \ic{acceptor}. The method is marked as \ic{dispatch}, so
it can be polymorphically overwritten for various language concepts. We override
it for the \ic{Entity} concept. We also have the \ic{IQualifiedNameProvider}
and \ic{JvmTypesBuilder} injected. The latter provides a builder API for
creating all kinds JVM objects, such as fields, setters, classes or operations.

\begin{lstlisting}[language=xtend, morekeywords={}, deletekeywords={}]
acceptor.accept(
    entity.toClass( entity.fullyQualifiedName ) [
        documentation = entity.documentation
        ...
    ]
)
\end{lstlisting}

\noindent At the top level, we map the \ic{Entity} to a \ic{Class}. \ic{toClass}
is one of the builder methods defined in the \ic{JvmTypesBuilder}. The class we
create should have the same name as the \ic{entity}; the name of the class is
passed into the constructor. The second argument, written conveniently behind
the parentheses, is a closure. Inside the closure, there is a variable \ic{it}
that refers to the target element (the class in this case). It is possible to
omit the \ic{it}, so when we write \ic{documentation = ...} this actually means
\ic{it.documentation = ...}. In other words, we set the documentation of the
created class to be the documentation of the \ic{entity}. Next we create a
field, a getter and a setter for each of the attributes of the \ic{Entity} andadd them to the \ic{Class}' \ic{members} collection:

\begin{lstlisting}[language=xtend, morekeywords={}, deletekeywords={}]
for ( attr : entity.attributes ) {
    members += attr.toField(attr.name, attr.type)
    members += attr.toGetter(attr.name, attr.type)
    members += attr.toSetter(attr.name, attr.type)
} 
\end{lstlisting}

\noindent 
\ic{toField}, \ic{toGetter} and \ic{toSetter} are all builders contributed by
the \ic{JvmTypesBuilder}. Let us better understand what they do. Here is the
implementation of \ic{toSetter}. Note that the first argument supplied by the
object in front of the dot, i.e.~the \ic{Attribute}. 

\begin{lstlisting}[language=java, morekeywords={}, deletekeywords={}]
public JvmOperation toSetter(EObject sourceElement, final String name, JvmTypeReference typeRef) {
    JvmOperation result = TypesFactory.eINSTANCE.createJvmOperation();
    result.setVisibility(JvmVisibility.PUBLIC);
    result.setSimpleName("set" + nullSaveName(Strings.toFirstUpper(name)));
    result.getParameters().add(toParameter(sourceElement, nullSaveName(name), cloneWithProxies(typeRef)));
    if (name != null) {
        setBody(result, new Functions.Function1<ImportManager, CharSequence>() {
            public CharSequence apply(ImportManager p) {
                return "this." + name + " = " + name + ";";
            }
        });
    }
    return associate(sourceElement, result);
}
\end{lstlisting}

\noindent 
The method first creates a \ic{JvmOperation} and sets the visibility and the
name. It then creates a parameter that uses the \ic{typeRef} passed in as the third
argument as its type. As you can see, all of this happens via model-to-model
transformation. This is important, because these created objects are used
implicitly in scoping and typing. The body, however, is created textually; it is
not needed for scoping or typing, it is used only in code generation. Since
that is a to-text transformation anyway, it is good enough to represent the body
of the setter as text already at this level. The last line is important: it
associates the source element (the \ic{Attribute} in our case) with the created
element (the setter \ic{Operation} we just created). As a consequence of
this association, the Xbase scoping and typing framework can work its magic of
providing support for our DSL without any further customization!

Let us now continue our look a the implementation of the \ic{JvmModelInferrer}
for the \ic{Entity}. The last step before our detour was that we created fields,
setters and getters for all attributes of our \ic{Entity}. We have to deal with
the operations of our \ic{Entity} next. 

\begin{lstlisting}[language=xtend, morekeywords={}, deletekeywords={}]
for ( op : entity.operations ) {
    members += op.toMethod(op.name, op.type) [
        for (p : op.parameters) {
            parameters += p.toParameter(p.name, p.parameterType)
        }
        body = op.body
    ]
}
\end{lstlisting}

\noindent 
This code should be easy to understand. We create a method for each operation
using the respective builder method, pass in the name and type, create a
parameter for each of the parameters of our source operation and then assign the
body of the created method to be the body of the operation in our DSL program.
The last step is particularly important. Notice that we don't clone the body, we
assign the object \emph{directly}. Looking into the \ic{setBody} method (the
assignment is actually mapped to a setter in Xtend), we see the following:

\begin{lstlisting}[language=java, morekeywords={}, deletekeywords={}]
public void setBody(JvmExecutable logicalContainer, XExpression expr) {
    if (expr == null)
        return;
    associator.associateLogicalContainer(expr, logicalContainer);
}
\end{lstlisting}

\noindent 
The \ic{associateLogicalContainer} method is what makes the automatic support
for scoping and typing happen:

\begin{itemize}
  \item because the operation is the container of the expression, the
  expression's type and the operation's type must be compatible
  \item because the expression(s) live inside the operation, the parameters of
  the operation, as well as the current class's fields, setters and getters are
  in scope automatically.
\end{itemize}

\noindent This approach of mapping a DSL to Java "code" via this model
transformation works nicely as long as it maps to Java code in a simple way. In the above case
of entities, the mapping is trivial and obvious. If the semantic gap becomes
bigger, the \ic{JvmTypeInferrer} becomes more complicated. However, what is
really nice is this: within the type inferrer, you can of course use Xtend's
template syntax to create implementation code. So it
is easy to mix model transformation (for those parts of a mapping that is relevant
to scoping and type calculation) and then use traditional to-text transformation
using Xtend's powerful template syntax for the detailed implementation aspects.


\parhead{Generator} The JVM mapping shown above already constitutes the full
semantic mapping to Java. We map entities to Java classes and fields to members
and getters/setters\sidenote{Notice how we did specify the implementation of the
getters and setters, although this would not strictly be necessary for the scoping and
typing support we get from the JVM mapping.}. So in fact, we do not have to do
anything else to get a generator, we can reuse the existing Xbase-to-Java code
generator. 

In case we build a language that cannot easily be mapped to a JVM model we can
still reuse the XBase expression compiler by injecting the
\ic{JvmModelGenerator} and then delegating to it at the respective granularity.

You can also change or extend the behavior of the default \ic{JvmModelGenerator}
by overriding its \ic{\_internalDoGenerate(EObject, IFileSystemAccess)} method
for your particular language concept\footnote{Notice that you also have to make
sure via Guice that your subclass is used, and not the \icsn{JvmModelGenerator}.}.

\parhead{Extending Xbase} In the above example we had embedded the (otherwise
unchanged) Xbase language into a simple DSL. Let us now look at how to extend
Xbase itself by adding new literals and new operators. We start by defining a
literal for dates:

\begin{lstlisting}[language=xtextgrammar, morekeywords={}, deletekeywords={}]
XDateLiteral:
    'date' ':' year=INT '-' month=INT '-' day=INT;
\end{lstlisting}

\noindent 
These new literals should be literals in terms of Xbase, so we have to make them
subtypes of \ic{XLiteral}. Notice how we override the \ic{XLiteral} rule defined
in Xbase. We have to repeat its original contents, there is no way to "add" to
the literals\footnote{Similarly, if you want to remove concepts you have to
overwrite the rule with the removed concept missing from the enumeration.}.

\begin{lstlisting}[language=xtextgrammar, morekeywords={}, deletekeywords={}]
XLiteral returns xbase::XExpression:
    XClosure |
    XBooleanLiteral |
    XIntLiteral |
    XNullLiteral |
    XStringLiteral |
    XTypeLiteral |
    XDateLiteral;
\end{lstlisting}

\noindent We use the same approach to add an additional operator represented
with \ic{===}:

\begin{lstlisting}[language=xtextgrammar, morekeywords={}, deletekeywords={}]
OpEquality:
    '==' | '!=' | '===';
\end{lstlisting}

\noindent 
Xtend supports operator overloading by mapping operators to methods that can be
overridden. The \ic{===} operator does not yet exist in Xtend, so we have to
specify the name of the method that should be called if the operator shows up
in a program. The second line of the \ic{initializeMapping}
method maps the new operator to a method named \ic{operator\_identity}:

\begin{lstlisting}[language=java, morekeywords={}, deletekeywords={}]
public class DomainModelOperatorMapping extends OperatorMapping {

    public static final QualifiedName IDENTITY = create("===");

     @Override
    protected void initializeMapping() {
        super.initializeMapping();
        map.put(IDENTITY, create("operator_identity"));
    }
}
\end{lstlisting}

\noindent 
We implement this method in a new class which we call
\ic{ObjectExtensions2}\footnote{The existing class \icsn{ObjectExtensions}
contains the implementations for the existing \icsn{==} and \icsn{!=} operators,
hence the name}\footnote{Through the \icsn{operator\_identity} operation, we have
expressed all the semantics: the Xbase generator will generate a call to that 
operation in the generated Java code. Alternatively, as a performanceimprovement, you could use the @Inline annotation to inline the function in thegenerated code.}:
\begin{lstlisting}[language=java, morekeywords={}, deletekeywords={}]
public class ObjectExtensions2 {
    public static boolean operator_identity(Object a, Object b) {
        return a == b;
    }
}
\end{lstlisting}

\noindent We also want to override the existing \ic{-} operator for the new date
literals to calculate the time between two dates. We don't have to specify the
mapping to a method name, since the mapping for \ic{-} is already defined in
Xbase. However, we have to provide an overloaded implementation of \ic{-} for
dates:

\begin{lstlisting}[language=java, morekeywords={}, deletekeywords={}]
public class DateExtensions {
    public static long operator_minus(Date a, Date b) {
        long resInMilliSeconds = a.getTime() - b.getTime();
        return millisecondsToDays( resInMilliSeconds );
        
    }
}
\end{lstlisting}

\noindent 
To make Xtend aware of these new classes, we have to register them. In order to
do so, we extend the \ic{ExtensionClassNameProvider}. It associates the classes
that contain the operator implementation methods with the types for which these
classes contain the applicable methods:

\begin{lstlisting}[language=java, morekeywords={}, deletekeywords={}]
public class DomainModelExtensionClassNameProvider extends ExtensionClassNameProvider {

    @Override
    protected Multimap<Class<?>, Class<?>> simpleComputeExtensionClasses() {
        Multimap<Class<?>, Class<?>> result = super.simpleComputeExtensionClasses(); 
        result.put(Object.class, ObjectExtensions2.class);
        result.put(Date.class, DateExtensions.class);
        return result;
    }
}
\end{lstlisting} 

\noindent 
We now have to extend the type system: it has to be able to derive the types for 
date literals. We create a type provider that extends the default
\ic{XbaseTypeProvider}\footnote{Don't forget to register this class with
Guice, just like all the other DSL-specific subclasses of framework classes.}:

\begin{lstlisting}[language=java, morekeywords={}, deletekeywords={}]
@Singleton
public class DomainModelTypeProvider extends XbaseTypeProvider {

    @Override
    protected JvmTypeReference type(XExpression expression, 
                     JvmTypeReference rawExpectation, boolean rawType) { 
        if (expression instanceof XDateLiteral) {
            return _type((XDateLiteral) expression, rawExpectation, rawType);
        }
        return super.type(expression, rawExpectation, rawType);
    }

    protected JvmTypeReference _type(XDateLiteral literal, 
                     JvmTypeReference rawExpectation, boolean rawType) { 
        return getTypeReferences().getTypeForName(Date.class, literal);
    }
}
\end{lstlisting}

\noindent 
We don't have to specify typing rules for the \ic{===} operator. Since we have
mapped it to the \ic{operator\_identity} operation, the type system uses the
types specified in this operation: the type of \ic{===} is
\ic{boolean}, and there are no restrictions on the two arguments; they are typed
as \ic{java.lang.Object}. If customizations were required these could be done by
overriding the \ic{\_expectedType} operation in \ic{XbaseTypeProvider}. 


Finally we have to extend the Xbase compiler so it can handle date literals:

\begin{lstlisting}[language=java, morekeywords={}, deletekeywords={}]
public class DomainModelCompiler extends XbaseCompiler {

    protected void _toJavaExpression(XDateLiteral expr, IAppendable b) {
        b.append("new java.text.SimpleDateFormat(\"yyyy-MM-dd\").parse(\"" +
              expr.getYear() + "-" + expr.getMonth() + "-" + 
              expr.getDay() + "\")"); 
    }

}
\end{lstlisting} 

\parhead{Active Annotations} Java annotations are markers you can attach to
various program elements such as classes, fields, methods or arguments. For
example, the \ic{@Override} annotation declares that a method overrides a
similar method in the super class. Another example is \ic{@NotNull} on an
argument, which expresses that that argument may not be \ic{null}. Annotations
may also capture metadata: the \ic{@Author(name = .., date = ..)} annotation
expresses who wrote a class. Annotations may be standardized (e.g.
\ic{@Override}) or may be implemented by users. In the standard case the
annotations are typically processed by the compiler (e.g., checking that there
actually is a method with the same signature in the superclass or modifying the
generated bytecode to report an error if a \ic{NotNull} argument is \ic{null}
at runtime). Custom annotations are processed in some way by some external tool
(e.g. by checking certain properties of the code or by modifying the class 
bytecode via some bytecode processor).

Xtext's Xtend language comes with so-called Active Annotations\footnote{This
feature is actually introduced in version 2.4; at the time of this writing, only
prototypes are available, so some details about what I describe here may be
different in the final release. This is also why we don't show source code
here.}. They use the same syntax as regular annotations\footnote{Of course this
limits the kinds of language extensions that can be built. However, some quite
interesting language extensions can be built nontheless.}. However, they can
influence the translation process from Xtend to Java. Each annotation is
essentially associated with a model-to-model transformation that creates the
necessary Java code. This way, the execution semantics of the respective Xtend
class can be influenced.

At the time of this writing, the most impressive active annotation (prototype) I
have seen involves GWT programming\footnote{It has been built by Sven
Efftinge and Oliver Zeigermann. The slides that describe the system are here:
\icsn{http://slidesha.re/Shb3SO}. The code is here:
\icsn{http://bit.ly/Y7eTi6}}. They implement the following two annotations:

\begin{description}
  \item[Services] From a simple Xtend class that contains the server-side
  implementation methods, the annotation generates the necessary remote
  interface and the other boilerplate that enables the remote communication
  infrastructure.
  \item[UI Forms] In GWT, a UI form is defined by an XML file that defines the
  structure as well as by a Java class that implements the behavior. The
  behavior includes the event handlers for the UI elements defined in the XML
  file. To this end, the class has to have fields that correspond (in name and
  type) to the UI elements defined in the XML. By using an annotation, this
  duplication can be avoided: the annotation implementation inspects the
  associated XML and automatically introduces the necessary fields.
\end{description}

Active annotations will provide a number of additional nifty features. First,
they can also implement custom validations and quick fixes for the IDE. Second,
they can change the scope and the type system\footnote{The transformation
defined by the active annotation that maps the annotated Xtend construct to
Java code is actually run not just during code generation, but also during
editing (like any other JVM model inferrer). Since scoping and the type system
of Xtend is based on the inferred JVM model, the annotation transformation can
affect these as well.}. Third, you can pass JVM types or expressions as
arguments to an expression as in

\begin{lstlisting}[language=xtend]
@Pre( b != 0 ) def divide(int a, int b) {
   return a / b
}
\end{lstlisting}

\noindent It can be defined whether the expression is passed in as an AST (\ic{b
!= 0}) or whether the result of the evaluation of the expression is passed in
(\ic{true} or \ic{false}).

\subsection{Embedding}

Embedding is not supported by Xtext. The reason is that, as we can see from
\sect{lemb}, the adapter language would have to inherit from \emph{two} base
languages. However, Xtext only supports extending one base grammar.

We have shown above how to embed Xbase expressions into a custom DSL. However,as
we have discussed, this is an example of extension with embedding flavor: we
create \emph{a new} DSL into which we embed the existing Xbase expressions. So
we only have to extend from \emph{one} base language -- Xbase. An example of
embedding would be to take an existing, independent SQL language and embed it
into the Entity DSL created above. This is not possible.
