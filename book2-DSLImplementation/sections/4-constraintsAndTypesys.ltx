\chapter{Constraints}

Constraints are boolean conditions that have to evaluate to \ic{true} in order for
the model to be correct ("does \ic{expr} hold?"). An error message that is reported
if the expression evaluates to false ("\ic{expr} does not hold!"). They are
typically associated with language concepts ("for each instances of \ic{x},
\ic{expr-with-x} must hold"). Constraints address model correctness beyond syntax and
scoping/linking, but short of actual execution semantics. Typical examples for constraints are:

\begin{itemize}
  \item uniqueness of names in lists of elements (e.g. functions in a
  namespace);
  \item every non-start state of a state machine has at least one incoming
  transition;
  \item a variable is defined before it is used (statement ordering);
  \item the assignee is type-compatible with the right hand side expression.
\end{itemize}

The last item is an example of a type system rule: these verify the correctness
of types in programs, e.g. making sure you don't assign a \ic{float} to an
\ic{int}. Particularly in expression languages, type calculations and checking
can become quite complicated and therefore warrants special support. This is
why we distinguish between simple constraints (covered in this chapter)  and
type systems (which we cover in the next chapter). 

Constraints can be implemented with any language that is able to query a model
and report errors to the user. To make constraint checking efficient, it is
useful if the language has the following characteristics:

\begin{itemize}
  \item It should be able to effectively navigate and filter the model. Support
  for path expressions (as in \ic{aClass.operations.arguments.type} as a way to
  find out the types of all arguments of all operations in a class) is extremely
  useful.
  \item Support for higher-order functions is useful so one can write
  generic algorithms and traversal strategies
  \item A good collection language, often making use of higher-order functions,
  is very useful, so it is easily possible to filter collections, create
  subsets or get the set of distinct values in a list.
  \item Finally, it is helpful to be able to associate a constraint
  declaratively with the language concept for whose instances it should be
  executed
\end{itemize}

Here is an example constraint written in a pseudo-language:

\begin{code}
constraint for: 
  Class
expression: 
  this.operations.arguments.type.filter(ComplexNumber).isNotEmpty &&
  !this.imports.any(i|i.name == "ComplexNumberSupportLib")
message: 
  "class "+this.name+" uses complex numbers, so the ComplexNumberSupportLib must
  be imported"
\end{code}

Some kinds of constraints require specialized data structures to be built or
maintained in sync with the program. A good examples is read access to an
uninitialized variable. To be able to find these kinds of errors statically, a
dataflow graph has to be constructed from the program. A dataflow graph models
the various exectution paths through a (part of a) program and performs analyses
on it. Once a dataflow graph is constructed, it can be checked whether there
exists a path from program start to a variable read without coming across a
write to the same variable. 

\todo{Will we cover this somewhere?}

\todo{Discuss diff approaches for checking constraints, and what are
good languages for that?}



\section{Constraints in Xtext}

Just like scopes, constraints are implemented in Java \todo{still true? Can
Xtend be used?}. Developers fill write methods into a validator
class generated by the Xtext project creation wizard. In the end, these
validations plug into the EMF validation framework. Other EMF\ic{ EValidator}
implementations can be used in Xtext as well.

A check method is a Java method with the following characteristics: it is
public, returns nothing, it can have any name, it has a single argument of the
type for which the check should apply, and it has the \ic{@Check} annotation. 
For example, the following method is a check that is invoked for all instances
of \ic{CustomState} (i.e. not for start states and background states):
	

\begin{code}
@Check(CheckType.NORMAL)
public void checkOrphanEndState( CustomState ctx ) {
    CoolingProgram coopro = Utils.ancestor(ctx, CoolingProgram.class);
    TreeIterator<EObject> all = coopro.eAllContents();
    while ( all.hasNext() ) {
        EObject s = all.next();
        if ( s instanceof ChangeStateStatement ) {
            ChangeStateStatement css = (ChangeStateStatement) s;
            if ( css.getTargetState() == ctx ) return;
        }
    }
    error("no transition ever leads into this state", 
    	CoolingLanguagePackage.eINSTANCE.getState_Name());
}
\end{code}


The method retrieves the cooling program that owns a state, then retrieves all
of its descendants and iterates over them. If the descendant is a \ic{ChangeStateStatement},
and if the \ic{targetState} property of the \ic{ChangeStateStatement} references
the current state, then we return: we have found a transition leading into the current
state. If we don't find one of these, we report an error. The \ic{CheckType.NORMAL}
in the annotation defines when this check should run:

\begin{itemize}
  \item CheckType.NORMAL: run when the file is saved 
  \item CheckType.FAST: run after each model change (i.e. after each keypress) 
  \item CheckType.EXPENSIVE: run only if requested via the context menu
\end{itemize}
 
% The amount of code that needs to be written for constraint checks depends a lot
% on the language used to express the constraints. Just like scoping, constraints
% basically navigate and query the model. The more efficiently a language is able
% to do that, the more suitable it is. Java is not very suitable, because it lacks
% higher order functions and chain expressions. Subsequent versions of the Xtext
% validation API are expected to be based on Xtend2, a language that has these
% features. We'll discuss it in the section on code generation and transformation.


\section{Constraints in MPS}

\todo{MPS dataflow}

MPS' approach to constraints is very similar to Xtext's. The main difference is
that the constraint is written in \ic{BaseLanguage}, which is an extended version of
Java that has some of the features that makes constraints more concise. Here is
the code for the same "state unreachable" constraint, which we can make use of
in the state machines extension to C:

\begin{code}
checking rule stateUnreachable {                                                                                                                                                                         
  applicable for concept = State as state                                                                                                                                                                       
  do {                                                                                                                                                                                                          
    if (!state.initial && 
        state.ancestor<concept = Statemachine>.
            descendants<concept = Transition>.
            where({~it => it.target == state; }).isEmpty) { 
        error "orphan state - can never be reached" -> state; 
    }
  }                                                                                                                                                                                                             
}                                                                                                                                                                                                               
\end{code}

At this point there is no way to control when a constraint is run, it is decided
based on some MPS-internal algorithm. However, pressing \keystroke{F5} in a
program or explicitly running the model checker forces all constraints to be
reevaluated.



\section{Constraints in Spoofax}




\chapter{Type Systems}

Type systems are basically sophisticated constraints that check typing rules in
programs. Here is a definition from Wikipedia:

\begin{quote} 
A type system may be defined as a tractable syntactic framework for
classifying phrases according to the kinds of values they compute. A type system
associates types with each computed value. By examining the flow of these
values, a type system attempts to prove that no type errors can occur. The type
system in question determines what constitutes a type error, but a type system
generally seeks to guarantee that operations expecting a certain kind of value
are not used with values for which that operation makes no sense.
\end{quote}

In summary, type systems associate types with values and then checks whether
these types conform to predefined typing rules. 

We distinguish between dynamic type systems which perform the type checks as
the program executed, and static type systems, where type checks are performed
ahead of execution, mostly based on type specifications in the program. This
section focuses exclusively on static type checks.
 
 
\section{Type System Basics}

To introduce the basic concepts of type systems, let us go back to the example
used at the beginning of the section on syntax. As a reminder here is the
example code, and \fig{astexample-again} shows the abstract syntax tree. 


\begin{code}
var x: int;
calc y: int = 1 + 2 * sqrt(x)
\end{code}
 

\begin{figure}[ht]
\begin{center}
  \includegraphics[scale=0.6]{figures/1/astexample.png}
  \caption[labelInTOC]{Abstract syntax tree for the above program. Boxes
  represent instances of language concepts, solid lines represent containment,
  dotted lines represent cross-references}
  \label{astexample-again} 
\end{center}
\end{figure}

Using this example, we can illustrate in more detail what type systems have to
do:

\begin{description}
  \item[Declare Fixed Types] Some program elements have fixed types. They don't
  have to be derived or calculated, they are always the same and previously
  known. Examples include the IntConst (whose type is IntType), the sqrt concept
  (whose type is double), as well as the type declarations themselves (the type
  of IntType is IntType, the type of DoubleType is DoubleType).
  \item[Derive Types] For other program elements, the type has to be derived
  from the types of other elements. For example, the type of a VarRef (the
  variable reference) is the type of the referenced variable. The type of a
  variable is the type of it's declared type. In the example, the type of x and
  the reference to x is IntType.
  \item[Calculate Common Types] Most type systems have some kind of type
  hierarchy. In the example, IntType is a subtype of DoubleType (IntType can be
  used wherever DoubleType is expected). This subtype relationship has to be
  specified. Also, the type of certain program elements may be calculated from
  the arguments passed to them; in many cases the resulting type will be the
  "more general one". examples are the Plus and Multi constructs: if two
  IntTypes are added, the result is an IntType. If two DoubleTypes are added,
  the result is a DoubleType. If an IntType and a DoubleType are added, the
  result is a DoubleType, the more general of the two.
  \item[Type Checks] Finally, a type system has check for type errors and report
  them to the language user. In the example, a type error would occur if
  something with a DoubleType were assigned to an IntType variable.
\end{description}

Note that the type of a program element is not generally the same as it's
language concept. For example, the concept (meta class) of the number 1 is
IntConst and it's type is IntType. The type of the sqrt is DoubleType and its
concept is Sqrt. Only for type declarations themselves the two are (usually) the
same. The type of an IntType is IntType. Specifically, several instances of the
same concept can have different types: a plus calculates it's type as the more
general of the two arguments. So the type of each Plus instance depends on
what kinds of arguments the particular instance has.
 
The core of a type system can be considered to be a function typeof that
calculates the type for a program element: 

	$$typeof ::= concept => type$$ 

Types are often represented with the same technology as the language concepts.
As we will see, in case of MPS types are just nodes, i.e. instances of concepts.
In Xtext, we use EObjects, i.e. instances of EClasses as types \MV{Spoofax?}. In
both cases, we even define the concepts as part of the language. This is useful
because most of the concepts used as types also have to be used in the program
text whenever types are explicitly declared (as in \verb#var x: int#).

\section{Type Calculation Strategies}

In the end, the typeof function can be implemented in any way suitable; after
all, it is just program code. However, in practice, three approaches seem to be
used most: recursion, unification and pattern matching. Wel'll explore each of
these conceptually, and then provide examples in the tool sections.


\MV{Eelco mentioned something about Data Flow stuff in Scala. Should we add
this? Does anyone know something about that?}


\subsection{Recursion}

Recursion is widely used in computer science. According to Wikipedia, it refers
to a 

\begin{quote}
a method of defining functions in which the function being defined is
applied within its own definition.
\end{quote}

The standard example is the calculation of factorial:


\begin{code}
int factorial( int n ) {
    if ( n <= 1 ) return 1;
    else return n * factorial( n-1 );
}
\end{code}
 

In the context of type systems, the recursive approach for calculating a type
defines a polymorhphic method typeof, which takes a program element and returns
its type, while calling itself to calculate the types of those elements on which
its own type depends. 

Let us consider the following example grammar (we use Xtext notation here):


\begin{code}
LocalVarDecl:
    "var" name=ID ":" type=Type ("=" init=Expr)?;
\end{code}
 

The following examples are structurally valid example instances:

 
\begin{code}
var i: int          // 1
var i: int = 42     // 2
var i: int = 33.33  // 3
var i = 42          // 4
\end{code}
 

Let's develop the pseudo-code for typeof function the LocalVarDecl. A first cut
could look as follows:

 
\begin{code}
typeof( LocalVarDecl lvd ) {
	return typeof( lvd.type )
}

typeof( IntType it ) { return it }
typeof( DoubleType dt ) { return dt }
\end{code}
 

Notice how the typeof for LocalVarDecl recusively calls typeof for its type
property. Recursion ends with the typeof functions for the types; they return
themselves.

However, while this implementation successfully calculates the type of the
LocalVarDecl, it does not address the type check that makes sure that, if an
init expression is specified, it has the same type (or a subtype). This could be
achieved as follows:

 
\begin{code} 
typeof( LocalVarDecl lvd ) {
    if isSpecified lvd.init { 
        assert typeof( lvd.init ) isSameOrSubtypeOf typeof( lvd.type )
    } 
    return typeof( lvd.type )
}
\end{code}


Notice that the type specification itself is also optional. So we have create a
somewhat more elaborate version of the function:

 
\begin{code} 
typeof( LocalVarDecl lvd ) {
    if !isSpecified lvd.type && !isSpecified lvd.init 
        raise error
        
    if isSpecified lvd.type && !isSpecified lvd.init
    	return typeof( lvd.type )
    	
    if !isSpecified lvd.type && isSpecified lvd.init
    	return typeof( lvd.init )
    	 
    if isSpecified lvd.type && isSpecified lvd.init {
        assert typeof( lvd.init ) isSameOrSubtypeOf typeof( lvd.type )
        return typeof( lvd.type )
    } 
}
\end{code}


This is relatively verbose. Assuming that assertions are ignored if one of the
called typeof functions returns null because the argument is not specified, we
can simplify this to the following code:

 
\begin{code} 
typeof( LocalVarDecl lvd ) {
    assert isSpecified lvd.type || isSpecified lvd.init
    assert typeof( lvd.init ) isSameOrSubtypeOf typeof( lvd.type )
    return typeof( lvd.type )
}
\end{code}




\subsection{Unification}

Unification is the second approach to type calculation. Once again we start with
a definition from Wikipedia:

\begin{quote}
Unification is an operation [..] which produces from [..] logic terms a 
substitution which [..] makes the terms equal modulo some equational theory.
\end{quote}

While this sounds sophisticated, we have all used unification in high-school for
solving sets of linear equations. The "equational theory" is algebra, and
substitution refers to assignment of values to x and y. A solution is 
\verb#x := 5, y := 10#. 

 
\begin{code} 
(1) 2 * x == 10
(2) x + x == 10 
(3) x + y == 2 * x + 5
\end{code}


Using unification for type systems means that language developers specify a
number of type equations which contain type variables (cf the x and y) as well
as type values (the numbers in the above example). Some kind of engine is then
trying to make all equations be true by assigning type values to the type
variables in the type equations.

The interesting property of this approach is that there is no distinction
between typing rules and type checks. We simply specify equations. If an
equation cannot be satisfied for any assigment of type values to type variables,
a type error is detected. To illustrate this, we return to the LocalVarDecl
example introduced above.

 
\begin{code}
var i: int          // 1
var i: int = 42     // 2
var i: int = 33.33  // 3
var i = 42          // 4
\end{code}
 

The following two type equations constitute the complete type system
specification. The $:==:$ operator means type equation (left side must be the
same type as right side), $:<=:$ refers to subtype-equation (left side must be
same type or supertype of right side). The operators are taken from MPS, which
uses this technique.

 
\begin{code}
typeof( LocalVarDecl.type ) :<=: typeof( LocalVarDecl.init) 
typeof( LocalVarDecl ) :==: typeof( LocalVarDecl.type ) 
\end{code}
 

Let us look at the four examples. We use capital letters for free type
variables. In the first case, the init expression is not given, so the first
equation is ignored. The second equation can be satisfied by assigning T, the
type of the variable declaration, to be int. The second equations acts as a type
derivation rule.

 
\begin{code}
var i: int          // 1

typeof( int ) :<=: typeof( -null- ) // ignore
typeof( T ) :==: typeof( int )      // T := int
\end{code}
 

In the second case the type and the init expression are given, and both have
types that can be calculated independent from the equations specified for the
LocalVarDecl. So the first equation has no free type variables, but it is true
with the type values specified. The second equation works the same as above,
deriving T to be int.

 
\begin{code}
var i: int = 42     // 2

typeof( int ) :<=: typeof( int )    // true
typeof( T ) :==: typeof( int )      // T := int
\end{code}
 

The third case is similar to the second case; but the first equation, in which
all types are specified, is not true, so a type error is raised.

 
\begin{code}
var i: int = 33.33    // 3

typeof( int ) :<=: typeof( double ) // error!
typeof( T ) :==: typeof( int )      // T := int
\end{code}
 

Case four is interesting because no variable type is explicitly specified; the
idea is to use what's known as type inference to derive the type from the init
expression. In this case there are two free variables in the equations,
substituting both with int solves both equations. Notice how the unification
approach automatically leads to support for type inference!

 
\begin{code}
var i = 42     // 4

typeof( U ) :<=: typeof( int )  // U := int
typeof( T ) :==: typeof( U )    // T := int
\end{code}
 


To further illustrate how unification works, consider the following example
where we try to provide typing rules for array types, incl. array initializers.


 
\begin{code}
var i: int[]
var i: int[] = {1, 2, 3}
var i = {1, 2, 3}
\end{code}
 

The additional complication in this case is that we need to make sure that all
the initialiation expressions (inside the curlies) have the same or compatible
types. Here are the typing equations:

 
\begin{code}
type var T
foreach ( init.elements as e ) 
    T :<=: typeof(e)
typeof( LocalVarDecl.type ) :<=: t
typeof( LocalVarDecl ) :==: typeof( LocalVarDecl.type ) 
\end{code}
 

We introduce an additional type variable T and iterate over all the expression
in the array initializer, establishing an equation between all of these elements
and T. This results in a set of equations that each must be satisfied. The only
way to achieve this is that all array initializer members are of the same
(sub-)type. In the examples, this makes T to be int. The rest of the equations
works as explained above. Notice that if we'd write 
\verb#var i = {1, 33.33, 3}#, then $T := double$, but the equations would 
still work because we use the $:<=:$ operator. 


\subsection{Pattern Matching}

In pattern matching, we simply we simply list the possible combinations of types
in a big table. Cases that are not listed in the table will result in errors.
For our LocalVarDecl example, such a table could look like the following:

\begin{tabular}{l l l}
typeof(type) & typeof(init) & typeof(LocalVarDecl)\\
\hline
int & int & int\\
int & - & int\\
- & int & int\\
double & double & double\\
double & - & double\\
- & double & double\\
int & double & int\\
double & int & int\\
\end{tabular}
 
To avoid repeating everything for all valid types, variables could be used. T+
refers to T or subtypes of T.

\begin{tabular}{l l l}
typeof(type) & typeof(init) & typeof(LocalVarDecl)\\
\hline
T & T & T\\
T & - & T\\
- & T & T\\
T & T+ & T\\
\end{tabular}


\section{Xtext Example}

Up until version 1.0 Xtext provided no support for implementing type systems
(beyond manually implementing constraints). In 2.0 a type system integrated with
the JVM's type system is available. Since it is limited to JVM-related types, it
is not as versatile as it could be.

As a consequence, two third-party libraries have been developed: the Xtext
Typesystem Framework (developed by Markus Voelter,
\verb#http://code.google.com/a/eclipselabs.org/p/xtext-typesystem/#) and XTypes
(developed by Lorenzo Bettini, \verb#http://xtypes.sourceforge.net/#). In the
remainder of this section we will look at the Xtext Typesystem Framework.


\paragraph{Xtext Typesystem Framework} The Xtext Typesystem Framework is
fundamentally based on the recursive approach. It provides an Interface
ITypesystem with a method typeof( EObject ) which returns the type for the
program element passed in as an argument. In its simplest form, the interface
can be implemented manually with arbitrary Java code. To make sure type errors
are reported as part of the Xtext validation, the framework has to be integrated
manually:

 
\begin{code}
@Inject 
private ITypesystem ts;

@Check(CheckType.NORMAL)
public void validateTypes( EObject m ) {
    ts.checkTypesystemConstraints( m, this );
}    
\end{code}
 

Most type systems are built from a limited set of typing rules (assigning fixed
types, deriving the type of an element from one of its properties, calculating
the type as the common type of its two arguments). The DefaultTypesystem class
provides support for declaratively. In the code below, the initialize method
defines one type (the type of the IntType is a clone of itself) and defines one
typing constraint (the expr property of the IfStatement must be a boolean).
Also, for types which cannot be specified declaratively, an operation type can
be implemented to programmatically define types. 

 
\begin{code}
public class CLTypesystem extends CLTypesytemGenerated {

    private CoolingLanguagePackage cl = CoolingLanguagePackage.eINSTANCE;
    
    @Override
    protected void initialize() {
        try { 
            useCloneAsType(cl.getIntType());
            ensureFeatureType(cl.getIfStatement(), 
                cl.getIfStatement_Expr(), cl.getBoolType());
        } catch ( TypesystemConfigurationException tsce ) {
            tcse.printStackTrace();
        }            
    }
        
    public EObject type( NumberLiteral s, TypeCalculationTrace trace ) {
        if ( s.getValue().contains(".")) {
            return create(cl.getDoubleType());
        }
        return create(cl.getIntType());
    }
}
\end{code}
 

In addition to the API used in the code above, the Typesystem Framework also
comes with a textual DSL to express typing rules. From the textual type system
specification, a generator generates the implementation of the Java class that
implements the type system using the APIs. In that sense, the DSL is just a
facade on top of a framework; however, this is a nice example of how a DSL can
provide added value over a framework or API (\fig{fig:xtext-typesyseditor} shows
a screenshot):

\begin{itemize}
  \item the notation is much more concise
  \item code completion into the target language meta model is provided
  \item if the typing rules are incomple, a static error is shown in the editor,
  as opposed to getting runtime error when the framework starts up (see the
  warning in (\fig{fig:xtext-typesyseditor})
  \item pressing ctrl-space on a property jumps to the typing rule that defines
  the type for that property.
\end{itemize}



\begin{figure}[ht]
\begin{center} 
  \includegraphics[scale=0.7]{figures/2/xtext-typesyseditor.png}
  \caption[labelInTOC]{}
  \label{fig:xtext-typesyseditor} 
\end{center}
\end{figure}


\paragraph{Type system for the Cooling language} The complete type system for
the cooling language is 200 lines of DSL code, and another 100 lines of Java
code. We'll take a look at some representative examples.

Primitive types usually use a copy of themselves as their type. It has to be a
copy as opposed to the object itself, because the actual program element must
not be pulled out of the EMF containment tree. This is specified as follows:

 
\begin{code}
typeof BoolType -> clone
typeof IntType -> clone
typeof DoubleType -> clone
typeof StringType -> clone
\end{code}
 

For concepts that have a fixed type, but not a clone, the type can simply be
specified:

 
\begin{code}
typeof StringLiteral -> StringType
\end{code}
 

Type systems are most important, and most interesting, in the context of
expressions. Since all expressions derive from the abstract Expr concept, we can
declare that this class is abstract, and hence no typing rule is given. However,
the editor reports a warning there are concrete subclasses of an abstract class
for which no type is specified either.

 
\begin{code}
typeof Expr -> abstract
\end{code}
 

The notation provided by the DSL groups typing rules and type checks for a
single concept together. The following is the typing information for the Plus
concept. It declares the type of Plus to be the common type of the left and
right arguments ("the more general one") and then adds two constraints that
check that the left and right argument are either strings, ints or doubles.

 
\begin{code}
typeof Plus -> common left right {
    ensureType left :<=: StringType, IntType, DoubleType
    ensureType right :<=: StringType, IntType, DoubleType
} 
\end{code}
 

The typing rules for Equals are also interesting. It specifies that the
resulting type is booleanm that the left and right arguments must be COMPARABLE,
and that the left and right arguments are compatible. COMPARABLE is a so-called
type characteristic, this can be considered as collection of types. In this case
it is  IntType, DoubleType, and BoolType. The $:<=>:$ operator describes
unordered compatibility: the types of the two properties left and right must
either be the same, or left must be a subtype or right, or vice versa. 

 
\begin{code}
typeof Equals -> BoolType {
    ensureType left :<=: char(COMPARABLE)
    ensureType right :<=: char(COMPARABLE)
    ensureCompatibility left :<=>: right
}
characteristic COMPARABLE {
    IntType, DoubleType, BoolType
}
\end{code}
 

There is also support for ordered compatibility, as can be seen from the typing
rule for AssignmentStatement. It has no type (it is a statement!), but the left
and right argument must exhibit ordered compatibility: they either have to be
the same types, or right must be a subtype of left, and \emph{not} vice versa.

 
\begin{code}
typeof AssignmentStatement -> none {
    ensureCompatibility left :<=: right
}
\end{code}
 



\section{MPS Example}

MPS includes a DSL for type system rule definition. The semantics are based on
unification, and to some extent, pattern matching. 

The type of a LocalVariableReference is calculated with the following typing
rule\footnote{Since only the expression within the \ic{do \curlies{ ... }} block has
to be typed by the developer, we'll only show that expression in future
examples.}. It establishes an equation between the type of the
LocalVariableReference itself and the variable it references. \verb#typeof# is a
built-in operator returns the type for its argument.

 
 
\begin{code}
rule typeof_LocalVariableReference {                    
  applicable for concept = LocalVariableReference as lvr
  overrides false                                       
                                                        
  do {                                                  
    typeof(lvr) :==: typeof(lvr.variable);              
  }                                                     
}                                                       
\end{code}
 

The rules for the boolean NotExpression contains two rules. The first one makes
sure that the notted expression is boolean. The second one types the
NotExpression itself to be boolean. Just as in Xtext, in MPS types are instances
of language concepts. In MPS there are two different ways how language concepts
can be instantiated. The first one (as shown in the first rule) uses the
BaseLanguage new Expression. The second one uses a quotation, where "a piece of
tree" can be inlined into program code. It uses the concrete syntax of the
quoted construct --- here: a BooleanType --- in the quotation.

 
\begin{code}
typeof(notExpr.expression) :==: new node<BooleanType>(); 
typeof(notExpr) :==: <boolean>; 
\end{code}
 

A more interesting example is the typing of structs. Let us consider the
following piece of C code:

 
\begin{code}
struct Person {
    char* name;
    int	age;
}

int addToAge( Person p, int delta ) {
    return p.age + delta;
}
\end{code}
 

At least two program elements have to be typed: the parameter p as well as the
p.age expression. The type of the FunctionParameter concept is the type of its
type: \verb#typeof(parameter) :==: typeof(parameter.type);#. This is not
specific to the fact that the parameter refers to a struct. The language concept
that represents the Person type in the parameter is a StructType. A StructType
refers to the StructDeclaration it represents a type of and extends Type, which
acts as the super type for all types in the Embedded C language. So in essence,
this means that the type of p is an instance of StructType that has a pointer to
the StructDeclaration Person.

The p.age is an instance of a StructAttributeReference. It is defined as
follows. It is an expression, owns another expression variable (on the left of
the dot) as well as a reference to a StructAttribute (name or age in the
example) .

 
\begin{code}
concept StructAttributeReference extends Expression
                                 implements ILValue
  instance can be root: false                      

  children:                                        
  Expression variable 1 specializes: <none>        
                                                   
  references:                                      
  StructAttribute attribute 1 specializes: <none>  
\end{code}
 
                                                   
The typing rule for the StructAttributeReference looks as follows. The variable,
the expression on which we use the dot operator, has to be a GenericStructType,
or a subtype thereof (i.e. a StructType which points to an actual
StructDeclaration). Second, the type of the whole expression is the type of the
reference attribute (e.g. int in case of p.age).

 
\begin{code}
typeof(structAttrRef.variable) :<=: new node<StructType>(); 
typeof(structAttrRef) :==: typeof(structAttrRef.attribute);
\end{code}
 

This example also illustrates the interplay between the type system and other
aspects of language definition, specifically scopes. The referenced
StructAttribute (on the right side of the dot) may only reference a
StructAttribute that is part of the the StructDeclaration that is referenced
from the StructType. The following scope definition illustrates this:

 
\begin{code}
link {attribute} 
  search scope: 
    (model, scope, referenceNode, linkTarget, enclosingNode)->join(ISearchScope | sequence<node< >>) { 
      node<> varType = referenceNode.variable.type; 
      if (varType.isInstanceOf(StructType)) { 
        return (varType as StructType).struct.attributes;
      } else { 
        return null; 
      } 
    } 
\end{code}
 

MPS also uses pattern matching. As we will discuss in the chapter on language
extension and composition, MPS supports incremental extension of existing
languages. Extensions may also introduce new types, and, specifically, may allow
existing operators to be used with these new types. 

As an example consider the introduction of complex numbers into C. It should be
possible to write code like this:

 
\begin{code}
complex c1 = (1, 2i);
complex c2 = (3, 5i);
complex c3 = c1 + c2; // (4+7i)
\end{code}
 

The plus in \verb#c1 + c2# should be the Plus defined by the original language.
Alternatively, we could define a new plus for complex numbers. While this would
work technically (remember there is no parser ambiguity problems), it would mean
that users, when entering a Plus, would have to decide between the original plus
and the new plus for complex numbers. This would not be very convenient from a
usability perspective. By reusing the original plus we avoid this problem.

However, this requires that the typing rules defined for plus in the original C
language will now accept complex numbers; the original typing rules must be
extended. To enable this, MPS supports so-called overloaded operations
containers. The following container defines the type of plus and minus if both
arguments are int or double.

 
\begin{code}
overloaded operations rules binaryOperation                                                                          
                                                                                                                     
operation concepts: PlusExpression | MinusExpression
left operand type: <int> is exact: false use strong subtyping false                                                  
right operand type: <int> is exact: false use strong subtyping false                                                 
operation type: (operation, leftOperandType, rightOperandType)->node<> { 
  <int>; 
}                                            

operation concepts: PlusExpression | MinusExpression
left operand type: <double> is exact: false use strong subtyping false                                                  
right operand type: <double> is exact: false use strong subtyping false                                                 
operation type: (operation, leftOperandType, rightOperandType)->node<> { 
  <double>; 
}                                            
\end{code}
 

To tie these definitions into the regular typing rules, the following typing
rule must be written\footnote{Note that only one such rule must be written for
all binary operations. Everything else will be handled with the overloaded
operations containers}. Using the operation type construct, the typing rules
ties in with overloaded operation containers.

 
\begin{code}
rule typeof_BinaryExpression {                                                                                                                                                                                                                                                                                                                                           
  applicable for concept = BinaryExpression as be                                                                                                                                                                                                                                                                                                                        
  overrides false                                                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                         
  do {                                                                                                                                                                                                                                                                                                                                                                   
    when concrete (typeof(be.left) as left) { 
        when concrete (typeof(be.right) as right) { 
            node<> optype = operation type( be , left , right ); 
            if (optype != null) { 
                typeof(be) :==: optype; 
            } else { 
                error "operator " + be.concept.name + 
                      " cannot be applied to " +
                      left.concept.name + "/" 
                      + right.concept.name -> be; 
            } 
        } 
    }
  }                                                                                                                                                                                                                                                                                                                                                                        
\end{code}
 

The important aspect of this approach is that overloaded operation containers
are additive. Language extensions can simply contribute additional containers.
For the complex number example, this could look like the following. We declare
that as soon as one of the arguments is of type complex, the resulting type will
be complex as well.

 
\begin{code}
operation concepts: PlusExpression | MinusExpression                                     
one operand type: <complex> is exact: false use strong subtyping false     
is applicable:                                                         
<no isApplicable>                                                      
operation type:                                                        
(operation, leftOperandType, rightOperandType)->node<> { 
  <complex>; 
}  
-----------------------------------------------                        
\end{code}
 


The Typesystem DSL in MPS covers a large fraction of the type system rules
encountered in practice. BaseLanguage, which is an extension of Java, covers the
whole Java type system this way. However, for exceptional cases, procedural
BaseLanguage code can be used to implement type checks as well.

\section{Spoofax Example}


Explain why expressions are different than "normal" programs
(precedence, etc.)

Show how Xtext, MPS and SDF do it differently

Explain why type systems are important in this context, although they
are "just constraints". Use as basis:
  TypesystemsForDSLs.pdf in the materials directory

explicit types vs. full type inference vs. local type inference

Recursion, Unification, Pattern Matching, Data Flow stuff (Scala, Eelco?)

attribute grammars