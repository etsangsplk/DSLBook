\chapter{Debugging DSLs}    

\todo{Do we have a chapter abstract everywhere?}

Debugging is relevant in two ways in the context of DSLs and language
workbenches. First, the DSL developer may want to debug the definition of a DSL,
including constraints, scopes or transformations and interpreters. Second,
programs written in the DSL may have to be debuggable by the end user. We
address both aspects in this chapter.

\section{Debugging the DSL Definition}

\todo{Write something here}

\subsection{Understanding and Debugging the Language Structure}

In parser-based systems, the transformation from text to the AST performed by
the parser\footnote{... and the lexer, if there is one ...} is itself a
non-trivial process and has a potential for errors. Debugging the parsing
process can be important.

\parhead{Xtext} Xtext uses ANTLR\footnote{http://antlr.org} under the hood. In
other words, from the Xtext grammar, an ANTLR grammar is generated which
performs the actual parsing. So understanding and debugging the Xtext parsing
process means understanding and debugging the ANTLR parsing process.

There are two ways to do this. First, since ANTLR generates a Java-based parser,
you can debug the execution of ANTLR (as part of Xtext) itself. Second, you
can have Xtext generate a debug grammar, which contains no action code (so it
does not populate the AST). However, it can be used to debug the parsing process
with ANTLRWorks\footnote{http://www.antlr.org/works}. ANTLRWorks comes with an
interactive debugger for ANTLR grammars.

\parhead{MPS} In MPS there is no transformation from text to the AST since it is
a projectional editor. However, there are still means to help better
understand the structure of an existing program. For example, any program
element can be inspected in the \emph{Explorer}. \fig{mps-explorer} shows the
information for a trivial C function:

\begin{code}
int8_t add(int8_t x, int8_t y) { 
  return x + y; 
} 
\end{code}


\begin{figure}[h]
\begin{center}
  \includegraphics[width=8cm]{figures/8/mps-explorer.png}
  \caption[]{The MPS explorer shows the structure of a program as a tree.
  The explorer also shows the concept for each program element as well as the
  type, if an element has one.}
  \label{mps-explorer} 
\end{center} 
\end{figure}

MPS provides similar support for understanding the projection rules. For any
program node MPS can show the cell structure as a tree. The tree contains
detailed information about the cell hierarchy, the program element associated
with each cell as well as the properties of the cell (height, width, etc.).

\todo{handle the noindent correctly all over the book}

\subsection{Debugging Scopes, Constraints and Type Systems}

Depending on the level of sophistication of a particular language, a lot of
non-trivial behavior can be contained in the code that determines scopes, checks
constraints or computes types. In fact, in many languages, these are the most
sophisticated aspects of language definition. Consequently, there is a need
for debugging those.

\parhead{Xtext} In Xtext, all aspects of a language except the grammar and the
abstract syntax are defined via Java programs using Xtext APIs. This includes
scopes, constraints and type system rules\footnote{It also includes all IDE
aspects.}. Consequently, all these aspects can be debugged by using a Java
debugger. To do this, you can simply launch the Eclipse Application that
contains the language and editor in debug mode and set breakpoints at the
relevant locations\footnote{It is easy to criticize Xtext for the fact that it
does not use DSLs for defining DSLs. However, in the context of debugging this
is good, because no special debuggers are necessary.}.

\parhead{MPS} MPS comes with an equivalent facility in the sense that a second
instance of MPS can be launched that runs "inside" the current one. This inner
instance can be debugged from the outside one. This approach can be used for all
those aspects of MPS-defined languages that are defined in terms of the
BaseLanguage, MPS' version of Java. For example, scopes can be debugged this
way. For example, in \fig{mps-mps-debug} we debug the scope for a
\ic{LocalVariableRef}.


\begin{figure*}[h]
  \includegraphics[width=17cm]{figures/8/mps-mps-debug.png}
  \caption[]{The debugger that can debug MPS while it "executes" a language is
  aware of all the relevant extensions to BaseLanguage. For example, in this
  screenshot we debug a scope constraint. Notice how in the \ic{Variables} view
  program nodes (such as the \ic{Statement s}) are shown on the abstraction
  level of the node, not in terms of its underlying Java data structure
  representation.}
  \label{mps-mps-debug} 
\end{figure*}


A related feature of MPS is the ability to analyze exception stack traces. MPS
generates Java code from language definitions and then executes this Java code.
If an exception occurs in language implementation code, this exception produces
a Java stack trace. This stack trace can be pasted into a dialog in MPS. MPS
then produces a version of the stack trace where the code locations in the stack
trace (which are relative to the generated Java) have been translated to
locations in the DSL definition (expressed in Base Language). The locations can
be clicked directly, opening the MPS editor at the respective location.

In the design chapter \todo{ref} we discussed how declarative languages may come
with a debugger that fits the particular declarative paradigm used by a
particular declarative language. MPS comes with two facilities. First, pressing
\ic{Ctrl-Shift-T} on any program element will open a dialog that shows the type
of the element. If the element has a type system error, that dialog also lets
the user navigate to the rule that reported the error. The second facility is
much more sophisticated. For any program node, MPS can show the so-called type
system trace (\fig{mps-ts-trace} shows a simple example). Remember how the MPS
type system is relies on a solver to solve the type system equations associated
with program elements (specified by the language developer for the respective
concepts). So each program has an associated set of type system equations.
Those contain explicitly specified types as well as type variables. The solver
tries to find type values for these variables such that all type system
equations become true. The type system trace essentially visualizes the state of
the solver including the values it assigns to type variables as well as which
type system rules are applied to which program element.

\begin{figure}[h]
  \includegraphics[width=11cm]{figures/8/mps-ts-trace.png} 
  \caption[][-20mm]{This
  example shows the solver state for the \ic{Argument x}. It first applies the
  rule \ic{typeof\_ITyped} (\ic{Argument} implements \ic{ITyped}) which
  expresses that the type of the element (type variable
  \ic{c} is the same as the element's \ic{type} property (type variable \ic{d}).
  It then applies the \ic{typeof\_Type} rule to the argument's type itself. This
  rule expresses that the type of a \ic{Type} is a clone of itself.
  Consequently, the type variable \ic{d} can be set to \ic{int8\_t}. In
  consequence this means that the type variable \ic{c} (which represents the
  type of the \ic{Argument}) is also \ic{int8\_t}. Note that this is a trivial
  example. Type system traces can become quite involved.}
  \label{mps-ts-trace} 
\end{figure}


\subsection{Debugging Interpreters and Transformations}

Debugging an interpreter is simple: since an interpreter is just a program
written in some programming language that processes and acts on the DSL program,
debugging the interpreter simply uses the debugger for the language in which the
interpreter is written\footnote{This assumes that the interpreter is written in
a programming language for which a debugger exists}. 

Debugging transformations and generators is typically not quite as trivial, for
two reasons. First, transformations and generators are typically written in DSLs
optimized for this task. So a specialized debugger is required. Second, if
multi-step transformations are used, the intermediate models may have to be
accessible, and it should be possible to trace a particular element through the
multi-step transformation.

\parhead{Xtext} As we have said before, Xtext can be used together with any
EMF-compatible code generator or transformation engine. However, since Xtext
ships with Xtend, we look at debugging Xtend transformations. Model-to-model
transformations and code generators in Xtend look very similar: both use Xtend
to navigate over and query the model, based on the AST. The difference is that,
as a side effect, model-to-model transformations create new model elements and
code generators create strings --- typically using the rich strings (aka
template expressions). 
 
Xtend supports debugging either on the level of the generated code, or on the
Xtend source level. As \fig{templatesdebugging} shows, even the template
expressions can be debugged. The Variables view shows the EMF representation
(i.e. the implementation) of program elements. 
 
\begin{figure*}[h]
  \includegraphics[width=17cm]{figures/8/xtext-templatesdebugging.png} 
  \caption[][-20mm]{}
  \label{templatesdebugging} 
\end{figure*}

Xtend is a fundamentally an imperative/OO language, so the step-through metaphor
for debuggers is appropriate. If Xtend is used for code generation or
transformation, debugging a boils down to stepping through the code that builds
the target model. I emphasize this because the next example uses a different
appraoch.


\parhead{MPS} In MPS, working with several chained transformations is normal, so
MPS provides support for debugging the transformation process. This support
includes two ingredients. The first one is showing the mapping partitioning. For
a given model, MPS computes the order in which transformations apply and reports
it to the user. This is useful to understand which transformations are executed
in which order\footnote{... and to debug transformation priorities!}. Let us
investigate a simple example C program that contains a message definition and a
\ic{report} statement. The \ic{report} statement is transformed to \ic{printf}
statements.

\begin{code}
module Simple imports nothing { 
   
  message list messages { 
    INFO aMessage() active: something happened 
  } 
   
  exported int32_t main(int32_t argc, int8_t*[] argv) { 
    report(0) messages.aMessage() on/if; 
    return 0; 
  } 
}
\end{code}

Below is the mapping configuration for this program: 

\begin{code}
[ 1 ]
com.mbeddr.core.modules.gen.generator.template.main.removeCommentedCode
[ 2 ]
com.mbeddr.core.util.generator.template.main.reportingPrintf
[ 3 ]
com.mbeddr.core.buildconfig.generator.template.main.desktop
com.mbeddr.core.modules.gen.generator.template.main.main
\end{code}

This particular model is generated in three phases. The first one removes
commented code to make sure it does not show up in the resulting C text file.
The second phase runs the generator that transforms \ic{report} statements into
\ic{printf}s. Finally, the \ic{desktop} generator generates a \ic{make} file
from the build configuration, and the last step generates the C text from the C
tree.

By default, MPS runs all generators until everything is either discarded or
transformed into text. While intermediate models exist, they are not shown to
the user. For debugging purposes though, these intermediate, transient models
can be kept around for inspection. Each of the phases is represented by one or
more transient models. As an example, here is the program after the \ic{report}
statement has been transformed:

\begin{code}
module Simple imports nothing { 

  exported int32_t main(int32_t argc, int8_t*[] argv) { 
    printf("$$ aMessage: something happened "); 
    printf("@ Simple:main:0#240337946125104144 \n "); 
    return 0;
  } 
} 
\end{code}

MPS also supports tracing an element through the intermediate models.
\fig{mps-tracer} shows an example. Users can select a program element in the
source, target or an intermediate model and trace it to the respective other
ends of the transformation.

\begin{figure*}[h]
  \includegraphics[width=18cm]{figures/8/mps-tracer.png}
  \caption[]{The generation trace functionality in MPS allows users to trace
  how a particular program element is transformed through a chain of
  transformations. The generation tracer also shows the transformation rules
  involved in the transformation.}
  \label{mps-tracer} 
\end{figure*}

Note how this approach to debugging transformations is very different from the
Xtend example above: instead of stepping through the transformation
code\footnote{As part of the general Debug-MPS-in-MPS functionality, MPS
transformations can also be debugged in a more imperative fashion. This is
useful, for example, to debug more complex logic used inside transformation
templates.}, MPS provides a \emph{static} representation of the transformation
in terms of the intermediate models and the element traces through them.


\section{Debugging DSL Programs}

To find errors in DSL programs, we can either debug them on the level of the DSL
program or in its $L_{D-1}$ representation (i.e. in the generated code or the
interpreter). Debugging on $L_{D-1}$ is useful if you want to find problems in
the execution engine, or, to some extent, if the language users are programmers
and they have an intimate understanding of the $L_{D-1}$ representation of the
program. However, for many DSLs it is necessary to debug on the level of the DSL
program either because the users are not familiar with the $L_{D-1}$
representation\footnote{This is true particularly for DSLs qtargeted at domain
experts, }, or because the $L_{D-1}$ is so low-level and complex that is bears
no obvious resemblance to the DSL program.


The way to build debuggers for DSLs of course depends on the DSL itself. For
example, for DSLs that only describe structures, debugging does not make much
sense in the first place. For DSLs that describe behavior, the debugging
approach depends on the behavioral paradigm used in the DSL. We have discussed
this in \todo{ref}. In this section we focus mostly on the imperative
paradigm\footnote{An examples for the functional paradigm has been provided in
\todo{ref}, and the type system tracer described above is an example of a
debugger for a declarative language.}.

Building a debugger poses two challenges. The first one is the debugger UI:
creating all the buttons and views for controlling the debugger and for showing
variables and treads. The second challenge concerns the control of and
data exchange with the to-be-debugged program. The first challenge is relatively
simple to solve, since many IDE frameworks (including Eclipse and MPS) already
come with debugger frameworks. 

The second challenge can be a bit more tricky. If the DSL is executed by an
interpreter, the situation is simple: the interpreter can be run and controlled
directly from the debugger. It is easy to implement single-stepping and variable
watches, for example, since the interpreter can directly provide the respective
interfaces\footnote{This is especially true if the interpreter is written in the
same language as the IDE --- no language integration issues have to be addressed
in this case.}. On the other hand, if the DSL program is transformed into code
that is executed in some other environment outside of our control, it may even
be impossible to build a debugger because there is no way to influence and
inspect the running program. Alternatively, it may be necessary to build a
variant of the code generator which generates a \emph{debug version} of the
program which contains specialized code to interact with the debugger. For
example, values of variables may be stored in a special data structure
inspectable by the debugger, and at each program location where the program may
have to stop (in single step mode or as a consequence of a breakpoint) code is
inserted that explicitly suspends the execution of the program, for example by
\ic{sleep}ing the current thread. However, such an approach is often limited and
ugly --- in the end, an execution infrastructure must provide debug support to
enable robust debugging.



\subsection{Print Statements --- a Poor Man's Debugger}

As the above discussion suggests, building full-blown debuggers may be a lot of
work. It is worth exploring whether a simpler approach is good enough. The
simplest such approach is to extend the DSL with language concepts that simply
print interesting aspects of the executing program to the console or a log file.
For example, the values of variables may be output this way.

The mbeddr \ic{report} statement is an example of this approach. A \ic{report}
statement takes a message text plus a set of variables. It then outputs the
message and the values of these variables. The target of the report statement
can be changed. By default, it reports to the console. However, since certain
target devices may not have any console, alternative transformations can be
defined for report statements, that, for example, could output the data to an
error memory or a serial line. A particularly interesting feature of \ic{report}
statements is that the transformation that handles them knows where in the
program the \ic{report} statement is located. It can add this information to the
output\footnote{The go-to-error-location functionality discussed in
\fig{analyzeErrorOutput} is based on this appraoch.}.

An approach based on print \emph{statements} is sometimes clumsy because it
requires factoring out the to-be-printed expression. And it only works for an
imperative language in the first place. For languages that make use of
sophisticated expressions, a different approach is recommended. Consider the
following example:

\begin{code}
Collection[Type] argTypes = aClass.operations.arguments.type;
\end{code}

If you wanted to print the list of operations and arguments, you would have to
change the program to something like this:

\begin{code}
print("operations: " + aClass.operations);
print("arguments: " + aClass.operations.arguments);
Collection[Type] argTypes = aClass.operations.arguments.type;
\end{code}

A much simpler alternative uses \emph{inlined} reporting expressions:


\begin{code}
Collection[Type] argTypes = aClass.operations.print("operations:")
                            .arguments.print("arguments:").type;
\end{code}
 
To make this convenient to use, the \ic{print} function has to return the object
it is called on (the one before the dot), and it must be typed accordingly if a
language with static type checking is used\footnote{The original
openArchitectureWare Xtend did it this way.}.


\subsection{Automatic Program Tracing}

As languages and programs become more complex, an automated tracing of program
execution may be useful. In this approach, all execution steps in a program are
automatically traced and logged into a tree-like data structure. The
refrigerator cooling language uses this approach. Here is an example program:

\begin{code}
cooling program HelloWorld {
    var temp: int
    start:
        entry { state s1 }  
    state s1: 
        check temp < 10 { state s2 }
    state s2: 
}
\end{code} 

Upon startup, it enters the \ic{start} state and immediately transitions to
state \ic{s1}. It remains in \ic{s1} until the variable \ic{temp} becomes less
than 10. It then transitions to \ic{s2}. Below is a test for this program that
verifies this behavior:

\begin{code}
test HelloWorldTest for HelloWorld {
    prolog {
        set temp = 30
    }
    step
    assert-currentstate-is s1
    step
    mock: set temp = 5
    step
    assert-currentstate-is s2
}
\end{code}

\fig{interpreterlog} shows the execution trace. It shows the execution of each
statement and the evaluation of each expression. The log viewer is a table tree
so the various execution steps can be selectively expanded and collapsed. To
connect to the program, users can double-click on an entry to select the
respective program element in the source node. By adding special comments to the
source, the log can be structured further.

\begin{figure}[h]
  \includegraphics[width=11cm]{figures/8/interpreterlog.png}
  \caption[]{The log viewer represents a program's execution as a tree. The
  first column contains a timestamp and the tree nesting structure. The second
  column contains the kind (severity) of the log message. A filter can be used
  to show only messages above a certain severity. The third column shows the
  language concept with which the trace step is associated (double-clicking on
  a row selects this element in the editor). Finally, the last column contains
  the information about the semantic action that was performed in the
  respective step.}
  \label{interpreterlog} 
\end{figure}

The execution engine for the programs is an interpreter, which makes it
particularly simple to collect the trace data. All interpreter methods that
execute statements or evaluate expressions take a \ic{LogEntry} object as an
additional argument. The methods then add children to the current \ic{LogEntry}
that describe whatever the method did, and then passes the child to any other
interpreter methods it calls. As an example, here is the implementation of the
\ic{AssignmentStatement}:

\begin{code}
protected void executeAssignmentStatement(AssignmentStatement s, LogEntry log) {
    LogEntry c = log.child(Kind.info, context, "executing AssignmentStatement" ); 
    Object l = s.getLeft();
    Object r = eval(s.getRight(), c);
    eec().environment.put(symbol, r);
    c.child(Kind.debug, context, "setting " + symbol.getName() + " to " + r);
}
\end{code}

If instead of an interpreter a code generator were used, the same approach could
essentially be used. Instead of embedding the tracing code in the interpreter,
the code generator would generate code that would build the respective trace
data structure in the executing program. Upon termination, the data structure
could be dumped to an XML file and subsequently loaded by the IDE for
inspection.



\subsection{Simulation as an Approximation for Debugging}

The interpreter for the Cooling programs mentioned above is of course not the
final execution engine --- C code is generated that is executed on the actual
target refrigerator hardware. However, as we have discussed in the design part
of the book (\todo{ref}), we can make sure the generated code and the
interpreter are semantically identical by running a sufficient (large) number of
tests. If we do this, we can use the interpreter to test the programs for
logical errors. The interpreter can also be used interactively, in which case it
acts as a simulator for the executing program. \fig{simulator} shows a
screenshot of a running program. 

If you look at \fig{simulator} closely, you will see that it shows all variables
in the program, the events in the queue, running tasks as well as the values of
properties of hardware elements and the current state. It also provides a button
to single-step the program, to run it continuously, and until it hits a
breakpoint. In other words, although the simulator does not use the
familiar\footnote{... familiar to programmers, but not to the target audience!}
UI of a debugger, it actually is a debugger\footnote{As we have said above,
the fact that it runs in the interpreter instead of the generated code is not
a problem if we ensure the two are semantically identical. Of course we cannot
find bugs in the implementation (i.e. in the generator) this way. But to
detect those, debugging on the level of the generated C code is more useful
anyway.}!

If you already have the interpreter\footnote{we discuss how to build on in
\todo{}}, expanding it into a simulator/debugger is relatively simple.
Essentially only three things have to be done:

\begin{itemize}
  \item First, the execution of the program must be controllable from the
  outside. This involves setting breakpoints, single-stepping through the
  program and stopping execution if a breakpoint is hit. In our example case, we
  do not single-step through statements, but only through
  steps\footnote{Remember that the language is time-triggered anyway, so
  execution is basically a sequence of steps triggered by a timer. In the
  simulator/debugger, the timer is replaced with the user pressing the
  \ic{Next Step} button for single stepping.}. Breakpoints are essentially
  Boolean flags associated with program elements: if the
  execution processes a statement that has the \ic{breakpoint} flat set to
  \ic{true}, execution stops.
  \item Second, we have implemented an Observer infrastructure for all parts of
  the program state that should be represented in the simulator UI. Whenever one
  of them changes (as a side effect of executing a statement in the program), an
  event is fired. The UI registers as an observer and updates the UI in
  accordance with the event.
  \item Third, values from the program state must be changeable from the
  outside. As a value in the UI (such as the temperature of a cooling
  compartment) is changed by the user, the value is updated in the state of the
  interpreter as well. 
\end{itemize}


\subsection{Automatic Debugging for Xbase-based DSLs}

DSLs that use Xbase, the reusable expression language that ships with Xtext,
get debugging mostly for free. This is because of the tight integration of Xbase
with the JVM. While we describe this integration in more detail in \todo{}. Here
is the essence. 

A DSL that uses Xbase typically defines its own structural and high-level
behavioral aspects but uses Xbase for the fine-grained, expression-level
behavior. For example, in a state machine DSL, states, events and transitions
would be concepts defined by the DSL, but the guard conditions and the action
code would reuse Xbase expressions. When mapping this DSL to
Java\footnote{Xbase-based DSLs \emph{must} be mapped to Java to benefit from
Xbase in the way discussed in this section. If you generate code other than
Java, Xbase cannot be used sensibly.}, the following approach is used. The
structural and high-level behavioral aspects are mapped to Java, but \emph{not}
by generating Java text, but by mapping the DSL AST to a Java AST. For the
reused Xbase aspects (the finer-grained behavior) there already exists a to-Java
generator (called the Xbase compiler) which we simply call from our generator.

Essentially, we do not create a code generator, but a model-to-model
transformation from the DSL AST to the Java AST. As part of the this
transformation (performed by the so-called JVMModel inferrer), trace links
between the DSL code and the created Java code are created. In other words, the
relationship between the Java code and the DSL code is well known. This
relationship is exploited in the debugging process. 

Xbase-based DSLs use the Java debugger for debugging. In addition to showing the
generated Java code, the debugger can also show the DSL code, based on the
trace information collected by the JVMModel inferrer. In the same way, if a user
sets a breakpoint in the DSL code, the trace information is used to determine
where to set the breakpoint in the generated Java code. 


\subsection{Debuggers for an Extensible Languages}
\label{mbeddrex}

This section describes in some detail the architecture of an extensible debugger
for an extensible language\footnote{Extensible languages have been defined and
discussed in the design section \todo{ref}. We show in detail in \todo{ref} how
this works with MPS}. We illustrate the approach with an implementation based on
mbeddr, an extensible version of C implemented with the MPS. We also show the
debuggers for non-trivial extensions of C.


\paragraph{Requirements on the Debugger}

Debuggers for imperative languages support at least the following features:
\emph{Breakpoints} suspend execution on arbitrary statements; \emph{Single-Step
Execution} steps over statements, and into and out of functions or other
callables; \emph{Watches} show values of variables, arguments or other aspects
of the program state. \emph{Stack Frames} visualize the call hierarchy of
functions or other callables.

When debugging a program that contains extensions, breakpoints,
stepping, watches and call stacks \emph{at the extension-level} differ from their
counterparts \emph{at the base-level}. The debugger has to perform the mapping
from the base-level to the extension-level (\fig{levels}). We distinguish
between the \emph{tree} representation of a program in MPS and the generated
\emph{text} that is used by the C compiler and the debugger
backend. A program in the tree representation can he separated into parts
expressed in the \emph{base} language and parts expressed using
extensions. We refer to the latter the \emph{extension}-level or
\emph{DSL}-level (see \fig{levels}).

\todo{make this a vertical figure}
\begin{marginfigure}
  \centering  
    \includegraphics[width=85mm]{figures/8/mbeddr/levels.png}
    \caption{
    An extension-aware debugger maps the debug
    behavior from the base-level to the extension-level (an extension may also
    be mapped onto other extensions; we ignore this aspect in this section).}
  \label{levels} 
\end{marginfigure}

\noindent An extensible \emph{tree}-level debugger for mbeddr  that
supports debugging on the \emph{base}-level and \emph{extension}-level, 
addresses the following requirements:

\begin{description}
\item[Modularity] Language extensions in mbeddr are
modular, so debugger extensions must be modular as well. No changes to the base
language must be necessary in order to enable debugging for a language
extension.

\item[Framework Genericity] In addition, new
language extensions must not require changes \emph{to the core debugger
infrastructure} (not just the base language).
  
\item[Simple Debugger Definition] Creating language
extensions is an integral part of using mbeddr. Hence, the development of a
debugger for an extension should be simple and not require too much knowledge
about the inner workings of the framework, or even the C debugger backend.

\item[Limited Overhead] As a consequence of embedded
software development, we have to limit the additional, debugger-specific code
generated into the binary. This would increase the size of the binary,
potentially making debugging on a small target device infeasible.
  
\item[Debugger Backend Independence] Embedded
software projects use different C debuggers depending on the target
device. This prevents modifying the C debugger itself: changes would have to be
re-implemented for every C debugger used.
\end{description}



\phead{An example Extension} We start out by developing a simple extension to
the mbeddr C language\footnote{We assume that you have read the basics about MPS
language development in \todo{ref}.}. The \ic{foreach} statement can be used to
conveniently iterate over C arrays. Users have to specify the array as well as
its size, since in C an array cannot be queried for its size. Inside the
\ic{foreach} body, \ic{it} acts as a reference to the current iteration's array
element.

\begin{code}
int8_t s = 0;                                              
int8_t[] a = {1, 2, 3};                  
foreach (a sized 3) {    
    s += it;    
} 
\end{code}

The code generated from this piece of extended C looks as follows. The
\ic{foreach} statement is expanded into a regular \ic{for} statement and an
additional variable \ic{\_\_it}:

\begin{code}
int8_t s = 0;                                              
int8_t[] a = {1, 2, 3};                  
for (int __c = 0; __c < 3; __c++) {    
    int8_t __it = a[__c];
    s += __it;    
} 
\end{code}

To make the \ic{foreach} extension modular, it lives in a separate language
module named \ic{ForeachLanguage}. The new language extends C, since we will
refer to concepts defined in C (see \fig{umldiag}).
 

\todo{make this one more vertical?}
\begin{marginfigure}
  \centering
    \includegraphics[width=60mm]{figures/8/mbeddr/umldiag.png}
    \caption{UML class diagram showing the structure of the
    \ic{ForeachLanguage}. Concepts from the C base language are in white
    boxes, new concepts are grey.} 
  \label{umldiag}
\end{marginfigure}


\phead{Developing the Language Extension}  In the new language, we define
the \ic{ForeachStatement}. To make it usable wherever C expects \ic{Statement}s
(i.e. in functions), \ic{ForeachStatement} extends C's \ic{Statement}.
\ic{ForeachStatement}s have three children (see \fig{umldiag}): an
\ic{Expression} that represents the array, an \ic{Expression} for the array
length, and a \ic{StatementList} for the body.
\ic{Expression} and \ic{StatementList} are both defined in C.

The editor that defines the concrete syntax is shown
in \fig{foreachEditorImage}. It consists of a horizontal list of cells: the
\ic{foreach} keyword, the opening parenthesis, the embedded editor of the
\ic{array} child, the \ic{sized} keyword, the embedded editor of the \ic{len}
expression, the closing parenthesis and the editor of the \ic{body}.

\begin{figure}[h]
\begin{center} 
  \includegraphics[width=85mm]{figures/8/mbeddr/foreachEditor2.png}
\end{center}
\caption{The editor definition of the
\ic{foreach} statement and its relationship to an example
instance.}
\label{foreachEditorImage}
\end{figure}

As shown in the code snippet below, the 
\ic{array} must be of type \ic{ArrayType}, and the type of \ic{len} must be
\ic{int64\_t} or any of its shorter subtypes.
 
\begin{code}
rule typeof_ForeachStatement for ForeachStatement as fes do {
    typeof(fes.len) :<=: <int64_t>; if
    (!(fes.array.type.isInstanceOf(ArrayType))) {
      error "array required" -> fes.array; 
    } 
}
\end{code}
 

The generator translates a \ic{ForeachStatement} to a regular \ic{for} statement
that iterates over the elements with a counter variable \ic{\_\_c}
(\fig{foreachGenerator}). Inside the \ic{for} body, we create a variable
\ic{\_\_it} that refers to the array element at position \ic{\_\_c}. We then
copy in the other statements from the body of the \ic{foreach}. Note that there
is an existing generator for C that outputs C text which is subsequently
compiled.
 
\begin{figure}[h]
\begin{center}  
  \includegraphics[width=110mm]{figures/8/mbeddr/foreachGenerator.png}
\end{center} 
\vspace{-2mm}
\caption{The \ic{foreach} generator template. A \ic{ForeachStatement} is replaced by what is framed \ic{<TF .. TF>}
when the template is executed, the \ic{dummy} function around it just provides
context. The \ic{COPY\_SRC} and
\ic{COPY\_SRCL} macros contain expressions (not shown) that determine 
with what the nodes in square brackets (e.g. \ic{10}, \ic{int8\_t x;}) are
replaced during a transformation.}
\label{foreachGenerator}
\end{figure}


The \ic{ItExpression} extends C's \ic{Expression} to make it usable where
expressions are expected. The editor consists of a single cell with the keyword
\ic{it}. A constraint enforces that the \ic{ItExpression} is only used inside
the body of a \ic{foreach}:

\begin{code}
concepts constraints ItExpression { 
  can be child 
    (context, scope, parentNode, link, childConcept)->boolean { 
      parentNode.ancestor<ForeachStatement, +>.isNotNull && 
      parentNode.ancestor<StatementList, +>.isNotNull;   
    }   
}
\end{code}


The type of \ic{it} must be the base type of the \ic{array} (e.g. \ic{int} in
case of \ic{int{[]}}), as shown in the code below:

\begin{code}
node<Type> basetype = typeof(it.ancestor<ForeachStatement>.array) 
                         as ArrayType.baseType; 
typeof(it) :==: basetype.copy;
\end{code}


The \ic{foreach} generator already generated a local variable
\ic{\_\_it} into the body of the \ic{for} loop. We can thus translate an
\ic{ItExpression} into a \ic{LocalVariableReference} that refers to
\ic{\_\_it}.

The specification of the \ic{foreach} debugger extension resides completely in
the \ic{ForeachLanguage}; this keeps the debugger definition for the extension
local to the extenstion language. 

To set a breakpoint on a concept, it must implement the \ic{IBreakpoint-
Support} marker interface. \ic{Statement} already implements this interface, so
\ic{ForEachStatement} implicitly implements this interface as well.

Stepping behavior is implemented via \ic{ISteppable}.
\ic{ForeachState- ment} implements this interface indirectly via \ic{Statement},
but we have to overwrite the methods that define the step over and step into
behavior. Assume the debugger is suspended on a \ic{foreach} and the user
invokes \emph{step over}. If the array is empty or we have finished iterating
over it, a step over ends up on the statement that follows \emph{after the
whole} \ic{foreach} statement. Otherwise we end up on the first line of the
\ic{foreach} body (\ic{sum += it;})\footnote{This is the first line of the mbeddr
program, \emph{not} the first line of the generated base program (which would be
\ic{int8\_t \_\_it = arr[\_\_c];}).}.

The debugger cannot guess which alternative will occur since it would require to
know the state of the program and to evaluate the expressions in the (generated)
\ic{for}. Instead we set breakpoints \emph{on each of the possible next
statements} and then resume execution until we hit one of them. The
implementations of the \ic{ISteppable} methods specify strategies for setting
breakpoints on these possible next statements. The
\ic{contributeStepOverStrategies} method collects strategies for the \emph{step
over} case:
 
\begin{code}
void contributeStepOverStrategies(list<IDebugStrategy> res) {
   ancestor
   statement list: this.body   
}
\end{code}

The method is implemented using a domain-specific language for debugger
specification, which is part of the mbeddr debugger framework\footnote{This
simplifies the implementation of debuggers significantly. It is another example
of where using DSLs for defining DSLs is a good idea.}. It is an extension of
MPS' \ic{BaseLanguage}, a Java-based language used for expressing behavior in
MPS. The \ic{ancestor} statement delegates to the \ic{foreach}'s ancestor; this
will lead to a breakpoint on the subsequent statement. The second line leads to
a breakpoint on the first statement of the \ic{body} statement list.



Since the \ic{array} and \ic{len} expressions can be arbitrarily complex and may
contain invocations of callables (such as function calls), we have to specify
the \emph{step into} behavior as well. This requires the debugger to inspect the
expression trees in \ic{array} and \ic{len} and find any expression that can be
stepped into. Such expressions implement \ic{IStepIntoable}. If
so, the debugger has to step into each of those, in turn. Otherwise the debugger
falls back to \emph{step over}. An additional method configures the expression
trees which the debugger must inspect:

\begin{code}
void contributeStepIntoStrategies(list<IDebugStrategy> res) { 
  subtree: this.array 
  subtree: this.len     
}
\end{code}
      

By default, the Watch window contains all C symbols (global and local variables,
arguments) as supplied by the native C debugger. In case of the \ic{foreach},
this means that \ic{it} is not available, but \ic{\_\_it} and \ic{\_\_c} are.
This is exactly the wrong way: the watch window should show \ic{it}, but not
\ic{\_\_it} and \ic{\_\_c}. To customize Watches, a concept has to implement
\ic{IWatchProvider}. Here is the code for \ic{foreach}, also expressed in the
debugger definition DSL:

\begin{code}
void contributeWatchables(list<UnmappedVariable> unmapped, 
                                 list<IWatchable> mapped) { 
  hide "__c" 
  map "__it" to "it" 
    type: this.array.type : ArrayType.baseType 
    category: WatchableCategories.LOCAL_VARIABLES 
    context: this    }
\end{code}

The first line hides \ic{\_\_c}. The rest \ic{map}s a base-level C variable to a
Watchable. It finds a C variable named \ic{\_\_it} (inserted by the \ic{foreach}
generator) and creates a watch variable named \ic{it}. At the same time, it
hides the base-level variable \ic{\_\_it}. The type of \ic{it} is the base type
of the array over which we iterate. We assign the \ic{it} Watchable to the local
variables section and associate the \ic{foreach} node with it (double-clicking
on the \ic{it} in the Watches will highlight the \ic{foreach} in the code).


Stepping into the \ic{foreach} body does not affect the call stack, since the
concept represents no callable (details see \sect{archspec}). So we do not have
to implement any stack frame related functionality.


\phead{Debugger Framework Architecture} The central idea of the debugger
architecture is this: from the C code in MPS and its extensions (tree-level) we
generate C text (text-level). This text is the basis for the debugging process
by a native C debugger. We then use trace data to find out how the generated
text maps back to the tree-level in MPS (R4).

At the core of the execution architecture is the \ic{Mapper}. It is driven by
the \ic{Debugger UI} (and through it, the user) and controls the C debugger via
the \ic{Debug Wrapper}. It uses the \ic{Program Structure} and the \ic{Trace
Data}. The \ic{Mapper} also uses a language's debug specification, discuss in
the next subsection. \fig{components} shows the components and their interfaces.

\begin{figure}[h]
  \centering
    \includegraphics[width=85mm]{figures/8/mbeddr/components.png} \caption{The
    \ic{Mapper} is the central component of the debugger execution architecture.
    It is used by the \ic{Debugger UI} and, in turn, uses the
    \ic{Debug Wrapper}, the \ic{Program Structure} and the \ic{Trace Data}.}
  \label{components}
\end{figure}   

The \ic{IDebugControl} interface is used by the \ic{Debugger UI} to
control the \ic{Mapper}. For example, it provides a \ic{resume} operation.
\ic{IBreakpoints} allows the UI to set breakpoints on program nodes.
\ic{IWatches} lets the UI retrieve the data items for the Watch window. The
\ic{Debug Wrapper} essentially provides the same interfaces, but on the level of
C (prefixed with \ic{LL}, for "low level"). In addition, \ic{ILLDebugControl}
lets the \ic{Mapper} find out about the program location of the \ic{C Debugger}
when it is suspended at a breakpoint. \ic{IASTAccess} lets the \ic{Mapper}
access program nodes. Finally, \ic{ITraceAccess} lets the
\ic{Mapper} find out the program node (tree-level) that corresponds to a
specific line in the generated C source text (text-level), and vice versa.

To illustrate the interactions of these components, we describe a \emph{step
over}. After the request has been handed over from the UI to the \ic{Mapper} via
\ic{IDebugControl}, the \ic{Mapper} performs the following steps:
 
\vspace{-1mm}
\begin{itemize}
  \item Ask the current node's concept for its \emph{step over} strategies;
  these define all possible locations where the debugger could end up after 
  the \emph{step over}.
  \vspace{-2mm}
  \item Query \ic{TraceData} for the corresponding lines in the generated C
  text for those program locations.  
  \vspace{-2mm}
  \item Use the debugger's \ic{ILLBreakpoints} to set breakpoints
  on those lines in the C text.
  \vspace{-2mm}
  \item Use \ic{ILLDebugControl} to resume program execution. It will 
  stop at any of the just created breakpoints.
  \vspace{-2mm}
  \item Use \ic{ILLDebugControl} to get the C call stack.
  \vspace{-2mm}
  \item Query \ic{TraceData} to find out for each C stack frame the 
  corresponding nodes in the tree-level program.
  \vspace{-2mm}
  \item Collect all relevant \ic{IStackFrameContributor}s (see next
  section). The \ic{Mapper} uses them to construct the tree-level
  call stack.
  \vspace{-2mm}
  \item Get the currently visible symbols and their values via
  \ic{ILLWatch- ables}.
  \vspace{-2mm}
  \item Query the nodes for all \ic{WatchableProvider}s and use them 
  to create a set of Watchables.
\end{itemize}

\noindent At this point, execution returns to the \ic{Debugger UI}, which then
gets the current location and Watchables from the \ic{Mapper} to highlight
the statement on which the debugger is suspended and populate the watch window.

In our implementation, the \ic{Debugger UI}, \ic{Program Repository} and
\ic{Trace Data} are provided by MPS. In particular, MPS builds a trace from the
program nodes (tree-level) in MPS to the generated text-level source. The
\ic{Debug Wrapper} is part of mbeddr and relies on the Eclipse CDT Debug Bridge
(\footnote{www.eclipse.org/cdt/}), which provides a Java API to \ic{gdb}
(\footnote{www.gnu.org/software/gdb/documentation/}) and other C debuggers.



\phead{Debugger Specification} The debugger specification reside in the
respective language module. As we have seen in the \ic{foreach} example, the
specification relies on a set of interfaces, a number of predefined strategies
as well as the debugger specification DSL. 

The interface \ic{IBreakpointSupport} is used to mark language concepts on which
breakpoints can be set. C's \ic{Statement} implements this interface. Since all
statements inherit from \ic{Statement} we can set breakpoints on all statements
by default.

When the user sets a breakpoint on a program node, the mapper uses
\ic{ITraceAccess} to find the corresponding line in the generated C text. A
statement defined by an extension may be expanded to several base-level
statements, so \ic{ITraceAccess} actually returns a range of lines, the
breakpoint is set on the first one.

Stack Frames represent the nesting of invoked callables at runtime\footnote{A
\emph{callable} is a language concept that contains statements and can be called
from multiple call sites.}. We create stack frames for a language concept if it
has callable semantics. The only callables in C are functions, but in mbeddr,
test cases, state machine transitions and component methods are callables as
well. Callable semantics on extension-level does not necessarily imply a
function call on the base-level. There are cases where an extension-level
callable is \emph{not} mapped to a function and where a non-callable \emph{is}
mapped to a function. Consequently, the C call stack may differ from the
extension call stack shown to the user. Concepts with callable semantics on the
extension-level or base-level implement \ic{IStackFrame- Contributor}. The
interface provides operations that determine whether a stack frame has to be
created in the debugger UI and what the name of this stack frame should be.

Stepping behavior is configured via the following interfaces:
\ic{IStack- FrameContributor}, \ic{ISteppable}, \ic{ISteppableContext} 
\ic{IStepIntoable} and \ic{IDebugStrategy}. \fig{stepping} shows an overview.  

\todo{make more vertical}
\begin{marginfigure}
  \centering
    \includegraphics[width=60mm]{figures/8/mbeddr/stepping.png}
    \caption{Structure of language concepts implementing the
    stepping-related interfaces. The boxes represent language concepts
    implementing the interfaces discussed in the text. Those concepts
    define the containments, so this figure represents a typical
    setup.}
  \label{stepping} 
\end{marginfigure}



The methods defined by these interfaces return \emph{strategies} that determine
where the debugger may have to stop next if the user selects a stepping
operation (remember that the debugger framework sets breakpoints to implement
stepping). New strategies can be added without changing the generic execution
aspect of the framework.

Stepping relies on \ic{ISteppable} contributing \emph{step over} and
\emph{step into} strategies. Many \ic{ISteppable}s are embedded in an
\ic{ISteppableContext} (e.g. \ic{Statement}s in \ic{StatementList}s).
Strategies may delegate to the containing \ic{ISteppableContext} to determine
where to stop next (the \ic{ancestor} strategy in the \ic{foreach} example).
 
For \emph{step into} behavior, an \ic{ISteppable} specifies those subtrees in
which instances of \ic{IStepIntoable} may be located (the \ic{array} and
\ic{len} expressions in the \ic{foreach} case). The debugger searches these
subtrees at debug-time and collects all instances of \ic{IStepIntoable}. An
\ic{IStepIntoable} represents a callable invocation (\eg a \ic{FunctionCall}),
and the returned strategies suspend the debugger within the callable.
 

\emph{Step out} behavior is provided by implementors of
\ic{IStackFrameCon- tributor} (mentioned earlier). Since a callable can be
called from many program locations, the call site for a particular invocation cannot be
determined by inspecting the program structure; a call stack is needed. We use
the ordered list of \ic{IStackFrameContributor}s, from which the tree-level call
stack is derived, to realize the \emph{step out} behavior.
By "going back" (or ``out") in the stack, the call site for the current
invocation is determined. For \emph{step out}, the debugger locates the
enclosing \ic{IStackFrameContributor} and asks it for its \emph{step out}
strategies.

 
Strategies implement \ic{IDebugStrategy} and are responsible for setting
breakpoints to implement a particular stepping behavior.
Language extensions can either implement their own strategies or use predefined
ones. Those include: setting a breakpoint on a particular node; searching for
\ic{IStepIntoables} in expression subtrees (step into) or delegating to the
outer stack frame (step out).



For supporting \emph{Watches}, language concepts implement \ic{IWatchPro- vider}
if they directly contribute one or more items into the Watch window. An
\ic{IWatchProviderContext} contains zero or more watch providers. Typically
these are concepts that own statement lists, such as \ic{Function}s or
\ic{IfStatement}s. If the debugger is suspended on any particular statement, we
can find all visible watches by iterating through all ancestor
\ic{IWatchProviderContext}s and asking them for their \ic{IWatchProvider}s.
\fig{watches} shows the typical structure of the concepts.

\todo{more vertical}
\begin{marginfigure}
  \centering
    \includegraphics[width=60mm]{figures/8/mbeddr/watches.png}
    \caption{Typical structure of language concepts implementing the
    Watches-related interfaces} 
  \label{watches}  
\end{marginfigure}

\An \ic{IWatchProvider} implements the \ic{contributeWatch- ables}
operation. It has access to the C variables available in the native C debugger.
Based on those, it creates a set of Watchables. The method may hide a base-level
C variable (because it is irrelevant to the extension-level), promote C
variable to a Watchable or create additional Watchables based on the values of C
variables. The representation of a Watchable often depends on the variable's
type \emph{as expressed in the extension program}. This type may be different
from the one in the C program. For example, we represent values of type
\ic{Boolean} with \emph{true} and \emph{false}, even though they are represented
as \ic{int}s in C. As the Watchable is created, we specify the type that should
be used. Types that should be used in this way must implement
\ic{IMappableType}. Its method \ic{mapVariable} is responsible for computing a
type-appropriate representation of a value.



\phead{More Examples} To illustrate our approach further, we have
implemented the debugging behavior for mbeddr C and all default extensions. We
discuss some interesting cases in this section.


We encounter many cases where we cannot know statically which piece of code will
be executed when \emph{stepping into} a callable. Consider polymorphic calls on
interfaces.

The mbeddr components extension provides interfaces with operations, as well as
components that \ic{provide} and \ic{use} these interfaces. The component
methods that implement interface operations are generated to base-level C
functions. The same interface can be implemented by \emph{different} components,
each implementation ending up in a \emph{different} C function. A client
component only specifies the \emph{interface} it uses, not the component. Hence,
we cannot know statically which C function will be called if an operation is
invoked on the interface. However, we do know statically all components that
implement the interface, so we know \emph{all possible C functions} that may be
invoked. A strategy implemented specifically for this case sets
breakpoints on the first line \emph{of all of these functions} to
make sure we stop in the first line of any of them if the user \emph{steps into}
a method invocation\footnote{We encounter a similar challenge in state machines: as an event is fired into
a state machine, we do not know which transition will be triggered. 
Consequently we set breakpoints in all transitions (translated to
\ic{case} branches in a \ic{switch} statement) of the state machine.}. 




In many cases a single statement on the extension-level is mapped to several
statements or whole blocks on the base-level. \emph{Stepping over} the single
extension-level statement must step over the whole block or list of statements
in terms of C. An example is the \ic{assert} statement used in test cases. It is
mapped to an \ic{if} statement. The debugger has to step over the complete
\ic{if} statement, independent of whether the condition in the \ic{if} evaluates
to \ic{true} or \ic{false}. Note that we get this behavior for free\footnote{Remember
that we never actually step over statements, we always set breakpoints at those
next possible code locations where the debugger may have to stop next.}:
the \ic{assert} statement sets a breakpoint on the base-level counterpart of the
\emph{next tree-level statement}. It is irrelevant how many lines of C text
further down this is.


An extension can provide language concepts with callable semantics that are not
translated to a C function. In case a user \emph{steps into} one of those
concepts, the debugger has to create a stack frame on the tree-level call stack,
although there is no corresponding stack frame on the C call stack. An example
is triggering a transition in the state machine extension\footnote{Triggering
has callable semantics, as in "we are \emph{in} the transition".}, which should
cause the debugger to create a tree-level stack frame even though a transition
is mapped on an \ic{if} statement, not to a C function call. To achieve this,
the \ic{Transition} implements \ic{IStackFrameContributor} and returns \ic{true}
from \ic{isExtStackFrame}. Its \ic{getStackFrameName} is shown below: the
tree-level stack frame has the name of the \ic{event} that triggered the
transition and the name of the owning \ic{state}.

\begin{code}
public string getStackFrameName() {
  this.ancestor<State>.name+" - "+this.trigger.event.name; }
\end{code}


The code snippet below shows a testing scenario with three stack frame
contributors: a function \ic{main}, two test cases, and an
\ic{executeTests} expression: 

\begin{code}
int32_t main() {
  return executeTests testIntRandom, testRealRandom; 
}

test case testIntRandom { 
  assert randomInt() != randomInt(); 
}

test case testRealRandom { 
  assert randomReal() != randomReal(); 
}
\end{code}

\noindent The \ic{main} function remains a function in generated C. The test case is
mapped to a function as well, and it is possible to step into test cases. So
these two have callable semantics \emph{and} are mapped to functions. 
The \ic{executeTests} expression is \emph{also} mapped to a function (which
invokes tests and sums up the number of failures) but it does \emph{not} have
callable semantics: the generated function is invisible to the user.
Since all of them are mapped to functions, they implement the
\ic{IStackFrameContributor} interface. \ic{isExtStackFrame} returns
\ic{true} for concepts with callable semantics (function and test case), but it
returns \ic{false} for the \ic{ExecuteTestExpression}. \ic{getStackFrameName}
for the function and the test case returns the name of the respective node
(\ic{this.name}); it returns \ic{null} for the \ic{ExecuteTestExpression}. This
way the debugger creates tree-level stack frames for called \ic{functions}
and \ic{test cases} with their respective name. The following snippet shows the
implementation for \ic{functions}:

\begin{code}
string getStackFrameName() { 
  return this.name; 
}

boolean isExtStackFrame() { 
  true; 
}

void contributeStepOutStrategies(list<IDebugStrategy> res) {
  if (name.equals("main")) new ResumeWithoutBreakpoint();
  else new StepToOuter(this); 
}
\end{code}

\noindent For stepping out, we use the \ic{StepToOuter} strategy which
suspends the execution within the outer stack frame contributor. In C, the
\ic{main} function is called directly by the debugger, so there is no outer
frame. We use \ic{ResumeWithoutBreakpoint} in this case.

In contrast, the \ic{ExecuteTestExpression} (which is also generated into a
function) uses a \ic{DelegateToOuter} to delegate the request to its outer stack
frame contributor, i.e. a \ic{Function}. We must delegate the request, since an
\ic{ExecuteTestExpression} has no callable semantics and does therefore not know
where the execution should be suspended after a \ic{step out}. The following
code shows the \ic{createBreakpoint} implementation of the custom strategy used
in this case:

\begin{code}
void configure(IStrategyConfiguration strategyConfiguration) { 
  this.dslStackMapping = conf.getDSLStackMapping(); 
  this.strategyConfiguration = strategyConfiguration; 
}

void createBreakpoint() throws Exception {
  list<IDebugStrategy> res = new arraylist<IDebugStrategy>();
  node<IStackFrameContributor> outerContributor =
            getOuterContributor(this, dslStackMapping);
  outerContributor.contributeStepOutStrategies(res); 
  foreach strategy in res {
    strategy.configure(strategyConfiguration); 
    strategy.createBreakpoint(); 
  } 
}
\end{code}
 
\noindent Going back to the example, consider the debugger is suspended in the
\emph{testIntRandom} test case: the tree-level call stack contains
\emph{testIntRandom} on top of \emph{main}. In contrast, the C call stack has
another stack frame for the function generated from the
\ic{ExecuteTestExpression} between the two tree-level stack frames. A \ic{step
out} suspends the debugger in this function. However, the user expects to get
back to \ic{main} so we have to show the call stack to just contain the \ic{main}
function. The framework hides the stack frame for \ic{ExecuteTestExpression},
since its \emph{isExtStackFrame} implementation returns \ic{false}. We can now
perform a \ic{step into} which causes the debugger to suspend in
\emph{testRealRandom} 


Extensions may provide custom data types that are mapped to one or more data
types or structures in the generated C. The debugger has to reconstruct the
representation in terms of the extension from the base level data. For example,
the state of a component is represented by a \ic{struct} that has a member for
each of the component fields. Component operations are mapped to C functions. In
addition to the formal arguments declared for the respective operation, the
generated C function also takes this \ic{struct} as an argument.
However, to support the polymorphic invocations discussed earlier, the type of
this argument is \ic{void*}. Inside the operation, the \ic{void*} is cast down
to allow access to the component-specific members. The debugger performs the
same downcast to be able to show Watchables for all component fields.


\phead{Discussion} To evaluate the suitability of our solution for our purposes,
we revisit the requirements described earlier.

\begin{description}
\item[Modularity] Our solution requires no changes to the base language
or its debugger implementation to specify the debugger for an extension.
Also, independently developed extensions retain their independence if
they contain debugger specifications\footnote{In particular, MPS' capability of
incrementally including language extensions in a program \emph{without defining
a composite language first} is preserved in the face of debugger specifications.}. 

\item[Framework Genericity] The extension-dependent
aspects of the debugger behavior are extensible. In particular, stepping
behavior is factored into strategies, and new strategies can be implemented by a
language extension. Also, the representation of Watch values can be customized
by making the respective type implement \ic{IMappableType} in a suitable way.

\item[Simple Debugger Definition] This challenge is solved by the
debugger definition DSL. It supports the definition of stepping behavior and
watches in a declarative way, without concerning the user with implementation
details of the framework or the debugger backend.

\item[Limited Overhead] Our solution generates no
debugger specific code at all (except the debug symbols added by compiling the C
code with debug options). Instead we rely on trace data to map the
extension-level to base-level and ultimately to text. This is a trade-off:
first, the language workbench must be able to provide trace information. Second,
the generated C text cannot be modified by a text processor before it is
compiled and debugged, since this would invalidate the trace data\footnote{The
C preprocessor works, it is handled correctly by the compiler and debugger} .
Our approach has another advantage: we do not have to change existing
transformations to generate debugger-specific code. This keeps the
transformations independent of the debugger.

\item[Debugger Backend Independence] We use the Eclipse CDT Debug Bridge to wrap
the particular C debugger, so we can use any compatible debugger without
changing our infrastructure. Our approach requires no changes to the native C
debugger itself, but since we use breakpoints for stepping, the debugger must be
able to handle a reasonable number of breakpoints\footnote{Most C debuggers
support this, so this is not a serious limitation.}. The debugger also has to
provide an API for setting and deleting breakpoints, for querying the currently
visible symbols and their values, as well as for querying the code location
where the debugger suspended.
\end{description}




\subsection{What's Missing?}

The support from language workbenches for building debuggers for the DSLs
defined with the language workbench is not where it should be. Especially in the
face of extensible languages or language composition, the construction of
debuggers is still a lot of work. The example discussed in \sect{mbeddrex} is
\emph{not} part of MPS in general, but instead a framework that has been built
specifically for mbeddr --- although we believe that the architecture can be
reused more generally.


Also, ideally, programs should be debuggable at any abstraction level: if a
multi-step transformation is used, then users should be able to debug the
program at any intermediate step. Debug support for for Xbase-based DSLs is
a good example for this; but it is only one translation step, and it is a
solution that is specifically constructed for Xbase and Java, and not a generic
framework.

So there is a lot of room for innovation in this space.