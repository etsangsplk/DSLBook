\chapter{Debugging DSLs}    

Debugging is relevant in two ways in the context of DSLs and language
workbenches. First, the DSL developer may want to debug the definition of a DSL,
including constraints, scopes or transformations and interpreters. Second,
programs written in the DSL may have to be debuggable by the end user. We
address both aspects in this chapter.

\section{Debugging the DSL Definition}

\todo{Write something here}

\subsection{Understanding and Debugging the Language Structure}

In parser-based systems, the transformation from text to the AST performed by
the parser\footnote{... and the lexer, if there is one ...} is itself a
non-trivial process and has a potential for errors. Debugging the parsing
process can be important.

\parhead{Xtext} Xtext uses ANTLR\footnote{http://antlr.org} under the hood. In
other words, from the Xtext grammar, an ANTLR grammar is generated which
performs the actual parsing. So understanding and debugging the Xtext parsing
process means understanding and debugging the ANTLR parsing process.

There are two ways to do this. First, since ANTLR generates a Java-based parser,
you can debug the execution of ANTLR (as part of Xtext) itself. Second, you
can have Xtext generate a debug grammar, which contains no action code (so it
does not populate the AST). However, it can be used to debug the parsing process
with ANTLRWorks\footnote{http://www.antlr.org/works}. ANTLRWorks comes with an
interactive debugger for ANTLR grammars.

\parhead{MPS} In MPS there is no transformation from text to the AST since it is
a projectional editor. However, there are still means to help better
understand the structure of an existing program. For example, any program
element can be inspected in the \emph{Explorer}. \fig{mps-explorer} shows the
information for a trivial C function:

\begin{code}
int8_t add(int8_t x, int8_t y) { 
  return x + y; 
} 
\end{code}


\begin{figure}[h]
\begin{center}
  \includegraphics[width=8cm]{figures/8/mps-explorer.png}
  \caption[]{The MPS explorer shows the structure of a program as a tree.
  The explorer also shows the concept for each program element as well as the
  type, if an element has one.}
  \label{mps-explorer} 
\end{center} 
\end{figure}

MPS provides similar support for understanding the projection rules. For any
program node MPS can show the cell structure as a tree. The tree contains
detailed information about the cell hierarchy, the program element associated
with each cell as well as the properties of the cell (height, width, etc.).

\todo{handle the noindent correctly all over the book}

\subsection{Debugging Scopes, Constraints and Type Systems}

Depending on the level of sophistication of a particular language, a lot of
non-trivial behavior can be contained in the code that determines scopes, checks
constraints or computes types. In fact, in many languages, these are the most
sophisticated aspects of language definition. Consequently, there is a need
for debugging those.

\parhead{Xtext} In Xtext, all aspects of a language except the grammar and the
abstract syntax are defined via Java programs using Xtext APIs. This includes
scopes, constraints and type system rules\footnote{It also includes all IDE
aspects.}. Consequently, all these aspects can be debugged by using a Java
debugger. To do this, you can simply launch the Eclipse Application that
contains the language and editor in debug mode and set breakpoints at the
relevant locations\footnote{It is easy to criticize Xtext for the fact that it
does not use DSLs for defining DSLs. However, in the context of debugging this
is good, because no special debuggers are necessary.}.

\parhead{MPS} MPS comes with an equivalent facility in the sense that a second
instance of MPS can be launched that runs "inside" the current one. This inner
instance can be debugged from the outside one. This approach can be used for all
those aspects of MPS-defined languages that are defined in terms of the
BaseLanguage, MPS' version of Java. For example, scopes can be debugged this
way. For example, in \fig{mps-mps-debug} we debug the scope for a
\ic{LocalVariableRef}.


\begin{figure*}[h]
  \includegraphics[width=17cm]{figures/8/mps-mps-debug.png}
  \caption[]{The debugger that can debug MPS while it "executes" a language is
  aware of all the relevant extensions to BaseLanguage. For example, in this
  screenshot we debug a scope constraint. Notice how in the \ic{Variables} view
  program nodes (such as the \ic{Statement s}) are shown on the abstraction
  level of the node, not in terms of its underlying Java data structure
  representation.}
  \label{mps-mps-debug} 
\end{figure*}


A related feature of MPS is the ability to analyze exception stack traces. MPS
generates Java code from language definitions and then executes this Java code.
If an exception occurs in language implementation code, this exception produces
a Java stack trace. This stack trace can be pasted into a dialog in MPS. MPS
then produces a version of the stack trace where the code locations in the stack
trace (which are relative to the generated Java) have been translated to
locations in the DSL definition (expressed in Base Language). The locations can
be clicked directly, opening the MPS editor at the respective location.

In the design chapter \todo{ref} we discussed how declarative languages may come
with a debugger that fits the particular declarative paradigm used by a
particular declarative language. MPS comes with two facilities. First, pressing
\ic{Ctrl-Shift-T} on any program element will open a dialog that shows the type
of the element. If the element has a type system error, that dialog also lets
the user navigate to the rule that reported the error. The second facility is
much more sophisticated. For any program node, MPS can show the so-called type
system trace (\fig{mps-ts-trace} shows a simple example). Remember how the MPS
type system is relies on a solver to solve the type system equations associated
with program elements (specified by the language developer for the respective
concepts). So each program has an associated set of type system equations.
Those contain explicitly specified types as well as type variables. The solver
tries to find type values for these variables such that all type system
equations become true. The type system trace essentially visualizes the state of
the solver including the values it assigns to type variables as well as which
type system rules are applied to which program element.

\begin{figure}[h]
  \includegraphics[width=11cm]{figures/8/mps-ts-trace.png} 
  \caption[][-20mm]{This
  example shows the solver state for the \ic{Argument x}. It first applies the
  rule \ic{typeof\_ITyped} (\ic{Argument} implements \ic{ITyped}) which
  expresses that the type of the element (type variable
  \ic{c} is the same as the element's \ic{type} property (type variable \ic{d}).
  It then applies the \ic{typeof\_Type} rule to the argument's type itself. This
  rule expresses that the type of a \ic{Type} is a clone of itself.
  Consequently, the type variable \ic{d} can be set to \ic{int8\_t}. In
  consequence this means that the type variable \ic{c} (which represents the
  type of the \ic{Argument}) is also \ic{int8\_t}. Note that this is a trivial
  example. Type system traces can become quite involved.}
  \label{mps-ts-trace} 
\end{figure}


\subsection{Debugging Interpreters and Transformations}

Debugging an interpreter is simple: since an interpreter is just a program
written in some programming language that processes and acts on the DSL program,
debugging the interpreter simply uses the debugger for the language in which the
interpreter is written\footnote{This assumes that the interpreter is written in
a programming language for which a debugger exists}. 

Debugging transformations and generators is typically not quite as trivial, for
two reasons. First, transformations and generators are typically written in DSLs
optimized for this task. So a specialized debugger is required. Second, if
multi-step transformations are used, the intermediate models may have to be
accessible, and it should be possible to trace a particular element through the
multi-step transformation.

\parhead{Xtext} As we have said before, Xtext can be used together with any
EMF-compatible code generator or transformation engine. However, since Xtext
ships with Xtend, we look at debugging Xtend transformations. Model-to-model
transformations and code generators in Xtend look very similar: both use Xtend
to navigate over and query the model, based on the AST. The difference is that,
as a side effect, model-to-model transformations create new model elements and
code generators create strings --- typically using the rich strings (aka
template expressions). 
 
Xtend supports debugging either on the level of the generated code, or on the
Xtend source level. As \fig{templatesdebugging} shows, even the template
expressions can be debugged. The Variables view shows the EMF representation
(i.e. the implementation) of program elements. 
 
\begin{figure*}[h]
  \includegraphics[width=17cm]{figures/8/xtext-templatesdebugging.png} 
  \caption[][-20mm]{}
  \label{templatesdebugging} 
\end{figure*}

Xtend is a fundamentally an imperative/OO language, so the step-through metaphor
for debuggers is appropriate. If Xtend is used for code generation or
transformation, debugging a boils down to stepping through the code that builds
the target model. I emphasize this because the next example uses a different
appraoch.


\parhead{MPS} In MPS, working with several chained transformations is normal, so
MPS provides support for debugging the transformation process. This support
includes two ingredients. The first one is showing the mapping partitioning. For
a given model, MPS computes the order in which transformations apply and reports
it to the user. This is useful to understand which transformations are executed
in which order\footnote{... and to debug transformation priorities!}. Let us
investigate a simple example C program that contains a message definition and a
\ic{report} statement. The \ic{report} statement is transformed to \ic{printf}
statements.

\begin{code}
module Simple imports nothing { 
   
  message list messages { 
    INFO aMessage() active: something happened 
  } 
   
  exported int32_t main(int32_t argc, int8_t*[] argv) { 
    report(0) messages.aMessage() on/if; 
    return 0; 
  } 
}
\end{code}

Below is the mapping configuration for this program: 

\begin{code}
[ 1 ]
com.mbeddr.core.modules.gen.generator.template.main.removeCommentedCode
[ 2 ]
com.mbeddr.core.util.generator.template.main.reportingPrintf
[ 3 ]
com.mbeddr.core.buildconfig.generator.template.main.desktop
com.mbeddr.core.modules.gen.generator.template.main.main
\end{code}

This particular model is generated in three phases. The first one removes
commented code to make sure it does not show up in the resulting C text file.
The second phase runs the generator that transforms \ic{report} statements into
\ic{printf}s. Finally, the \ic{desktop} generator generates a \ic{make} file
from the build configuration, and the last step generates the C text from the C
tree.

By default, MPS runs all generators until everything is either discarded or
transformed into text. While intermediate models exist, they are not shown to
the user. For debugging purposes though, these intermediate, transient models
can be kept around for inspection. Each of the phases is represented by one or
more transient models. As an example, here is the program after the \ic{report}
statement has been transformed:

\begin{code}
module Simple imports nothing { 

  exported int32_t main(int32_t argc, int8_t*[] argv) { 
    printf("$$ aMessage: something happened "); 
    printf("@ Simple:main:0#240337946125104144 \n "); 
    return 0;
  } 
} 
\end{code}

MPS also supports tracing an element through the intermediate models.
\fig{mps-tracer} shows an example. Users can select a program element in the
source, target or an intermediate model and trace it to the respective other
ends of the transformation.

\begin{figure*}[h]
  \includegraphics[width=18cm]{figures/8/mps-tracer.png}
  \caption[]{The generation trace functionality in MPS allows users to trace
  how a particular program element is transformed through a chain of
  transformations. The generation tracer also shows the transformation rules
  involved in the transformation.}
  \label{mps-tracer} 
\end{figure*}

Note how this approach to debugging transformations is very different from the
Xtend example above: instead of stepping through the transformation
code\footnote{As part of the general Debug-MPS-in-MPS functionality, MPS
transformations can also be debugged in a more imperative fashion. This is
useful, for example, to debug more complex logic used inside transformation
templates.}, MPS provides a \emph{static} representation of the transformation
in terms of the intermediate models and the element traces through them.


\section{Debugging DSL Programs}

To find errors in DSL programs, we can either debug them on the level of the DSL
program or in its $L_{D-1}$ representation (i.e. in the generated code or the
interpreter). Debugging on $L_{D-1}$ is useful if you want to find problems in
the execution engine, or, to some extent, if the language users are programmers
and they have an intimate understanding of the $L_{D-1}$ representation of the
program. However, for many DSLs it is necessary to debug on the level of the DSL
program either because the users are not familiar with the $L_{D-1}$
representation\footnote{This is true particularly for DSLs qtargeted at domain
experts, }, or because the $L_{D-1}$ is so low-level and complex that is bears
no obvious resemblance to the DSL program.


The way to build debuggers for DSLs of course depends on the DSL itself. For
example, for DSLs that only describe structures, debugging does not make much
sense in the first place. For DSLs that describe behavior, the debugging
approach depends on the behavioral paradigm used in the DSL. We have discussed
this in \todo{ref}. In this section we focus mostly on the imperative
paradigm\footnote{An examples for the functional paradigm has been provided in
\todo{ref}, and the type system tracer described above is an example of a
debugger for a declarative language.}.

Building a debugger poses two challenges. The first one is the debugger UI:
creating all the buttons and views for controlling the debugger and for showing
variables and treads. The second challenge concerns the control of and
data exchange with the to-be-debugged program. The first challenge is relatively
simple to solve, since many IDE frameworks (including Eclipse and MPS) already
come with debugger frameworks. 

The second challenge can be a bit more tricky. If the DSL is executed by an
interpreter, the situation is simple: the interpreter can be run and controlled
directly from the debugger. It is easy to implement single-stepping and variable
watches, for example, since the interpreter can directly provide the respective
interfaces\footnote{This is especially true if the interpreter is written in the
same language as the IDE --- no language integration issues have to be addressed
in this case.}. On the other hand, if the DSL program is transformed into code
that is executed in some other environment outside of our control, it may even
be impossible to build a debugger because there is no way to influence and
inspect the running program. Alternatively, it may be necessary to build a
variant of the code generator which generates a \emph{debug version} of the
program which contains specialized code to interact with the debugger. For
example, values of variables may be stored in a special data structure
inspectable by the debugger, and at each program location where the program may
have to stop (in single step mode or as a consequence of a breakpoint) code is
inserted that explicitly suspends the execution of the program, for example by
\ic{sleep}ing the current thread. However, such an approach is often limited and
ugly --- in the end, an execution infrastructure must provide debug support to
enable robust debugging.



\subsection{Print Statements --- a Poor Man's Debugger}

As the above discussion suggests, building full-blown debuggers may be a lot of
work. It is worth exploring whether a simpler approach is good enough. The
simplest such approach is to extend the DSL with language concepts that simply
print interesting aspects of the executing program to the console or a log file.
For example, the values of variables may be output this way.

The mbeddr \ic{report} statement is an example of this approach. A \ic{report}
statement takes a message text plus a set of variables. It then outputs the
message and the values of these variables. The target of the report statement
can be changed. By default, it reports to the console. However, since certain
target devices may not have any console, alternative transformations can be
defined for report statements, that, for example, could output the data to an
error memory or a serial line. A particularly interesting feature of \ic{report}
statements is that the transformation that handles them knows where in the
program the \ic{report} statement is located. It can add this information to the
output\footnote{The go-to-error-location functionality discussed in
\fig{analyzeErrorOutput} is based on this appraoch.}.

An approach based on print \emph{statements} is sometimes clumsy because it
requires factoring out the to-be-printed expression. And it only works for an
imperative language in the first place. For languages that make use of
sophisticated expressions, a different approach is recommended. Consider the
following example:

\begin{code}
Collection[Type] argTypes = aClass.operations.arguments.type;
\end{code}

If you wanted to print the list of operations and arguments, you would have to
change the program to something like this:

\begin{code}
print("operations: " + aClass.operations);
print("arguments: " + aClass.operations.arguments);
Collection[Type] argTypes = aClass.operations.arguments.type;
\end{code}

A much simpler alternative uses \emph{inlined} reporting expressions:


\begin{code}
Collection[Type] argTypes = aClass.operations.print("operations:")
                            .arguments.print("arguments:").type;
\end{code}
 
To make this convenient to use, the \ic{print} function has to return the object
it is called on (the one before the dot), and it must be typed accordingly if a
language with static type checking is used\footnote{The original
openArchitectureWare Xtend did it this way.}.


\subsection{Automatic Program Tracing}

As languages and programs become more complex, an automated tracing of program
execution may be useful. In this approach, all execution steps in a program are
automatically traced and logged into a tree-like data structure. The
refrigerator cooling language uses this approach. Here is an example program:

\begin{code}
cooling program HelloWorld {
    var temp: int
    start:
        entry { state s1 }  
    state s1: 
        check temp < 10 { state s2 }
    state s2: 
}
\end{code} 

Upon startup, it enters the \ic{start} state and immediately transitions to
state \ic{s1}. It remains in \ic{s1} until the variable \ic{temp} becomes less
than 10. It then transitions to \ic{s2}. Below is a test for this program that
verifies this behavior:

\begin{code}
test HelloWorldTest for HelloWorld {
    prolog {
        set temp = 30
    }
    step
    assert-currentstate-is s1
    step
    mock: set temp = 5
    step
    assert-currentstate-is s2
}
\end{code}

\fig{interpreterlog} shows the execution trace. It shows the execution of each
statement and the evaluation of each expression. The log viewer is a table tree
so the various execution steps can be selectively expanded and collapsed. To
connect to the program, users can double-click on an entry to select the
respective program element in the source node. By adding special comments to the
source, the log can be structured further.

\begin{figure}[h]
  \includegraphics[width=11cm]{figures/8/interpreterlog.png}
  \caption[]{The log viewer represents a program's execution as a tree. The
  first column contains a timestamp and the tree nesting structure. The second
  column contains the kind (severity) of the log message. A filter can be used
  to show only messages above a certain severity. The third column shows the
  language concept with which the trace step is associated (double-clicking on
  a row selects this element in the editor). Finally, the last column contains
  the information about the semantic action that was performed in the
  respective step.}
  \label{interpreterlog} 
\end{figure}

The execution engine for the programs is an interpreter, which makes it
particularly simple to collect the trace data. All interpreter methods that
execute statements or evaluate expressions take a \ic{LogEntry} object as an
additional argument. The methods then add children to the current \ic{LogEntry}
that describe whatever the method did, and then passes the child to any other
interpreter methods it calls. As an example, here is the implementation of the
\ic{AssignmentStatement}:

\begin{code}
protected void executeAssignmentStatement(AssignmentStatement s, LogEntry log) {
    LogEntry c = log.child(Kind.info, context, "executing AssignmentStatement" ); 
    Object l = s.getLeft();
    Object r = eval(s.getRight(), c);
    eec().environment.put(symbol, r);
    c.child(Kind.debug, context, "setting " + symbol.getName() + " to " + r);
}
\end{code}

If instead of an interpreter a code generator were used, the same approach could
essentially be used. Instead of embedding the tracing code in the interpreter,
the code generator would generate code that would build the respective trace
data structure in the executing program. Upon termination, the data structure
could be dumped to an XML file and subsequently loaded by the IDE for
inspection.



\subsection{Simulation as an Approximation for Debugging}

The interpreter for the Cooling programs mentioned above is of course not the
final execution engine --- C code is generated that is executed on the actual
target refrigerator hardware. However, as we have discussed in the design part
of the book (\todo{ref}), we can make sure the generated code and the
interpreter are semantically identical by running a sufficient (large) number of
tests. If we do this, we can use the interpreter to test the programs for
logical errors. The interpreter can also be used interactively, in which case it
acts as a simulator for the executing program. \fig{simulator} shows a
screenshot of a running program. 

If you look at \fig{simulator} closely, you will see that it shows all variables
in the program, the events in the queue, running tasks as well as the values of
properties of hardware elements and the current state. It also provides a button
to single-step the program, to run it continuously, and until it hits a
breakpoint. In other words, although the simulator does not use the
familiar\footnote{... familiar to programmers, but not to the target audience!}
UI of a debugger, it actually is a debugger\footnote{As we have said above,
the fact that it runs in the interpreter instead of the generated code is not
a problem if we ensure the two are semantically identical. Of course we cannot
find bugs in the implementation (i.e. in the generator) this way. But to
detect those, debugging on the level of the generated C code is more useful
anyway.}!

If you already have the interpreter\footnote{we discuss how to build on in
\todo{}}, expanding it into a simulator/debugger is relatively simple.
Essentially only three things have to be done:

\begin{itemize}
  \item First, the execution of the program must be controllable from the
  outside. This involves setting breakpoints, single-stepping through the
  program and stopping execution if a breakpoint is hit. In our example case, we
  do not single-step through statements, but only through
  steps\footnote{Remember that the language is time-triggered anyway, so
  execution is basically a sequence of steps triggered by a timer. In the
  simulator/debugger, the timer is replaced with the user pressing the
  \ic{Next Step} button for single stepping.}. Breakpoints are essentially
  Boolean flags associated with program elements: if the
  execution processes a statement that has the \ic{breakpoint} flat set to
  \ic{true}, execution stops.
  \item Second, we have implemented an Observer infrastructure for all parts of
  the program state that should be represented in the simulator UI. Whenever one
  of them changes (as a side effect of executing a statement in the program), an
  event is fired. The UI registers as an observer and updates the UI in
  accordance with the event.
  \item Third, values from the program state must be changeable from the
  outside. As a value in the UI (such as the temperature of a cooling
  compartment) is changed by the user, the value is updated in the state of the
  interpreter as well. 
\end{itemize}


\subsection{Automatic Debugging for Xbase-based DSLs}

DSLs that use Xbase, the reusable expression language that ships with Xtext,
get debugging mostly for free. This is because of the tight integration of Xbase
with the JVM. While we describe this integration in more detail in \todo{}. Here
is the essence. 

A DSL that uses Xbase typically defines its own structural and high-level
behavioral aspects but uses Xbase for the fine-grained, expression-level
behavior. For example, in a state machine DSL, states, events and transitions
would be concepts defined by the DSL, but the guard conditions and the action
code would reuse Xbase expressions. When mapping this DSL to
Java\footnote{Xbase-based DSLs \emph{must} be mapped to Java to benefit from
Xbase in the way discussed in this section. If you generate code other than
Java, Xbase cannot be used sensibly.}, the following approach is used. The
structural and high-level behavioral aspects are mapped to Java, but \emph{not}
by generating Java text, but by mapping the DSL AST to a Java AST. For the
reused Xbase aspects (the finer-grained behavior) there already exists a to-Java
generator (called the Xbase compiler) which we simply call from our generator.

Essentially, we do not create a code generator, but a model-to-model
transformation from the DSL AST to the Java AST. As part of the this
transformation (performed by the so-called JVMModel inferrer), trace links
between the DSL code and the created Java code are created. In other words, the
relationship between the Java code and the DSL code is well known. This
relationship is exploited in the debugging process. 

Xbase-based DSLs use the Java debugger for debugging. In addition to showing the
generated Java code, the debugger can also show the DSL code, based on the
trace information collected by the JVMModel inferrer. In the same way, if a user
sets a breakpoint in the DSL code, the trace information is used to determine
where to set the breakpoint in the generated Java code. 


\subsection{Debuggers for an Extensible Languages}

This section describes, in some detail, the architecture of an extensible
debugger for an extensible language. We illustrate the approach with an
implementation based on mbeddr, an extensible version of C implemented with the
MPS. We illustrate the debuggers for non-trivial extensions of C. We also
discuss the extent to which the approach can be used with other extensible
languages and language workbenches.


\paragraph{Requirements on the Debugger}
\label{challenges}

Debuggers for imperative languages support at least the following features:
\emph{Breakpoints} suspend execution on arbitrary statements; \emph{Single-Step
Execution} steps over statements, and into and out of functions or other
callables; \emph{Watches} show values of variables, arguments or other aspects
of the program state. \emph{Stack Frames} visualize the call hierarchy of
functions or other callables.

When debugging a program that contains extensions, breakpoints, stepping,
watches and call stacks \emph{at the extension-level} differ from their
counterparts \emph{at the base-level}. The debugger has to perform the mapping
from the base-level to the extension-level (\fig{levels}). We distinguish
between the \emph{tree} representation of a program in MPS and the generated
\emph{text} that is used by the C compiler and the debugger
backend. A program in the tree representation can he separated into parts
expressed in the \emph{base} language and parts expressed using
extensions. We refer to the latter the \emph{extension}-level or
\emph{DSL}-level (see \fig{levels}).

\begin{marginfigure}
  \centering  
    \includegraphics[width=35mm]{figures/8/mbeddr/levels.png}
    \caption{
    An extension-aware debugger maps the debug
    behavior from the base-level to the extension-level (an extension may also
    be mapped onto other extensions; we ignore this aspect in this section).}
  \label{levels} 
\end{marginfigure}

\noindent An extensible \emph{tree}-level debugger for mbeddr  that
supports debugging on the \emph{base}-level and \emph{extension}-level, 
addresses the following requirements (the requirements are named R1 through
R5 so we can refer back to them from the following sections):


\vspace{1mm}\noindent \textbf{R1 Modularity:} Language extensions in mbeddr are
modular, so debugger extensions must be modular as well. No changes to the base
language must be necessary in order to enable debugging for a language
extension.

\vspace{1mm}\noindent \textbf{R2 Framework Genericity:} In addition, new
language extensions must not require changes \emph{to the core debugger
infrastructure} (not just the base language, as described in R1).
  
\vspace{1mm}\noindent \textbf{R3 Simple Debugger Definition:} Creating language
extensions is an integral part of using mbeddr. Hence, the development of a
debugger for an extension should be simple and not require too much knowledge
about the inner workings of the framework, or even the C debugger backend.

\vspace{1mm}\noindent \textbf{R4 Limited Overhead:} As a consequence of embedded
software development, we have to limit the additional, debugger-specific code
generated into the binary. This would increase the size of the binary,
potentially making debugging on a small target device infeasible.
  
\vspace{1mm}\noindent \textbf{R5 Debugger Backend Independence:} Embedded
software projects use different C debuggers depending on the target
device. This prevents modifying the C debugger itself: changes would have to be
re-implemented for every C debugger used.



\paragraph{An example Extension} We start out by developing a simple extension
to the mbeddr C language. The \ic{foreach} statement shown below is a simple
example of language extension. \ic{foreach} can be used to conveniently iterate
over C arrays. Users have to specify the array as well as its size, since in C
an array cannot be queried for its size. Inside the \ic{foreach} body, \ic{it}
acts as a reference to the current iteration's array element.

\begin{code}
int8_t s = 0;                                              
int8_t[] a = {1, 2, 3};                  
foreach (a sized 3) {    
    s += it;    
} 
\end{code}

The code generated from this piece of extended C looks as follows. The
\ic{foreach} statement is expanded into a regular \ic{for} statement and an
additional variable \ic{\_\_it}:

\begin{code}
int8_t s = 0;                                              
int8_t[] a = {1, 2, 3};                  
for (int __c = 0; __c < 3; __c++) {    
    int8_t __it = a[__c];
    s += __it;    
} 
\end{code}

To make the \ic{foreach} extension modular, it lives in a separate language
module named \ic{ForeachLanguage}. The new language extends C, since we will
refer to concepts defined in C (see \fig{umldiag}).
 

\begin{marginfigure}
  \centering
    \includegraphics[width=50mm]{figures/8/mbeddr/umldiag.png}
    \caption{UML class diagram showing the structure of the
    \ic{ForeachLanguage}. Concepts from the C base language are in white
    boxes, new concepts are grey.} 
  \label{umldiag}
\end{marginfigure}


\paragraph{Developing the Language Extension}  In the new language, we define
the \ic{ForeachStatement}. To make it usable wherever C expects \ic{Statement}s
(i.e. in functions), \ic{ForeachStatement} extends C's \ic{Statement}.
\ic{ForeachStatement}s have three children (see \fig{umldiag}): an
\ic{Expression} that represents the array, an \ic{Expression} for the array
length, and a \ic{StatementList} for the body.
\ic{Expression} and \ic{State- mentList} are both defined in C.

The editor that defines the concrete syntax (\fig{foreachEditorImage}) consists
of a horizontal list of cells: the \ic{foreach} keyword, the opening
parenthesis, the embedded editor of the
\ic{array} child, the \ic{sized} keyword, the embedded editor of the \ic{len}
expression, the closing parenthesis and the editor of the \ic{body}.

\begin{figure}[h]
\begin{center} 
  \includegraphics[width=85mm]{figures/8/mbeddr/foreachEditor2.png}
\end{center}
\caption{The editor definition of the
\ic{foreach} statement and its relationship to an example
instance.}
\label{foreachEditorImage}
\end{figure}

As shown in the code snippet below, the 
\ic{array} must be of type \ic{ArrayType}, and the type of \ic{len} must be
\ic{int64\_t} or any of its shorter subtypes.
 
\begin{code}
rule typeof_ForeachStatement for ForeachStatement as fes do {
    typeof(fes.len) :<=: <int64_t>; if
    (!(fes.array.type.isInstanceOf(ArrayType))) {
      error "array required" -> fes.array; } }
\end{code}
 

The generator translates a \ic{ForeachStatement} to a regular \ic{for} statement
that iterates over the elements with a counter variable \ic{\_\_c}
(\fig{foreachGenerator}). Inside the \ic{for} body, we create a variable
\ic{\_\_it} that refers to the array element at position \ic{\_\_c}. We then
copy in the other statements from the body of the \ic{foreach}. Note that there
is an existing generator for C that outputs C text which is subsequently
compiled.
 
\begin{figure}[h]
\begin{center}  
  \includegraphics[width=110mm]{figures/8/mbeddr/foreachGenerator.png}
\end{center} 
\vspace{-2mm}
\caption{The \ic{foreach} generator template. A \ic{ForeachStatement} is replaced by what is framed \ic{<TF .. TF>}
when the template is executed, the \ic{dummy} function around it just provides
context. The \ic{COPY\_SRC} and
\ic{COPY\_SRCL} macros contain expressions (not shown) that determine 
with what the nodes in square brackets (e.g. \ic{10}, \ic{int8\_t x;}) are
replaced during a transformation.}
\label{foreachGenerator}
\end{figure}


The \ic{ItExpression} extends C's \ic{Expression} to make it usable where
expressions are expected. The editor consists of a single cell with the keyword
\ic{it}. A constraint enforces that the \ic{ItExpression} is only used inside
the body of a \ic{foreach}:

\begin{code}
concepts constraints ItExpression { 
  can be child 
    (context, scope, parentNode, link, childConcept)->boolean { 
      parentNode.ancestor<ForeachStatement, +>.isNotNull && 
      parentNode.ancestor<StatementList, +>.isNotNull;   }   }
\end{code}


The type of \ic{it} must be the base type of the \ic{array} (e.g. \ic{int} in
case of \ic{int{[]}}), as shown in the code below:

\begin{code}
node<Type> basetype = typeof(it.ancestor<ForeachStatement>.array) 
                         as ArrayType.baseType; 
typeof(it) :==: basetype.copy;
\end{code}


The \ic{foreach} generator already generated a local variable
\ic{\_\_it} into the body of the \ic{for} loop. We can thus translate an
\ic{ItExpression} into a \ic{LocalVariable- Reference} that refers to
\ic{\_\_it}.

\paragraph{Defining the Debugger}
\label{exdebugger}
The specification of the \ic{foreach} debugger extension resides completely in
the \ic{ForeachLanguage} (R1). 
 

To set a breakpoint on a concept, it must implement the
\ic{IBreakpointSupport} marker interface. \ic{Statement} already implements this
interface, so \ic{ForEachStatement} implicitly implements this interface as well.

Stepping behavior is implemented via \ic{IStep- pable}.
\ic{ForeachStatement} implements this interface indirectly via \ic{Statement},
but we have to overwrite the methods that define the step over and step into
behavior. Assume the debugger is suspended on a \ic{foreach} and the user
invokes \emph{step over}. If the array is empty or we have finished iterating
over it, a step over ends up on the statement that follows \emph{after the
whole} \ic{foreach} statement. Otherwise we end up on the first line of the
\ic{foreach} body (\ic{sum += it;}). This is the first line of the mbeddr
program, \emph{not} the first line of the generated base program (which would be
\ic{int8\_t \_\_it = arr[\_\_c];}).

The debugger can not guess which alternative will occur since it would require
to know the state of the program and to evaluate the expressions in the
(generated) \ic{for}. Instead we set breakpoints \emph{on each of the possible
next statements} and then resume execution until we hit one of them (an idea
adapted from \cite{Wu06grammar}). The implementations of the \ic{ISteppable}
methods specify strategies for setting breakpoints on these possible next
statements. The \ic{contributeStepOverStrategies} method collects strategies for
the \emph{step over} case:
 
\begin{code}
void contributeStepOverStrategies(list<IDebugStrategy> res) {
   ancestor
   statement list: this.body   }
\end{code}

The method is implemented using a domain-specific language for
debugger specification, which is part of the mbeddr debugger framework (R3). It
is an extension of MPS' \ic{BaseLanguage}, a Java-based language used for
expressing behavior in MPS. The \ic{ancestor} statement delegates to the
\ic{foreach}'s ancestor; this will lead to a breakpoint on the subsequent
statement. The second line leads to a breakpoint on the first statement of the
\ic{body} statement list.



Since the \ic{array} and \ic{len} expressions can be arbitrarily complex and may
contain invocations of callables (such as function calls), we have to specify
the \emph{step into} behavior as well. This requires the debugger to inspect the
expression trees in \ic{array} and \ic{len} and find any expression that can be
stepped into. Such expressions implement \ic{IStepIntoable}. If
so, the debugger has to step into each of those, in turn. Otherwise the debugger
falls back to \emph{step over}. An additional method configures the expression
trees which the debugger must inspect:

\begin{code}
void contributeStepIntoStrategies(list<IDebugStrategy> res) { 
  subtree: this.array 
  subtree: this.len     }
\end{code}
      

By default, the Watch window contains all C
symbols (global and local variables, arguments) as supplied by the
native C debugger. In case of the \ic{foreach}, this means that \ic{it}
is not available, but \ic{\_\_it} and \ic{\_\_c} are. This is exactly the wrong way:
the watch window should show \ic{it}, but not \ic{\_\_it} and \ic{\_\_c}.

To customize Watches, a concept has to implement \ic{IWatchProvider}. Here
is the code for \ic{foreach}, also expressed in the debugger definition DSL:


\begin{code}
void contributeWatchables(list<UnmappedVariable> unmapped, 
                                 list<IWatchable> mapped) { 
  hide "__c" 
  map "__it" to "it" 
    type: this.array.type : ArrayType.baseType 
    category: WatchableCategories.LOCAL_VARIABLES 
    context: this    }
\end{code}

The first line hides \ic{\_\_c}. The rest \ic{map}s a base-level C
variable to a Watchable. It finds a C variable named \ic{\_\_it} (inserted by
the \ic{foreach} generator) and creates a watch variable named \ic{it}. At the same time, it
hides the base-level variable \ic{\_\_it}. The type of \ic{it} is the base type
of the array over which we iterate. We assign the \ic{it} Watchable to the local
variables section and associate the \ic{foreach} node with it (double-clicking
on the \ic{it} in the Watches will highlight the \ic{foreach} in the code).


Stepping into the \ic{foreach} body does not affect the
call stack, since the concept represents no callable (details see
\sect{archspec}). So we do not have to implement any stack frame
related functionality.


