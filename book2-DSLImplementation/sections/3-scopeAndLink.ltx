\chapter{Scoping and Linking}		
\label{Ch:scopes}

As we have elaborated in the previous section, the concrete syntax in its
simplest form is shaped like a tree. However, the information represented by the program is
semantically almost always a graph, i.e.\ in addition to the tree's containment
hierarchy, it contains non-containment cross-references. Examples are abound and
include variable references, procedure calls and target states in transitions of
state machines. The challenge thus is: how to get from the "syntactical tree" to
the "semantic graph", or: how to establish the cross-links.

There is a marked difference between the projectional and parser-based case:

\begin{itemize}

  \item In parser-based systems, the cross-references have to be
  \emph{resolved}, from the parsed text after the AST has been created. An IDE
  may provide the candidates in a code completion menu, but after selecting a
  target, the resulting textual representation of the reference must contain all
  the information to \emph{re-resolve} the reference each time the program is
  parsed.

  \item In projectional editors where every program element has a unique ID, a
  reference is simply a pointer to that ID. Once a reference is established, it
  can always be re-resolved trivially based on the ID. The reference is established directly as
  the program is edited: the code completion menu shows potential target
  elements for a reference (typically in a pick list) and selection of one of
  them creates the reference. Of course, the code completion menu shows some
  human-readable (qualified) name of the target, but the persisted program uses
  the unique ID.

\end{itemize}

Typically, a language's structure definition defines what
concepts constitute valid target concepts for references (e.g. a \ic{Function},
a \ic{Variable}, or a \ic{State}), but this is usually too imprecise.
Language-specific visibility rules determine which instances of these concepts
are actually visible. For example, only the function and variables in the local
module or the states in the same state machine as the transition may be valid
targets.

The collection of model elements which are valid targets of a particular
semantic cross-reference is called the \emph{scope} of that cross-reference.
Typically, the scope of a particular cross-reference not only depends on the
target concept of the cross-reference but also on its surroundings, e.g.\ a
namespace prefix, the location inside the larger structure of the site of the
cross-reference or something that's essentially non-structural in nature.

A scope, the collection of valid targets for a reference, has two uses. First, it
can be shown in the code completion menu in the IDE if the user presses
\keystroke{Ctrl-Space} at the reference site. Second, independent of the IDE,
the scope is used for checking the validity of an existing reference: if the
reference target is not among those elements in the scope, the reference is
invalid.

\LK{There seem to be three concepts of scope here:
1) the lexical scope as a primarily syntactic concept that marks part of a program and can be nested;
2) the local variable scope as a collection of variables associated with a particular lexical scope;
3) the scope as a collection of all names that are reachable from a certain lexical scope.

The last one I really only know from Xtext, and I've always found it rather confusing.
Is it used more generally?
It's really more like a symbol table than anything else, that combine names from different
lexical scopes.
}

Scopes can be hierarchical, in which case they are organized as a stack of
collections --- confusingly, these collections are often called scopes
themselves. During resolution of a cross-reference, the lowest or
\emph{innermost} collection is searched first. If the reference cannot be
resolved to match any of its elements, the parent of the innermost collection is
queried, and so forth.

The hierarchy can follow or mimic the structure of the language itself: e.g.,
the innermost scope of a reference consists of all the elements present in the
directly-encompassing "block" while the outermost scope is the \emph{global}
scope. This provides a mechanism to disambiguate target elements having the same
reference syntax (usually the target element's name) by always choosing the
element from the innermost scope --- this is often called "shadowing".

Instead of looking at scopes from the perspective of the reference (and hence
calculating a set of candidate target elements), once can also look at scopes
from the perspective of visibility. In this case, we (at least conceptually)
compute for each location in the program, the set of visible elements. A
reference is then restricted to refer to any element from those visible at the
particular location. Our notion is more convenient from the cross-reference
viewpoint, however, as it centers around resolving particular cross-references
one at a time. From an implementation perspective, both views are exchangable.

\section{Name Resolution in Spoofax}

\MV{Explain this one first, since this one is the most low level; good fit to
introduce the basic mechanism}

In Spoofax, annotations can be used to describe to describe which elements of
the language \emph{reference} a concept and which elements \emph{define} a
concept. Each concept has its own namespace \MV{What does this mean?}: for
example, \ic{Function} for functions and \ic{Property} for properties.
Annotations can also control the basic scoping structure of these namespaces.
Once the references, definitions, and basic scopes have been specified, they can
be customized using rewrite rules.

\subsection{References and Definitions}

In the previous chapter we described how to specify a grammar for a subset of
the Mobl language. This chapter shows how to add annotations and rules to define
Mobl's name analysis.

Definitions of concepts are indicated using the notation \ic{Namespace@=Symbol},
where \ic{Namespace} is the namespace of the definition, and \ic{Symbol}
is the grammatical symbol for its name. As an example, we can add this notation to
the production for entity definitions:

\begin{code}
"entity" Type@=ID "{" EntityBodyDecl* "}" -> Entity {"Entity"}
\end{code}

The annotation indicates that every program fragment that the syntactic element
that corresponds to this production is a concept in the \ic{Type} namespace. It
also says that the name of that concept is indicated by the identifier \ic{ID}
that follows after the \ic{entity} keyword.
\MV{Let me see if I understand. Concepts are not the same as the name language
concept I use in the design part of the (CS, AS) building blocks of language.
These are essentially namespaces. So the Type@=ID means that the text in the ID
is put into a collection of names in the Type namespace. And if I then use
Type@ID, the text in this location may only be one of the strings in the Type
namespace. Right?}

References to definitions are defined similarly, using the notation
\ic{Namespace@Symbol}:

\begin{code}
Property@=ID ":" Type@ID -> EntityBodyDecl {"Property"}
\end{code}

This production shows that a property defines a concept in the \ic{Property}
namespace, while it references something in the \ic{Type} namespace.

\subsection{Basic Scoping Rules}

Scoping annotations customize how the relation between references
and definitions is resolved. Scoping annotations can be specified
by adding \ic{scope(Namespace)} at the end of a production:

\begin{code}
"entity" Type@=ID "{" EntityBodyDecl* "}" -> Entity {"Entity", scope(Property)}
\end{code}

Here, the \ic{scope} annotation indicates that every entity scopes
the properties inside it. This means that properties in different entities can
be distinguished:

\begin{code}
entity Customer {
  name : String
}

entity Product {
  name : String
}
\end{code}

\MV{We're rapidly approach terminology hell :-) So this scope is \emph{not} a
collection of target elements for a reference, but rather a namespace, which
qualifies the new names inside it. So the two properties are actually called
Customer.name and Product.name. Right?} 

\MV{So Scope(X) means that the contents of the X namespace (X@=ID) are using in
the children of the respective element?}

In this example, the two \ic{name} properties live in the same namespace, but
they exist in different scopes. This means that if \ic{name} is referenced in a
function inside \ic{Customer}, then it references the first one, not the one in
\ic{Product}.

\MV{I think you should say that the separation of languge concept/AST type and
Namespace is an elegant solution for the polymorpic references problem.
Different syntactic constructs can have their idenitfying names in the same
Namespace, and references to that namespace work even if the reference targets
are of different AST types}

\MV{Maybe also say, that, in contrast to Xtext, the resulting AST for the
refernece is still "just" a string, and not an actual reference as in the
resulting Ecore file. Do you want to show a little bit of AST there?}

The full grammar of the mobl entities language with annotations is the following
(leaving out the lexical syntax):

\begin{code}
module MoblEntities

context-free start symbols

  Module
  
context-free syntax

  "module" Module@=ID Entity* -> Module {"Module", scope(Entity)}
  "entity" Type@=ID "{" EntityBodyDecl* "}"
                              -> Entity {"Entity", scope(Property,Function)}
  Property@=ID ":" Type@ID    -> EntityBodyDecl {"Property"}

  "function" Function@=ID "(" {Param ","}* ")" ":" Type@ID "{" Statement* "}"
                              -> EntityBodyDecl {"Function", scope(Var)}
  Var@=ID ":" Type@ID         -> Param {"Param"}
  "return" Exp ";"            -> Statement {"Return"}

  Exp "." Function@ID "(" Exp  ")" -> Exp {"MethodCall"}
  Exp "." Property@ID              -> Exp {"FieldAccess"}
  Exp "+" Exp                      -> Exp {"Plus"}
  Exp "*" Exp                      -> Exp {"Mul"}
  Var@ID                           -> Exp {"Var"}
  INT                              -> Exp {"Int"}
\end{code}


\subsection{URIs for Concepts}

Each concept\MV{What was "concept" again? Namespace, Scope, Concept \ldots I am
confused :-)} in Spoofax has a URI that uniquely identifies it across a project.
By default, these URIs are constructed on the concept definitions and scoping
annotations. As an example, consider the following entity.


\begin{code}
module storage

entity Store {
  name    : String
  address : Address
}
\end{code}

Following the annotated mobl grammar, there are two scopes in this fragment: one
at the module level and one at the entity level. These scopes also correspond to
the definitions of \ic{storage} in the \ic{Module} namespace and \ic{Store} in
the \ic{Type} namespace. Spoofax constructs URIs by simply combining the names
in the scoping hierarchy: the URI for \ic{Store} is \ic{Type://storage.Store},
and the URI for \ic{name} is
\ic{Property://storage.}\linebreak[0]\ic{Store.name}.

Using URIs makes it possible to identify a concept across a project and to
distinguish it from concepts with the same name in a different scope (such as
\ic{name} in the \ic{Customer} entity).

URIs are internally represented as lists of terms, that start with the
namespace, followed by a reverse hierarchy of the path names:

\begin{code}
[Property(), "name", "Store", "storage"]
\end{code}

The reverse order used in the representation makes it easier to efficiently
store and manipulate URIs in memory\MV{Why?}. In most cases, path parts are
simple strings, such as \ic{"Store"}, but they can be complex terms when needed.\MV{Why is this imporant?}

Some scopes are \emph{anonymous} and do not have a name associated with them.
Block statements in C-like languages are an example of this. These scopes are
handled differently from named scopes. We can add a block statement to our
grammar by adding the following production:
\begin{code}
"{" Stm* "}" -> Stm {"Block", Scope(Var)}
\end{code}

The block statement does not define a definition name, but it still
defines a scope, and therefore should be included in any URIs.
Spoofax handles these cases by adding an anon element to the URI:

\begin{code}
[Var(), "v", Anon(15), "f", "Store", "storage"]
\end{code}

\noindent would be a valid URI for a variable \ic{v} in an anonymous block
inside some function \ic{f}.

\MV{Do you want to show the example program code for this?}

When needed, the path elements that are created for a scope can be customized
using a rewrite rule:
\begin{code}
adjust-index-path(is-def | namespace, path):
  Entity(name, body) -> [Entity(), name]
\end{code}

\MV{What is a rewrite rule? Why do you want to rewrite the scopes?}

\todo{}

\subsection{Hardcoded Concepts}

e.g., String, Int

\todo{}

\subsection{Customizing Scopes with Rewrite Rules}

unifying Var and Property namespace?

type-based: property access, function calls

\todo{}

\subsection{Constraints and Type Systems}

order of scopes, duplicates, unresolved references:

next section!



\section{Scoping in Xtext}

Xtext uses Java code (in the future probably Xtend2 code) for implementing all
aspects of languages except the grammar. Language developers implement various
classes to build the language beyond the grammar. Xtext framework and custom
language implementation classes are contributed to the runtime using Google
Guice, a dependency injection framework. A lot of functionality is provided
out-of-the-box with minimal configuration, but it's easy to swap out specific
parts by binding another or a custom class through Guice.

\subsection{Simple, Local Scopes}

To implement scopes, language developers have to contribute a class that
implements the \ic{IScopeProvider} interface. It has one method that returns an
\ic{IScope} for a given reference. An \ic{IScope} is basically a collection of
candidate reference targets, together with the textual representation by which
these may be referenced from the current reference site (the same target may be
referenced by different text strings from different program locations). The
method takes the \ic{EReference} (which identifies the reference for which the
scope that needs to be calculated) as well as the current
instance of the language concept whose reference should be scoped.


\begin{code}
public interface IScopeProvider {
	IScope getScope(EObject context, EReference reference);
}
\end{code}


To make scoping implementation easier, Xtext provides so-called declarative
scope providers through the \ic{AbstractDeclarativeScopeProvider} base class:
instead of having to inspect the \ic{EReference} and context objects manually to
decide how to compute the scope, the language implementor can express this
information via the name of the method (using a naming convention). Two
different naming conventions are available:


\begin{code}
// <X>, <R>: we are trying to scope the <R> reference of the <X> concept 
public IScope scope_<X>_<R>(<X> ctx, EReference ref );

// <X>: the language concept we are looking for
// <Y>: the concept from under which we try to look for the reference 
public IScope scope_<X>(<Y> ctx, EReference ref);
\end{code}

 
Let's assume we want to scope the \ic{targetState} reference of the
\ic{ChangeStateStatement}. Its definition in the grammar looks as follows:

\begin{code}
ChangeStateStatement:
    "state" targetState=[State];
\end{code}

We can use the following two alternative methods:

\begin{code}
public IScope scope_ChangeStateStatement_targetState
            (ChangeStateStatement ctx, EReference ref ) {
    ...            
}
            
public IScope scope_State(ChangeStateStatement ctx, EReference ref) {
    ...
}
\end{code}


The first alternative is specific for the \ic{targetState} reference of the
\ic{ChangeStateStatement}. It is invoked by the declarative scope provider only
for that reference. The second alternative is more generic. It is invoked
whenever we are trying to reference a \ic{State} (or any sub type of \ic{State})
from any reference of a \ic{ChangeStateStatement} and \emph{all its
descendants}. So we could write an even more general alternative, which scopes
the visible States from anywhere in a \ic{CoolingProgram}, independent of the actual
reference.

\begin{code}
public IScope scope_State(CoolingProgram ctx, EReference ref) {
    ...
}
\end{code}


The implementation of the scopes is simple, and relatively similar in all three
cases. We write Java code that crawls up the containment hierarchy until we
arrive at a \ic{CoolingProgram} (in the last alternative, we already have the
\ic{CoolingProgram}, so we don't need to move up the tree), and then construct
an \ic{IScope} that contains the \ic{State}s defined in that
\ic{CoolingProgram}. Here is a possible implementation:


\begin{code}
public IScope scope_ChangeStateStatement_targetState
            (ChangeStateStatement ctx, EReference ref ) {
    CoolingProgram owningProgram = Utils.ancestor( ctx, CoolingProgram.class );
    return Scopes.scopeFor(owningProgram.getStates());
}
\end{code}

The \ic{Scopes} class provides a couple of helper methods to create \ic{IScope}
objects from collections of elements. The simple \ic{scopeFor} method we use
will use the \ic{name} of the target element as the text by which it will be
referenced. So if a state is called \ic{normalCooling}, then we'd have to write
\ic{state normalCooling} in a \ic{ChangeStateStatement}. The text \ic{normalCooling}
acts as the reference - pressing \keystroke{Ctrl-F3} on that program element
will go to the referenced state.




\subsection{Nested Scopes} 

The approach to scoping shown above is suitable for simple cases, such as the
\ic{targetState} reference shown above. However, in languages with nestes blocks
a different approach is recommended. Here is an example of a program expressed in
a language with nested blocks:


\begin{code}
var int x;		
var int g;
 
function add( int x, int y ) {
    int sum = x + y;               // 1
    return sum;
}

function addAll( int es ... ) {
    int sum = 0;                 
    foreach( e in es ) { 
        sum += e;                // 2
    }
    x = sum;                     // 3
}
\end{code}


At \ic{1}, the local variable \ic{sum}, the arguments \ic{x} and \ic{y} and the
global variables \ic{x} and \ic{g} are visible, although the global variable
\ic{x} is shadowed by the argument of the same name. At \ic{2}, we can see
\ic{x}, \ic{g}, \ic{sum} and \ic{es}, but also the iterator variable \ic{e}. At
\ic{3}, \ic{x} refers to the global since it is not shadowed by a parameter or
local variable of the same name. In general, certain program elements introduce
blocks (typically statement lists surrounded by curly braces). A block can
declare new symbols. References from within these blocks can see the symbols
defined in that block, as well as all ancestor blocks. Symbols in inner blocks
typically hide symbols with the same name in outer blocks. The symbols in outer
blocks are either not accessible, or a special name has to be used, for example,
by prefixing them with some \ic{outer} keyword.

Xtext's scopes support this scenario. \ic{IScopes} can have outer scopes. If a
symbol is not found in a scope, a scope delegates to its outer scope and tries
to find the symbol there. Since inner scopes are searched first, this implements
shadowing as expected.

Also, scopes are not just collections of elements. Instead, they are maps
between a string and an element. The string is used as the reference text. By
default, the string is the same as the target element's \ic{name}. So if a
variable is called \ic{x}, it can be referenced by the string \ic{x}. However,
this reference string can be changed as a scope is defined. This can be used to
make shadowed variables visible under a different name, such as \ic{outer.x} if
it is referenced from location \ic{1}. The following is pseudo-code that implements
this behaviour:


\begin{code}
// recursive method to build nested scopes
private IScope collect( StatementList ctx ) { 
    IScope outer = null
    if ( ctx is within another StatementList parent ) {
        outer = collect(parent)
    }
    IScope scope = new Scope( outer )
    for( all symbols s in ctx ) {
        scope.put( s.name, s )
        if ( outer.hasSymbolNamed( s.name ) ) {
            scope.put( "outer."+s.name, outer.getSymbolByName( s.name ) )
        }
    } 
    return scope
}

// entry method, according to naming convention 
// in declarative scope provider
public IScope scope_Symbol( StatementList ctx ) {
    return collect( ctx )
}	
\end{code}


\subsection{Global Scopes} 

There is one more aspect of scoping that needs to be discussed. Programs can be
separated into several files and references can cross file boundaries. That is,
an element in file \ic{A} can reference an element in file \ic{B}. In earlier versions of
Xtext file \ic{A} had to explicity import file \ic{B} to make the elements in \ic{B}
available as reference targets. This resulted in several problems. First, for internal
reasons, scalability was limited. Second, as a consequence of the explicit file
imports, if the referenced element was moved into another file, the import
statements in all referencing files had to be updated.

Since Xtext 1.0 both of these problems are solved using the so-called index. The
index is a data structure that stores
(\ic{String},\ic{IEObjectDescription})-pairs. The first argument is the
qualified name of the object and the second one, the \ic{IEObjectDescription},
contains information about a model element, including a URI, a kind of global
pointer that also includes the file in which the element is stored. All
references are checked against this name in the index, not against the actual
object. If the actual object has to be resolved, the URI stored in the index is
used. Only then is the respective file loaded (this is what improved
scalability; files are only loaded if a reference target is accessed, not to
check a reference for validity). The index is updated whenever a file is saved,
or a rebuild is performed. This way, if an element is moved to a different file
while keeping its qualified name (based on the logical program structure)
constant, the reference remains valid. Only the URI in the index is updated.

There are two ways to customize what gets stored in the index, and how. The
\ic{IQualifiedNameProvider} returns a qualified name for each program element. If it
returns \ic{null}, the element is not stored in the index, which means it is not
referenceble. The other way is the \ic{IDefaultResourceDescriptionStrategy} which
allows language developers to build their own \ic{IEObjectDescription} for program
elements. This is important if custom user data has to be stored in the
\ic{IEObjectDescription} for later use during scoping.

The \ic{IGlobalScopeProvider} is activated if a local scope returns \ic{null} or
no applicable methods can be found in the declarative scope provider class (or if
they return \ic{null}). The specific implementation is configured through a
Guice binding. By default, the \ic{ImportNamespacesAwareGlobalScopeProvider} is
configured, which provides the possibility to reference model elements outside
of the current file either through their (fully) qualified name or through their
unqualified name using an \ic{import} statement.  




\parhead{Polymorphic References} In the cooling language, expressions also
include references to various other entities, such as configuration parameters,
variables and hardware elements (compressors or fans defined in a different
model). All of these referenceble elements extend the \ic{SymbolDeclaration}
meta class. This means that all of them can be referenced by the single
\ic{SymbolRef} construct.
\begin{code} 
AtomicLevel returns Expression:
    ...
    ({SymbolRef} symbol=[SymbolDeclaration|QID]);
\end{code}  

The problem with this situation is that the reference itself does not encode the
kind of thing that is referenced. By looking at the reference alone we only know
that we reference some kind of symbol. This makes writing code that processes
the model cumbersome, since the target of a \ic{SymbolRef} has to be taken into
account when deciding how to treat (translate, validate) a symbol reference. A
more natural design of the language would use different reference constructs for
the different referencable elements. In this case, the reference itself is
specific to the referenced meta class, making processing much easier.

\begin{code} 
AtomicLevel returns Expression:
    ...
    ({VariableRef} var=[Variable]);
    ({ParameterRef} param=[Parameter]);
    ({HardwareBuildingBlockRef} hbb=[HardwareBuildingBlock]);
\end{code}  

However, this is not possible with Xtext, since the parser cannot distinguish
the three cases syntactically. In all three cases, the reference syntax itself
is just an \ic{ID}. Only during the linking phase could the system check which
kind of element is actually referenced, but this is too late for the parser,
which needs an unambiguous grammar. The grammar could be disambiguated by using
a different syntax for each element:

\begin{code} 
AtomicLevel returns Expression:
    ...
    ({VariableRef} "v:" var=[Variable]);
    ({ParameterRef} "p:" param=[Parameter]);
    ({HardwareBuildingBlockRef} "bb:" hbb=[HardwareBuildingBlock]);
\end{code}  

While this approach will technically work, it would lead to an awkward syntax
and is hence typically not used. The only remaining alternative is to make all
referencable elements extend \ic{SymbolDeclaration} and use a single reference
concept.





\section{Scoping in MPS}

Making references work in MPS requires several ingredients. First of all,
developers define a reference as part of the language structure. Then, an editor
is defined that determines how the referenced element is rendered at the
referencing site. We have shown this in the previous section. To determine which
instances of the referenced concept are allowed, a scoping function has to be
implemented. It simply returns a list of all the elements that are considered
valid targets for the reference, as well a an optional text string used
to represent the respective element in the code completion menu.

As we have explained above, smart references are an important ingredient to make
this work conveniently. They make sure that users can simply type the name (or
whatever else is put into the code completion menu by the language developer) of
the targeted element; once something is selected, the corresponding reference
concept is instantiated, and the selected target is set.

\parhead{Simple Scopes} As an example, we begin with the scope definition for
the target reference of the Transition concept. To recap, it is defined as:

\begin{code}
concept Transition      
  // ...                                        
  references:                           
    State target 1 specializes: <none>    
\end{code}

The scope itself is defined via the search scope constraint below. The system
provides an anonymous function \ic{search scope} that gets a number of arguments
that describe the context including the enclosing node and the referencing node.
As the signature shows, the function has to return either an \ic{ISearchScope}
or simply a sequence of nodes of type \ic{State}. The scope of the target state
is simple the set of states of the state machine that (transitively) contains
the transition. To implement this, the expression in the body of this function
crawls up the containment hierarchy until it finds a \ic{Statemachine} and then
returns its \ic{states}. The code used to express scopes can be arbitrarily 
complex and is implemented in MPS' BaseLanguge.
\begin{code}
link {target} 
  referent set handler:
    <none> 
  search scope: 
    (model, scope, referenceNode, linkTarget, enclosingNode)
    	->join(ISearchScope | sequence<node<State>>) { 
      enclosingNode.ancestor<concept = Statemachine>.states; 
    } 
  validator: 
    <default> 
  presentation : 
    <no presentation> 
;\end{code}


In addition to the search scope, language developers can provide code that
should be executed if a new reference target is set (\ic{referent set handler}),
additional validation (\ic{validator}), as well as customized
presentation in the code completion menu (\ic{presentation}).

\parhead{Nested Scopes} In a more complex, block oriented language with
nested scopes, a different implementation pattern is recommended:

\begin{itemize}
  \item All program elements that contribute elements that can be referenced
  (such as blocks, functions or methods) implement an interface \ic{IScopeProvider}.
  \item This interface provides a method \ic{getVisibleElements<concept C)} that
  returns all elements that are available in that scope. 
  \item The search scope function simply calls this method on the owning
  \ic{IScopeProvider}, passing in the concept whose instances it wants to see 
  (\ic{State} in the above example).
  \item The implementation of the method recursively calls the method on its
  owning \ic{IScopeProvider}, until there is none anymore. It also removes 
  elements that are overshadowed from the result.
\end{itemize}

\parhead{Polymorphic References} We have explained above how references work in
principle: they are real pointers to the references element. In the section on
Xtext (\todo{make sure we explain that first}) we have seen how from a given
location only one kind of reference for any given syntactic form can be
implemented. Consider the following example, where we refer to a global variable
\ic{a} and an event parameter (\ic{timestamp}) from within expressions:

\begin{code}
var int a;
var int b;

statemachine linefollower {                                                         
  in event initialized(int timestamp);
  states {                                                                
    state initializing {                                                      
      on initialized [now() - timestamp > 1000 && a > 3] -> running                                                   
    }     
    state running {
    }
  }                                                                            
}                                                                                   
\end{code}

Both references to local variables and to event parameters use the same
syntactic form: simply a text string (the name of the respective target
element). In Xtext, this has to be implemented with a single reference concept,
typically called \ic{SymbolReference}, that can reference to any kind of
\ic{Symbol}. \ic{LocalVariableDefintions} and \ic{EventParameters} would both
extend \ic{Symbol}, and scopes would make sure both kinds are visible from
within guard expressions. The problem with this approach is that the reference
itself contains no type information about what it references, it is simply a
\ic{SymbolReference}. Processing code has to inspect the type of the
referenced symbol to find out what a particular \ic{SymbolReference} actuallymeans.

In projectional editors this is done differently. To solve the example above,
one would create a \ic{LocalVariableReference} and an
\ic{EventParameterReference}. The former references variables and the latter
references event parameters. Both have an editor that simply renders the name
of the referenced element, and each of them has \ic{their own} scope definition! 
So adding new kinds of references to existing expression languages can be done
in a modular fashion, since the new reference expression comes with its own,
independent scoping rule. 

Entering the reference happens by typing the name of the referenced element (cf.
the concept of smart references introduced above). In the case where there's a
\ic{LocalVariable} and a \ic{EventParameter} of the same name, the user has to
make an explicit decision, at the time of entry (the name won't bind, and the
code completion menu requires a choice). It is important to understand that,
although the names are similar, the tool still knows which one refers to a \ic{LocalVariable} and which
one refers to a \ic{EventParameter}: upon selection from the code completion
menu, the correct reference objects are created.




%-------- Older Notes
%
%In parsing:
%  parser only produces tree
%  graph always through naming, symbol table, etc.
%  but may be built into grammar lang
%  in both cases naming is important
%  if grammar has real refs, then scoping is used 
%    to define the set of target objects
%  maybe the same obj has several names, dep on from where I refer to it
%          name shadowing, scopes as a hierarchy
%
%  challenge: multiple refs to diff things via the same ref syntax
%  seen in many languages, e.g. Java
%
%  example 1: an expression 'time.getSeconds()'; is time a local var or a field?
%
%  example 2: a name 'java.lang.System.out'; is 'out' a field? a class? a package name? an
%  inner class? the capitalization gives us a hint but is only a
%  convention. need semantic information
%
%  multiple refs to diff things problem in Xtext
%
% works in spoofax, but with the most straightforward approach
% references have the same abstract syntax (e.g., Var(x), pointing to
%  a variable or a field)
%
%In projection
%  references are real refs, based on unique IDs
%  still need scopes to define the set of valid targets   
%
%Compare proj and parser, where in parser the info in the reference has to be
%enough to resolve the uniquely named target. In proj systems, what is shown is
%irrelevant, since behind the scenes the ID is used.
