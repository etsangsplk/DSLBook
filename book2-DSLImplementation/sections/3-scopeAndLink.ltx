\chapter{Scoping and Linking}		

As we have elaborated in the previous section, the concrete syntax in its
simplest form is a tree. However, the information represented by the program is
semantically almost always a graph, i.e.\ in addition to the tree's containment
hierarchy, it contains non-containment cross-references. Examples abound and
include variable references, procedure calls and target states in transitions of
state machines. The challenge thus is: how to get from the "syntactical tree" to
the "semantic graph", or: how to establish the cross-links.

There is a marked difference between the projectional and parser-based case:

\begin{itemize}

  \item In parser-based systems, the cross-references have to be
  \emph{resolved}, from the parsed text after the AST has been created. An IDE
  may provide the candidates in a code completion menu, but after selecting a
  target, the resulting textual representation of the reference must contain all
  the information to \emph{re-resolve} the reference each time the program is
  parsed.

  \item In projectional editors where every program element has a unique ID, a
  reference is simply a pointer to that ID. Once a reference is established, it
  can always be re-resolved trivially based on the ID. The reference is established directly as
  the program is edited: the code completion menu shows potential target
  elements for a reference (typically in a pick list) and selection of one of
  them creates the reference. Of course, the code completion menu shows some
  human-readable (qualified) name of the target, but the persisted program uses
  the unique ID.

\end{itemize}

Often \MV{also for Spoofax?}, a language's structure definition defines what
concepts constitute valid target concpets for references (e.g. a \ic{Function},
a \ic{Variable}, or a \ic{State}), but this is usually too imprecise.
Language-specific visibility rules determine which instances of these concepts
are actually visible. For example, only the function and variables in the local
module or the states in the same state machine as the transition may be valid
targets.

The collection of model elements which are valid targets of a particular
semantic cross-reference is called the \emph{scope} of that cross-reference.
Typically, the scope of a particular cross-reference not only depends on the
target concept of the cross-reference but also on its surroundings, e.g.\ a
namespace prefix, the location inside the larger structure of the site of the
cross-reference or something that's essentially non-structural in nature.

A scope, the collection of valid targets for a refernce, has two uses. First, it
can be shown in the code completion menu in the IDE if the user presses
\keystroke{Ctrl-Space} at the reference site. Second, independent of the IDE,
the scope is used for checking the validity of an existing reference: if the
reference target is not among those elements in the scope, the reference is
invalid.

Scopes can be hierarchical, in which case they are organized as a stack of
collections --- confusingly, these collections are often called scopes
themselves. During resolution of a cross-reference, the lowest or
\emph{innermost} collection is searched first. If the reference cannot be
resolved to match any of its elements, the parent of the innermost collection is
queried, and so forth.

The hierarchy can follow or mimic the structure of the language itself: e.g.,
the innermost scope of a reference consists of all the elements present in the
directly-encompassing "block" while the outermost scope is the \emph{global}
scope. This provides a mechanism to disambiguate target elements having the same
reference syntax (usually the target element's name) by always choosing the
element from the innermost scope --- this is often called "shadowing".

Instead of looking at scopes from the perspective of the reference (and hence
calculating a set of candidate target elements), once can also look at scopes
from the perspective of visibility. In this case, we (at least conceptually)
compute for each location in the program, the set of visible elements. A
reference is then restricted to refer to any element from those visible at the
particular location. Our notion is more convenient from the cross-reference
viewpoint, however, as it centers around resolving particular cross-references
one at a time. From an implementation perspective, both views are exchangable.

\section{Name resolution in Spoofax}

\MV{Explain this one first, since this one is the most low level; good fit to
introduce the basic mechanism}


\section{Scoping in Xtext}

Xtext uses Java code (in the future probably Xtend2 code) for implementing all
aspects of languages except the grammar. Language developers implement various
classes to build the language beyond the grammar. Xtext framework and custom
language implementation classes are contributed to the runtime using Google
Guice, a dependency injection framework. A lot of functionality is provided
out-of-the-box with minimal configuration, but it's easy to swap out specific
parts by binding another or a custom class through Guice.

\subsection{Simple, local Scopes}

To implement scopes, language developers have to contribute a class that
implements the \ic{IScopeProvider} interface. It has one method that returns an
\ic{IScope} for a given reference. An \ic{IScope} is basically a collection of
candidate reference targets, together with the textual representation by which
these may be referenced from the current reference site (the same target may be
referenced by different text strings from different program locations). The
method takes the \ic{EReference} (which identifies the reference for which the
scope that needs to be calculated) as well as the current
instance of the language concept whose reference should be scoped.


\begin{code}
public interface IScopeProvider {
	IScope getScope(EObject context, EReference reference);
}
\end{code}


To make scoping implementation easier, Xtext provides so-called declarative
scope providers through the \ic{AbstractDeclarativeScopeProvider} base class:
instead of having to inspect the \ic{EReference} and context objects manually to
decide how to compute the scope, the language implementor can express this
information via the name of the method (using a naming convention). Two
different naming conventions are available:


\begin{code}
// <X>, <R>: we are trying to scope the <R> reference of the <X> concept 
public IScope scope_<X>_<R>(<X> ctx, EReference ref );

// <X>: the language concept we are looking for
// <Y>: the concept from under which we try to look for the reference 
public IScope scope_<X>(<Y> ctx, EReference ref);
\end{code}

 
Let's assume we want to scope the \ic{targetState} reference of the
\ic{ChangeStateStatement}. Its definition in the grammar looks as follows:

\begin{code}
ChangeStateStatement:
    "state" targetState=[State];
\end{code}

We can use the following two alternative methods:

\begin{code}
public IScope scope_ChangeStateStatement_targetState
            (ChangeStateStatement ctx, EReference ref ) {
    ...            
}
            
public IScope scope_State(ChangeStateStatement ctx, EReference ref) {
    ...
}
\end{code}


The first alternative is specific for the \ic{targetState} reference of the
\ic{ChangeStateStatement}. It is invoked by the declarative scope provider only
for that reference. The second alternative is more generic. It is invoked
whenever we are trying to reference a \ic{State} (or any sub type of \ic{State})
from any reference of a \ic{ChangeStateStatement} and \emph{all its
descendants}. So we could write an even more general alternative, which scopes
the visible States from anywhere in a \ic{CoolingProgram}, independent of the actual
reference.

\begin{code}
public IScope scope_State(CoolingProgram ctx, EReference ref) {
    ...
}
\end{code}


The implementation of the scopes is simple, and relatively similar in all three
cases. We write Java code that crawls up the containment hierarchy until we
arrive at a \ic{CoolingProgram} (in the last alternative, we already have the
\ic{CoolingProgram}, so we don't need to move up the tree), and then construct
an \ic{IScope} that contains the \ic{State}s defined in that
\ic{CoolingProgram}. Here is a possible implementation:


\begin{code}
public IScope scope_ChangeStateStatement_targetState
            (ChangeStateStatement ctx, EReference ref ) {
    CoolingProgram owningProgram = Utils.ancestor( ctx, CoolingProgram.class );
    return Scopes.scopeFor(owningProgram.getStates());
}
\end{code}

The \ic{Scopes} class provides a couple of helper methods to create \ic{IScope}
objects from collections of elements. The simple \ic{scopeFor} method we use
will use the \ic{name} of the target element as the text by which it will be
referenced. So if a state is called \ic{normalCooling}, then we'd have to write
\ic{state normalCooling} in a \ic{ChangeStateStatement}. The text \ic{normalCooling}
acts as the reference - pressing \keystroke{Ctrl-F3} on that program element
will go to the referenced state.




\subsection{Nested Scopes} 

The approach to scoping shown above is suitable for simple cases, such as the
\ic{targetState} reference shown above. However, in languages with nestes blocks
a different approach is recommended. Here is an example of a program expressed in
a language with nested blocks:


\begin{code}
var int x;		
var int g;
 
function add( int x, int y ) {
    int sum = x + y;               // 1
    return sum;
}

function addAll( int es ... ) {
    int sum = 0;                 
    foreach( e in es ) { 
        sum += e;                // 2
    }
    x = sum;                     // 3
}
\end{code}


At \ic{1}, the local variable \ic{sum}, the arguments \ic{x} and \ic{y} and the
global variables \ic{x} and \ic{g} are visible, although the global variable
\ic{x} is shadowed by the argument of the same name. At \ic{2}, we can see
\ic{x}, \ic{g}, \ic{sum} and \ic{es}, but also the iterator variable \ic{e}. At
\ic{3}, \ic{x} refers to the global since it is not shadowed by a parameter or
local variable of the same name. In general, certain program elements introduce
blocks (typically statement lists surrounded by curly braces). A block can
declare new symbols. References from within these blocks can see the symbols
defined in that block, as well as all ancestor blocks. Symbols in inner blocks
typically hide symbols with the same name in outer blocks. The symbols in outer
blocks are either not accessible, or a special name has to be used, for example,
by prefixing them with some \ic{outer} keyword.

Xtext's scopes support this scenario. \ic{IScopes} can have outer scopes. If a
symbol is not found in a scope, a scope delegates to its outer scope and tries
to find the symbol there. Since inner scopes are searched first, this implements
shadowing as expected.

Also, scopes are not just collections of elements. Instead, they are maps
between a string and an element. The string is used as the reference text. By
default, the string is the same as the target element's \ic{name}. So if a
variable is called \ic{x}, it can be referenced by the string \ic{x}. However,
this reference string can be changed as a scope is defined. This can be used to
make shadowed variables visible under a different name, such as \ic{outer.x} if
it is referenced from location \ic{1}. The following is pseudo-code that implements
this behaviour:


\begin{code}
// recursive method to build nested scopes
private IScope collect( StatementList ctx ) { 
    IScope outer = null
    if ( ctx is within another StatementList parent ) {
        outer = collect(parent)
    }
    IScope scope = new Scope( outer )
    for( all symbols s in ctx ) {
        scope.put( s.name, s )
        if ( outer.hasSymbolNamed( s.name ) ) {
            scope.put( "outer."+s.name, outer.getSymbolByName( s.name ) )
        }
    } 
    return scope
}

// entry method, according to naming convention 
// in declarative scope provider
public IScope scope_Symbol( StatementList ctx ) {
    return collect( ctx )
}	
\end{code}


\subsection{Global Scopes} 

There is one more aspect of scoping that needs to be discussed. Programs can be
separated into several files and references can cross file boundaries. That is,
an element in file \ic{A} can reference an element in file \ic{B}. In earlier versions of
Xtext file \ic{A} had to explicity import file \ic{B} to make the elements in \ic{B}
available as reference targets. This resulted in several problems. First, for internal
reasons, scalability was limited. Second, as a consequence of the explicit file
imports, if the referenced element was moved into another file, the import
statements in all referencing files had to be updated.

Since Xtext 1.0 both of these problems are solved using the so-called index. The
index is a data structure that stores
(\ic{String},\ic{IEObjectDescription})-pairs. The first argument is the
qualified name of the object and the second one, the \ic{IEObjectDescription},
contains information about a model element, including a URI, a kind of global
pointer that also includes the file in which the element is stored. All
references are checked against this name in the index, not against the actual
object. If the actual object has to be resolved, the URI stored in the index is
used. Only then is the respective file loaded (this is what improved
scalability; files are only loaded if a reference target is accessed, not to
check a refernce for validity). The index is updated whenever a file is saved,
or a rebuild is performed. This way, if an element is moved to a different file
while keeping its qualified name (based on the logical program structure)
constant, the reference remains valid. Only the URI in the index is updated.

There are two ways to customize what gets stored in the index, and how. The
\ic{IQualifiedNameProvider} returns a qualified name for each program element. If it
returns \ic{null}, the element is not stored in the index, which means it is not
referenceable. The other way is the \ic{IDefaultResourceDescriptionStrategy} which
allows language developers to build their own \ic{IEObjectDescription} for program
elements. This is important if custom user data has to be stored in the
\ic{IEObjectDescription} for later use during scoping.

The \ic{IGlobalScopeProvider} is activated if a local scope returns \ic{null} or
no applicable methods can be found in the declarative scope provider class (or if
they return \ic{null}). The specific implementation is configured through a
Guice binding. By default, the \ic{ImportNamespacesAwareGlobalScopeProvider} is
configured, which provides the possibility to reference model elements outside
of the current file either through their (fully) qualified name or through their
unqualified name using an \ic{import} statement.  





\section{Scoping in MPS}

Making references work in MPS requires several ingredients. First of all,
developers define a reference as part of the language structure. Then, an editor
is defined that determines how the referenced element is rendered at the
referencing site. We have shown this in the previous section. To determine which
instances of the referenced concept are allowed, a scoping function has to be
implemented. It simply returns a list of all the elements that are considered
valid targets for the reference, as well as, optionally, a text string used to
display the respective element in the code completion menu.

As we have explained above, smart references are an important ingredient to make
this work conveniently. They make sure that users can simply type the name (or
whatever else is put into the code completion menu by the language developer) of
the targetted element; once something is selected, the corresponding reference
concept is instantiated, and the selected target is set.

\paragraph{Simple Scopes} As an example, we begin with the scope definition for
the target reference of the Transition concept. To recap, it is defined as:


\begin{code}
concept Transition      
  // ...                                        
  references:                           
    State target 1 specializes: <none>    
\end{code}


The scope itself is defined via the following search scope constraint. The
system provides an anonymous function search scope that gets a number of
arguments that describe the context. The expression in the function then has to
be written by the language developer. The expression crawls up the containment
hierarchy until it finds a Statemachine. The set of valid target elements is the
states of that state machine. The code used here can be arbitrarily complex, and
is implemented in MPS' BaseLanguge.


\begin{code}
link {target} 
  referent set handler:<none> 
  search scope: 
    (model, scope, referenceNode, linkTarget, enclosingNode)
    	->join(ISearchScope | sequence<node< >>) { 
      referenceNode.ancestor<concept = Statemachine>.states; 
    } 
  validator: 
    <default> 
  presentation : 
    <no presentation> 
;\end{code}


In addition to the search scope, users can provide code that should be executed
if a new reference target is set, additional validation, as well as customized
presentation in the code completion menu. 

In case of the transition, the projection of the transition uses the name of the
target concept as the representation of the actual reference. This can be seen
from the transition editor (see previous section), that contains this
expression: \verb#(%target% -> {name} )#. This means that the name property of
the referenced State is shown as the reference. By default, this is also what is
used in the code completion menu, resulting in text-editor-like behavior.
\fig{Fig:mps-transeditor-2} shows an example where the reference includes the
"keyword" state, as well as the prefix initial in case the state is an initital
state.


\begin{figure}[ht]
\begin{center}
  \includegraphics[scale=0.8]{figures/2/mps-transeditor-2.png}
  \caption[labelInTOC]{}
  \label{Fig:mps-transeditor-2}  
\end{center} 
\end{figure}

To make a point, the editor could also be defined as \verb#(%target% -> X )#,
where every reference is rendered as an X. The system would still work (because
the underlying GUIDs are still used), but the information conveyed to the
user has been reduced to zero. 

\paragraph{Nested Scopes} In a more complex, block oriented language with
nested scopes, a different implementation pattern is recommended:

\begin{itemize}
  \item All program elements that contribute elements that can be references
  (such as blocks, functions or methods) implement an interface IScopeProvider.
  \item This interface provides a method getVisibleElements<concept C) that
  returns all elements that are available in that scope. 
  \item The search scope function simply calls this method on the owning
  IScopeProvider, passing in the concept whose instances it wants to see (State
  in the above example).
  \item The implementation of the method recursively calls the method on its
  owning IScopeProvider, until there is none anymore. It also removes elements
  that are overshadowed from the result.
\end{itemize}

We have already discussed in the previous section that polymorpic references are
not a problem in MPS. Each one simply defines its own search scope, possibly
using the IScopeProvider-based approach introduced above: a 
LocalVariableReference returns all local variables as its scope, the
ParameterReference returns all function parameters. In the resulting code
completion menu in an expression where LocalVariableReference and
ParameterReference are allowed, the superset of both scopes is shown.


%-------- Older Notes
%
%In parsing:
%  parser only produces tree
%  graph always through naming, symbol table, etc.
%  but may be built into grammar lang
%  in both cases naming is important
%  if grammar has real refs, then scoping is used 
%    to define the set of target objects
%  maybe the same obj has several names, dep on from where I refer to it
%          name shadowing, scopes as a hierarchy
%
%  challenge: multiple refs to diff things via the same ref syntax
%  seen in many languages, e.g. Java
%
%  example 1: an expression 'time.getSeconds()'; is time a local var or a field?
%
%  example 2: a name 'java.lang.System.out'; is 'out' a field? a class? a package name? an
%  inner class? the capitalization gives us a hint but is only a
%  convention. need semantic information
%
%  multiple refs to diff things problem in Xtext
%
% works in spoofax, but with the most straightforward approach
% references have the same abstract syntax (e.g., Var(x), pointing to
%  a variable or a field)
%
%In projection
%  references are real refs, based on unique IDs
%  still need scopes to define the set of valid targets   
%
%Compare proj and parser, where in parser the info in the reference has to be
%enough to resolve the uniquely named target. In proj systems, what is shown is
%irrelevant, since behind the scenes the ID is used.
