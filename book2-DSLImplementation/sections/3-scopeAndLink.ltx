\chapter{Scoping and Linking}		
\label{Ch:scopes}

As we have elaborated in the previous section, the concrete syntax in its
simplest form is shaped like a tree. However, the information represented by the program is
semantically almost always a graph, i.e.\ in addition to the tree's containment
hierarchy, it contains non-containment cross-references. Examples are abound and
include variable references, procedure calls and target states in transitions of
state machines. The challenge thus is: how to get from the "syntactical tree" to
the "semantic graph", or: how to establish the cross-links.

There is a marked difference between the projectional and parser-based case:

\begin{itemize}

  \item In parser-based systems, the cross-references have to be
  \emph{resolved}, from the parsed text after the AST has been created. An IDE
  may provide the candidates in a code completion menu, but after selecting a
  target, the resulting textual representation of the reference must contain all
  the information to \emph{re-resolve} the reference each time the program is
  parsed.

  \item In projectional editors where every program element has a unique ID, a
  reference is simply a pointer to that ID. Once a reference is established, it
  can always be re-resolved trivially based on the ID. The reference is established directly as
  the program is edited: the code completion menu shows potential target
  elements for a reference (typically in a pick list) and selection of one of
  them creates the reference. Of course, the code completion menu shows some
  human-readable (qualified) name of the target, but the persisted program uses
  the unique ID.

\end{itemize}

Typically, a language's structure definition defines what
concepts constitute valid target concepts for references (e.g., a \ic{Function},
a \ic{Variable}, or a \ic{State}), but this is usually too imprecise.
Language-specific visibility rules determine which instances of these concepts
are actually visible. For example, only the function and variables in the local
module or the states in the same state machine as the transition may be valid
targets.

The collection of model elements which are valid targets of a particular
semantic cross-reference is called the \emph{scope} of that cross-reference.
Typically, the scope of a particular cross-reference not only depends on the
target concept of the cross-reference but also on its surroundings, e.g.\ a
namespace prefix\LK{could you define this namespace prefix?}, the location inside the larger structure of the site of the
cross-reference or something that's essentially non-structural in nature.

A scope, the collection of valid targets for a reference, has two uses. First, it
can be shown in the code completion menu in the IDE if the user presses
\keystroke{Ctrl-Space} at the reference site. Second, independent of the IDE,
the scope is used for checking the validity of an existing reference: if the
reference target is not among those elements in the scope, the reference is
invalid.

%\LK{There seem to be three concepts of scope here:
%1) the lexical scope as a primarily syntactic concept that marks part of a program and can be nested;
%2) the local variable scope as a collection of variables associated with a particular lexical scope;
%3) the scope as a collection of all names that are reachable from a certain lexical scope.
%
%The last one I really only know from Xtext, and I've always found it rather confusing.
%Is it used more generally?
%It's really more like a symbol table than anything else, that combine names from different
%lexical scopes.
%}

Scopes can be hierarchical, in which case they are organized as a stack of
collections --- confusingly, these collections are often called scopes
themselves. During resolution of a cross-reference, the lowest or
\emph{innermost} collection is searched first. If the reference cannot be
resolved to match any of its elements, the parent of the innermost collection is
queried, and so forth.

The hierarchy can follow or mimic the structure of the language itself: e.g.,
the innermost scope of a reference consists of all the elements present in the
directly-encompassing "block" while the outermost scope is the \emph{global}
scope. This provides a mechanism to disambiguate target elements having the same
reference syntax (usually the target element's name) by always choosing the
element from the innermost scope --- this is often called "shadowing".

Instead of looking at scopes from the perspective of the reference (and hence
calculating a set of candidate target elements), once can also look at scopes
from the perspective of visibility. In this case, we (at least conceptually)
compute for each location in the program, the set of visible elements. A
reference is then restricted to refer to any element from those visible at the
particular location. Our notion is more convenient from the cross-reference
viewpoint, however, as it centers around resolving particular cross-references
one at a time. From an implementation perspective, both views are exchangable.

\section{Scoping in Spoofax}

In Spoofax, each language concept has its own private namespace. For example,
functions may live in the \ic{Functions} namespace and properties may live in the \ic{Property}
namespace. Namespaces can be defined as part of a grammar definition,
by adding annotations to productions. Spoofax supports three different
forms of annotations: annotations for language elements that define something
in a namespace, for elements that reference something in a namespace, and
for block constructs.

\subsection{Definitions and References}

In the previous chapter we described how to specify a grammar for a subset of
the mobl language. This chapter shows how to add annotations and rules to define
name resolution for this language.

To understand naming in Spoofax, the notion of a \emph{namespace} is
essential. A namespace is essentially a collection of names. A namespace
is not necessarily connected to a specific language concept. Different concepts
can contribute names to a namespace.
%During reference resolution, names are
%resolved against namespaces.

Language elements that contribute names to a a namespace can be annotated with
\ic{Namespace@=Symbol}, where \ic{Namespace} is the namespace of the definition,
and \ic{Symbol} is the grammatical symbol that represents the name of the
concept, and that is contributed to the namespace. As an example, wecan add this notation to the production for \ic{entity} definitions:

\begin{code}
"entity" Type@=ID "{" EntityBodyDecl* "}" -> Decl {"Entity"}
\end{code}

The annotation indicates that every program element
that corresponds to this production defines a name in the \ic{Type} namespace.
It also indicates the name of the program element: the identifier \ic{ID}
that follows after the \ic{entity} keyword.

Note how Spoofax distinguishes the name of a namespace from the type of a
program element: the type of the program element above is \ic{Decl}, but it
lives in the \ic{Type} namespace. By distinguishing these two things, it becomes
easy to add or exclude program elements from a namespace. For example,
\ic{import} statements are also of syntactic type \ic{Decl}, but they do not
live in the \ic{Type} namespace. Likewise, we could add primitive integers or
strings to the \ic{Type} namespace, even if they are syntactically a very
different concept from entity declarations.

References to definitions are defined in a similar fashion, using the notation
\ic{Namespace@Symbol}:
\begin{code}
Property@=ID ":" Type@ID -> EntityBodyDecl {"Property"}
\end{code}

The first annotation here says that the production defines something in the \ic{Property}
namespace, while the second says that the \ic{ID} after the colon referencessomething in the \ic{Type} namespace.

\subsection{Basic Scoping Rules}

Scoping annotations define the block structures of a language.
Block structures can be nested and determine the
visibility of names. For example, functions are block structures
that can contain local variable definitions that are not visible
from outside the function. Internally, the local variables are then assigned
a qualified name based on the name of the function.
The same principle applies to fields in a Java class, properties in a mobl entity, and so on.

Block structures can be specified by adding \ic{scope(Namespace)} at
the end of a production:

\begin{code}
"entity" Type@=ID "{" EntityBodyDecl* "}" -> Entity {"Entity", scope(Property)}
\end{code}

Here, the \ic{scope} annotation indicates that every entity scopes
the properties inside it. These scopes are used to qualify the names of
every property inside an entity:

\begin{code}
entity Customer {
  name : String
}

entity Product {
  name : String
}
\end{code}

In this example, the two \ic{name} properties both live the \ic{Property}
namespace, but we can still distinguish them: one can be reached as
\ic{Customer.name}, the other as \ic{Product.name}.
  This means that if
\ic{name} is referenced in a function inside \ic{Customer}, then it references
the first one, not the one in \ic{Product}.
Note that Spoofax does not require each name inside a block structure to be
unique: by default, it is not an error if users add an additional property
called name to \ic{Product}. However, in most languages it is desirable to
forbid duplicate names. We show how to specify a constraint for that later on.

The full grammar of the mobl entities language with annotations is the following
(leaving out the lexical syntax):

\begin{code}
module MoblEntities

context-free start symbols

  Module
  
context-free syntax

  "module" Module@=ID Decl* -> Module {"Module", scope(Entity)}
  "entity" Type@=ID "{" EntityBodyDecl* "}"
                              -> Decl {"Entity", scope(Property,Function)}
  "import" Module@ID          -> Decl {"import"}
  Property@=ID ":" Type@ID    -> EntityBodyDecl {"Property"}

  "function" Function@=ID "(" {Param ","}* ")" ":" Type@ID "{" Statement* "}"
                              -> EntityBodyDecl {"Function", scope(Var)}
  Var@=ID ":" Type@ID         -> Param {"Param"}
  "var" Var@=ID "=" Expr ";"  -> Statement {"Declare"}
  "return" Exp ";"            -> Statement {"Return"}

  Exp "." Function@ID "(" Exp  ")" -> Exp {"MethodCall"}
  Exp "." Property@ID              -> Exp {"FieldAccess"}
  Exp "+" Exp                      -> Exp {"Plus"}
  Exp "*" Exp                      -> Exp {"Mul"}
  _@ID                             -> Exp {"Var"}
  INT                              -> Exp {"Int"}
\end{code}

A special case in this grammar is the rule for \ic{"Var"},
which can refer to multiple namespaces. Consider the statement \ic{return x.y;}.
In such a statement, \ic{x} can be a local variable (\ic{Var}) or a local property (\ic{Property}).
In the full mobl language, it can even be a type (\ic{Type}).
As this more complicated scenario is not covered by the annotations, 
we specify an \ic{\_} in the grammar instead.
The \ic{\_} indicates that we specify additional, manual rules
for resolving this case. We show how to specify these at the end of this section.

\subsection{URIs for Program Elements}

Each program element that defines something is assigned a URI. The URI uniquely
identifies the element across a project. By default, these URIs are constructed
automatically, based on the namespace and scope annotations in the grammar. As
an example, consider the following entity.


\begin{code}
module storage
entity Store {
  name    : String
  address : Address
}
\end{code}

Following the annotated mobl grammar, there are two block constructs in this
fragment: one at the module level and one at the entity level. We can assign
names to these blocks: \ic{storage} and \ic{Store}, by using the namespace
definition annotations. By creating a hierarchy of these names, Spoofax creates
URIs: the URI for \ic{Store} is \ic{Type://storage.Store}, and the one for
\ic{name} is \ic{Property://}\linebreak[0]\ic{storage.}\linebreak[0]\ic{Store.name}. URIs are represented internally
as lists of terms, that start with the namespace, followed by a reverse
hierarchy of the path names:
\begin{code}
[Property(), "name", "Store", "storage"]
\end{code}

The reverse order used in the representation makes it easier to efficiently
store and manipulate URIs in memory: every tail of such a list
can share the same memory space. In most cases, path parts are
simple strings, such as \ic{"Store"}, but they can be complex terms if needed.

Some language elements define \emph{anonymous} blocks and do not have a name
associated with them. Block statements in C-like languages are an example of
this. These scopes are handled differently from named scopes. We can add a block
statement to our grammar by adding the following production:

\begin{code}
"{" Stm* "}" -> Stm {"Block", Scope(Var)}
\end{code}

The block statement does not define a definition name, but can still become part
of a URI. Instead of a name, that part will then have the form \ic{Anon(n)}
where \ic{n} is a generated number that identifies the block. \ic{Anon(n)} is anexample of a complex term.

URIs can be inspected using the default hover help popups, or using the analyzed
syntax view. The analyzed syntax view shows the abstract syntax with all URIs as
annotations. Consider the following example with both named and anonymous
blocks:

\begin{code}
module banking

entity BankAccount {
  name   : String
  number : Num
  
  function toCapitals() : String {
    { // anonymous block
      var result = name.toUpperCase();
      return result;
    } 
  }
}
\end{code}

The analyzed abstract syntax for this example is the following:

\begin{code}
Module(
  "banking"{[Module(),"banking"]},
  [ Entity(
      "BankAccount"{[Type(),"BankAccount","banking"]},
      [ Property(
          "name"{[Property(),"name","BankAccount","banking"]},
          "String"{[Type(),"String","mobl"]}
        ),
        Property(
          "number"{[Property(),"number","BankAccount","banking"]},
          "Num"{[Type(),"Num","mobl"]}
        ),
        Function(
          "toCapitals"{[Function(),"toCapitals","BankAccount","banking"]},
          [],
          "String"{[Type(),"String","mobl"]},
          Block([
            Declare(
              "result"{[Var(),"result",Anon(125),"toCapitals","BankAccount","banking"]},
              MethodCall(..., ...{[Function(),"toUpperCase","String","mobl"]})
            ),
            Return(
              Var("result"{[Var(),"result",Anon(125),"toCapitals","BankAccount","banking"]})
            )
          ])
        )
      ]
    )
  ]
) 
\end{code}

The annotations indicate the URIs of each definition and reference.
They can be used to get an unrefined view of all URIs at a glance, but
also have a role in transformations on abstract syntax, as we discuss later.

Any references that cannot be resolved are annotated with a special
\ic{Unresolved} constructor. For example, a variable \ic{nonexistent} could be
represented as
\ic{Var("nonexistent"\curlies{[Unresolved(Var()),"non\-existent",...]})}. This
makes it easy to recognize any unresolved references in analyses or
transformations.


\subsection{Persistence of Naming Information}
\label{Sec:spoofax-index}

Spoofax stores all definitions and references in an in-memory data structure
called the index. It can also store information about definitions, such as type
information, as we show in the next chapter. By collecting all this summary
information about files in a project together, it ensures fast access to global
information. The index is updated automatically with changes to the file system
(e.g., files being deleted or removed) and is persisted as Eclipse exits.
All entries in the index have a URI as we showed previously. Index entries can be
represented in the ATerm format\MV{I think you never said what the ATerm format
is}
\LK{it's in the AST section now, along with an explanation what we mean by "term"}
For example, \icb{Def([}\ic{Module(),"banking"])} is a
definition entry for a banking module. In the form of terms, they can be used in
the same way as abstract syntax tree fragments in transformations and analyses.
\Chapter{ch:constraints} shows how the index can be used for such tasks.

Internally, index entries are stored in tables for efficient random access. They
also contain meta-data such as the file name and line number of the definition.
With this meta-data, Spoofax can provide editor services such as reference resolving.
Note that there is no requirement
that file names correspond to the URIs: a \ic{banking.Bank} entity could be
defined in any file, as long as there are no constraints in the language that
prevent that.

%\ic{Use([Type(),"string","mobl"],[Property(),"Property(),"name","BankAccount","banking"])}
%is a reference from the \ic{BankAccount.name} property to
%the \ic{mobl.string} type.


\subsection{The Default Name Resolution Strategy}

The structure of URIs forms the basis of the default name resolution strategy of
Spoofax. The default strategy can be customized, but we first take a closer look
at how name resolution works just based on the annotations in the grammar.
Consider the \ic{address} property in the \ic{Store} entity:

\begin{code}
module storage

entity Store {
  name    : String
  address : Address
}
\end{code}

The \ic{address} property references something named \ic{Address}. According to
the grammar, that something lives in the \ic{Type} namespace. Spoofax resolves
this name by looking at the context: is there an \ic{Address} in
\icb{Type://}\ic{storage.Store}? If not, it will keep trying the parent URI:
\ic{Type://storage} and finally \ic{Type://}. If it is successful in finding it
this way, it can resolve the reference, otherwise it displays an error marker in
the editor.
The default resolution strategy makes is designed
to be generic and makes few assumptions about a specific language.
Spoofax expects language designers to \emph{manage by exception}.
By default, it does not care about file boundaries: if an \ic{Address} is defined in a
different file, it will still find it. There is also no default constraint for
duplicate names: two definitions of \ic{Address} are fine. 
Lastly, the default strategy knows nothing about import definitions for
a specific language, as these can vary quite a bit among languages.
%However, Spoofax allows customization of the default strategy and the addition
%of constraints to address these matters.

%\subsection{Customizing the Name Resolution Strategy}

Spoofax provides support for adding constraints 
and for customization of the behavior of the default resolution strategy
by means of \emph{rewrite rules}.
Rewrite rules are functions that operate on terms,
transforming one term to another.
We give a primer on rewrite rules next,
and show how they can be used to customize name resolution.
%In the next chapter, we show how rewrite rules
%can be used to specify more sophisticated customizations,
%constraints, and type systems using rewrite rules.

%\TODO{show rules for handling imports here.
%can't really show anything else interesting without types.}

%unifying Var and Property namespace?
%
%
%When needed, the path elements that are created for a scope can be customized
%using a rewrite rule:
%
%\begin{code}
%adjust-index-path(is-def | namespace, path, prefix):
%  Entity(name, body) -> [Entity(), name]
%\end{code}
%
%\MV{What is a rewrite rule? Why do you want to rewrite the scopes?}
%%
%
%
%\begin{code}
%adjust-index-path(target | namespace, path, prefix):
%  Var(<target>) -> 
%\end{code}

\subsection{Rewrite Rules}
\label{Sec:rewrite-rules}

Rewrite rules in Spoofax are provided as  part of the Stratego program
transformation language.
%
A basic rewrite rule that transforms a term pattern \ic{term1}
to a term pattern \ic{term2} has the following form:

\begin{code}
rule-name:
  term1 -> term2
\end{code}

Term patterns have the same form as terms: any term is a legal term pattern.
In addition to the basic constructors, string literals, integer literals, and so on,
they also support variables (e.g., \ic{v} or \ic{name}) and wildcards (indicated by \ic{\_}).
%
As an example, the following rewrite rule rewrites an \ic{Entity} to
the list of properties contained in that entity:

\begin{code}
get-properties-types:
  Entity(name, properties) -> properties
\end{code}

So, for an entity \ic{Entity("User", [Property("name", String)])}, it binds
\ic{"User"} to the variable \ic{name}, and \icb{[Property(}\ic{"name", "String")]}
to the variable \ic{properties}. It then returns \ic{properties}.

While rewrite rules can be viewed as functions, they have one important difference:
they can be defined multiple times for different patterns. In the case of \ic{get-properties},
we could add another definition that works for property access expressions:

\begin{code}
get-properties:
  FieldAccess(expr, property) -> property
\end{code} 

Rules can have complex patterns. For example, it is possible
to write a rule that succeeds only for entities with just a \ic{name} property:

\begin{code}
is-name-only-entity:
  Entity(_, [Property("name", "String")]) -> True()
\end{code}

Note how this rule uses a wildcard since it doesn't care about the name of the entity.

%\MV{If this is important enough to
%mention, then please also show an example or explain how it is important}
%As we will show next, they can also have conditions and perform
%arbitrary computations.
%When a rule is defined multiple times, the first one that matches simply "wins". 
%\MV{"the first one" in which order?} 

Rewrite rules can be invoked using the syntax \ic{<rule-name> term}. For example,
\ic{<get-properties> Entity("Unit", [])} would return an empty
list of properties. The pointy brackets make it easy to distinguish
rule invocations from terms, and makes it possible to use invocations in
term expressions.

Stratego provides a \ic{with} clause that can be used
for additional code that should be considered for rewrite rules.
The \ic{with} clause is most commonly used for assignments and
calls to other rules. As an example, we can write the rule above
using a \ic{with}:

\begin{code}
invoke-get-properties:
  Entity(name, properties) -> result
  with
    result := <get-properties> Entity(name, properties)
\end{code}

This rule assigns the value of \ic{get-properties} to a variable \ic{result}
and returns that as the result value of the rule.

Rules can also have conditions. These can be specified using \ic{where}.
If the pattern of a rule does not match, or if its conditions do not succeed,
a rule is said to \emph{fail}. These clauses typically use the operators listed
in \Figure{Fig:stratego-operators}.
%
An example of a rule with a \ic{where} clause
is the following:

\begin{code}
has-properties:
  Entity(name, properties) -> True()
  with
    properties := <get-properties> Entity(name, properties);
  where
    not(!properties => [])  
\end{code}

\begin{figure}[t]
\begin{tabular}{|l|l|}
\hline
\textbf{Expression} & \textbf{Description} \\ 
\hline
\ic{<e> t} & Applies \ic{e} to \ic{t}, or fails if \ic{e} is unsuccessful. \\
\ic{v := t} & Assign a term expression \ic{t} to a variable \ic{v}. \\ 
\ic{!t => p} & Match a term \ic{t} against a pattern \ic{p}, or fail. \\
\ic{not(e)} & Succeeds if \ic{e} does not succeed. \\
\ic{e1; e2} & Sequence: apply \ic{e1}. If it succeeds, apply \ic{e2}. \\ % Fail if either \ic{e1} or \ic{e2} fails. \\
\ic{e1 <+ e2} & Choice: apply \ic{e1}, if it fails apply {e2} instead. \\
%\ic{if e then e1 else e2 end} & If \ic{e} succeeds, then apply \ic{e1}, else \ic{e2}. \\
\hline
\end{tabular}
\caption{Operators in Stratego expressions.}
\label{Fig:stratego-operators}
\end{figure}

This rule only succeeds for entities where the condition \icb{not(}\ic{!prop\-erties => [])}
holds. That is, it succeeds as long as an entity has an empty list (indicated by \ic{[]})
of properties. Rewrite rules can have any number of \ic{where} and \ic{with} clauses,
which are evaluated in the order they appear.

Like functions or methods in other languages, rewrite rules
can have parameters. Stratego distinguishes between parameters that
pass other rules and parameters that pass terms, using a vertical
bar to separate them two separate lists. Rules that
take both rule and term parameters have a signature of the form \ic{rule(r|t)},
those with only rule parameters \ic{rule(r)}, and those with
only term parameters \ic{rule(|t)}.

The Stratego standard library provides a number of higher-order
rules, i.e.\ rules that take other rules as their argument. 
These rules are used for common operations on abstract syntax trees:
for example, \ic{map(r)} applies a rule \ic{r} to all elements
of a list:

\begin{code}
get-property-types:
  Entity(_, properties) -> types
  with
    types := <map(get-property-type)> properties

get-property-type:
  Property(_, type) -> type
\end{code}

Rules like \ic{map} specify a \emph{traversal} on a certain term
structure: they specify how a certain rule should be applied to
a term and its subterms. Rules that specify traversals are
also called \emph{strategies}. In Spoofax, strategies are used
to control traversals in constraints, transformation, and code generation.

\subsection{Customizing the Name Resolution Strategy}

%Stratego provides a standard library with a large number of useful 
%\todo{...}

To customize the name resolution strategy, Spoofax language
definitions can include \ic{adjust-index-lookup} rules.
These rules have a specific signature, and are invoked by the
name resolution strategy for each reference that 
is resolved.

As an example, consider how a reference to a local property
is resolved in mobl:

\begin{code}
entity BankAccount {
  function getNumber() : number {
    return number;
  }
  
  name   : String
  number : Num
}
\end{code}

Here, the function \ic{getNumber} references the local \ic{number} property.
The production rule we previously specified for these kinds of references
used an underscore to indicate that we would manually specify how to resolve it:

\begin{code}
_@ID -> Exp {"Var"}
\end{code}

So, we need to specify a \ic{adjust-index-lookup} rule for the variables:

\begin{code}
adjust-index-lookup(target |namespace, path, name):
  Var(<target>) -> adjusted-uris
  with
    adjusted-uris := ...
\end{code}

\TODO{complete this explanation}

Each \ic{adjust-index-lookup} rule has this exact signature:
it gets a \ic{target} rule argument, and term arguments
with the namespace, path, and name of the reference to
be resolved. On the left-hand side, it specifies what
construct it matches against: 


\begin{code}
adjust-index-lookup(target |namespace, path, prefix):
  Var(<target>) -> adjusted-uris
  with
    adjusted-uris := [[Var() | path], [Property() | path]]
\end{code}


\begin{code}
  adjust-index-lookup(target | namespace, path, prefix):
    element -> results
\end{code}



\begin{code}
  adjust-index-lookup(target |namespace, path, prefix):
    Var(<target>) -> [[Var() | path], [Property() | path]]
\end{code}


\begin{code}
"import" Module@ID -> Decl {"import"}
\end{code}

\ic{Import("customers")}

\begin{code}
  adjust-index-lookup(target |namespace, path, prefix): 
    Type(<target>) -> <concat> [primitives, [[Type() | path]], importPaths]
    with
      importPaths := <filter(import-to-path)> <index-get-all-in-file(|Import)> <index-get-current-file>;
      primitives := <map(type-of; type-to-def)> <primitive-types>
    
  import-to-path:
    Def([Import(), EntityImport(mod, ent)|_]) -> Def([Type(), ent, mod])
\end{code}



%\todo{show rules for handling imports here.
%can't really show anything else interesting without types.}

%unifying Var and Property namespace?
%
%
%When needed, the path elements that are created for a scope can be customized
%using a rewrite rule:
%
%\begin{code}
%adjust-index-path(is-def | namespace, path, prefix):
%  Entity(name, body) -> [Entity(), name]
%\end{code}
%
%\MV{What is a rewrite rule? Why do you want to rewrite the scopes?}
%%
%
%
%\begin{code}
%adjust-index-path(target | namespace, path, prefix):
%  Var(<target>) -> 
%\end{code}


To customize the name resolution strategy, rewrite rules can be used
to rewrite rewrite a reference to their definition.
If there is no rewrite rule defined for
a reference, then the default resolution strategy is used.

(...)

order of scopes, duplicates (no need to be unique), unresolved references:

\section{Scoping in Xtext}

Xtext uses Java code (in the future probably Xtend2 code) for implementing all
aspects of languages except the grammar. Language developers implement various
classes to build the language beyond the grammar. Xtext framework and custom
language implementation classes are contributed to the runtime using Google
Guice, a dependency injection framework. A lot of functionality is provided
out-of-the-box with minimal configuration, but it's easy to swap out specific
parts by binding another or a custom class through Guice.

\subsection{Simple, Local Scopes}

To implement scopes, language developers have to contribute a class that
implements the \ic{IScopeProvider} interface. It has one method that returns an
\ic{IScope} for a given reference. An \ic{IScope} is basically a collection of
candidate reference targets, together with the textual representation by which
these may be referenced from the current reference site (the same target may be
referenced by different text strings from different program locations). The
method takes the \ic{EReference} (which identifies the reference for which the
scope that needs to be calculated) as well as the current
instance of the language concept whose reference should be scoped.


\begin{code}
public interface IScopeProvider {
	IScope getScope(EObject context, EReference reference);
}
\end{code}


To make scoping implementation easier, Xtext provides so-called declarative
scope providers through the \ic{AbstractDeclarativeScopeProvider} base class:
instead of having to inspect the \ic{EReference} and context objects manually to
decide how to compute the scope, the language implementor can express this
information via the name of the method (using a naming convention). Two
different naming conventions are available:


\begin{code}
// <X>, <R>: we are trying to scope the <R> reference of the <X> concept 
public IScope scope_<X>_<R>(<X> ctx, EReference ref );

// <X>: the language concept we are looking for
// <Y>: the concept from under which we try to look for the reference 
public IScope scope_<X>(<Y> ctx, EReference ref);
\end{code}

 
Let's assume we want to scope the \ic{targetState} reference of the
\ic{ChangeStateStatement}. Its definition in the grammar looks as follows:

\begin{code}
ChangeStateStatement:
    "state" targetState=[State];
\end{code}

We can use the following two alternative methods:

\begin{code}
public IScope scope_ChangeStateStatement_targetState
            (ChangeStateStatement ctx, EReference ref ) {
    ...            
}
            
public IScope scope_State(ChangeStateStatement ctx, EReference ref) {
    ...
}
\end{code}


The first alternative is specific for the \ic{targetState} reference of the
\ic{ChangeStateStatement}. It is invoked by the declarative scope provider only
for that reference. The second alternative is more generic. It is invoked
whenever we are trying to reference a \ic{State} (or any sub type of \ic{State})
from any reference of a \ic{ChangeStateStatement} and \emph{all its
descendants}. So we could write an even more general alternative, which scopes
the visible States from anywhere in a \ic{CoolingProgram}, independent of the actual
reference.

\begin{code}
public IScope scope_State(CoolingProgram ctx, EReference ref) {
    ...
}
\end{code}


The implementation of the scopes is simple, and relatively similar in all three
cases. We write Java code that crawls up the containment hierarchy until we
arrive at a \ic{CoolingProgram} (in the last alternative, we already have the
\ic{CoolingProgram}, so we don't need to move up the tree), and then construct
an \ic{IScope} that contains the \ic{State}s defined in that
\ic{CoolingProgram}. Here is a possible implementation:


\begin{code}
public IScope scope_ChangeStateStatement_targetState
            (ChangeStateStatement ctx, EReference ref ) {
    CoolingProgram owningProgram = Utils.ancestor( ctx, CoolingProgram.class );
    return Scopes.scopeFor(owningProgram.getStates());
}
\end{code}

The \ic{Scopes} class provides a couple of helper methods to create \ic{IScope}
objects from collections of elements. The simple \ic{scopeFor} method we use
will use the \ic{name} of the target element as the text by which it will be
referenced. So if a state is called \ic{normalCooling}, then we'd have to write
\ic{state normalCooling} in a \ic{ChangeStateStatement}. The text \ic{normalCooling}
acts as the reference - pressing \keystroke{Ctrl-F3} on that program element
will go to the referenced state.




\subsection{Nested Scopes} 

The approach to scoping shown above is suitable for simple cases, such as the
\ic{targetState} reference shown above. However, in languages with nestes blocks
a different approach is recommended. Here is an example of a program expressed in
a language with nested blocks:


\begin{code}
var int x;		
var int g;
 
function add( int x, int y ) {
    int sum = x + y;               // 1
    return sum;
}

function addAll( int es ... ) {
    int sum = 0;                 
    foreach( e in es ) { 
        sum += e;                // 2
    }
    x = sum;                     // 3
}
\end{code}


At \ic{1}, the local variable \ic{sum}, the arguments \ic{x} and \ic{y} and the
global variables \ic{x} and \ic{g} are visible, although the global variable
\ic{x} is shadowed by the argument of the same name. At \ic{2}, we can see
\ic{x}, \ic{g}, \ic{sum} and \ic{es}, but also the iterator variable \ic{e}. At
\ic{3}, \ic{x} refers to the global since it is not shadowed by a parameter or
local variable of the same name. In general, certain program elements introduce
blocks (typically statement lists surrounded by curly braces). A block can
declare new symbols. References from within these blocks can see the symbols
defined in that block, as well as all ancestor blocks. Symbols in inner blocks
typically hide symbols with the same name in outer blocks. The symbols in outer
blocks are either not accessible, or a special name has to be used, for example,
by prefixing them with some \ic{outer} keyword.

Xtext's scopes support this scenario. \ic{IScopes} can have outer scopes. If a
symbol is not found in a scope, a scope delegates to its outer scope and tries
to find the symbol there. Since inner scopes are searched first, this implements
shadowing as expected.

Also, scopes are not just collections of elements. Instead, they are maps
between a string and an element. The string is used as the reference text. By
default, the string is the same as the target element's \ic{name}. So if a
variable is called \ic{x}, it can be referenced by the string \ic{x}. However,
this reference string can be changed as a scope is defined. This can be used to
make shadowed variables visible under a different name, such as \ic{outer.x} if
it is referenced from location \ic{1}. The following is pseudo-code that implements
this behavior:


\begin{code}
// recursive method to build nested scopes
private IScope collect( StatementList ctx ) { 
    IScope outer = null
    if ( ctx is within another StatementList parent ) {
        outer = collect(parent)
    }
    IScope scope = new Scope( outer )
    for( all symbols s in ctx ) {
        scope.put( s.name, s )
        if ( outer.hasSymbolNamed( s.name ) ) {
            scope.put( "outer."+s.name, outer.getSymbolByName( s.name ) )
        }
    } 
    return scope
}

// entry method, according to naming convention 
// in declarative scope provider
public IScope scope_Symbol( StatementList ctx ) {
    return collect( ctx )
}	
\end{code}


\subsection{Global Scopes} 

There is one more aspect of scoping that needs to be discussed. Programs can be
separated into several files and references can cross file boundaries. That is,
an element in file \ic{A} can reference an element in file \ic{B}. In earlier versions of
Xtext file \ic{A} had to explicity import file \ic{B} to make the elements in \ic{B}
available as reference targets. This resulted in several problems. First, for internal
reasons, scalability was limited. Second, as a consequence of the explicit file
imports, if the referenced element was moved into another file, the import
statements in all referencing files had to be updated.

Since Xtext 1.0 both of these problems are solved using the so-called index. The
index is a data structure that stores
(\ic{String},\ic{IEObjectDescription})-pairs. The first argument is the
qualified name of the object and the second one, the \ic{IEObjectDescription},
contains information about a model element, including a URI, a kind of global
pointer that also includes the file in which the element is stored. All
references are checked against this name in the index, not against the actual
object. If the actual object has to be resolved, the URI stored in the index is
used. Only then is the respective file loaded (this is what improved
scalability; files are only loaded if a reference target is accessed, not to
check a reference for validity). The index is updated whenever a file is saved,
or a rebuild is performed. This way, if an element is moved to a different file
while keeping its qualified name (based on the logical program structure)
constant, the reference remains valid. Only the URI in the index is updated.

There are two ways to customize what gets stored in the index, and how. The
\ic{IQualifiedNameProvider} returns a qualified name for each program element. If it
returns \ic{null}, the element is not stored in the index, which means it is not
referenceble. The other way is the \ic{IDefaultResourceDescriptionStrategy} which
allows language developers to build their own \ic{IEObjectDescription} for program
elements. This is important if custom user data has to be stored in the
\ic{IEObjectDescription} for later use during scoping.

The \ic{IGlobalScopeProvider} is activated if a local scope returns \ic{null} or
no applicable methods can be found in the declarative scope provider class (or if
they return \ic{null}). The specific implementation is configured through a
Guice binding. By default, the \ic{ImportNamespacesAwareGlobalScopeProvider} is
configured, which provides the possibility to reference model elements outside
of the current file either through their (fully) qualified name or through their
unqualified name using an \ic{import} statement.  




\parhead{Polymorphic References} In the cooling language, expressions also
include references to various other entities, such as configuration parameters,
variables and hardware elements (compressors or fans defined in a different
model). All of these referenceble elements extend the \ic{SymbolDeclaration}
meta class. This means that all of them can be referenced by the single
\ic{SymbolRef} construct.
\begin{code} 
AtomicLevel returns Expression:
    ...
    ({SymbolRef} symbol=[SymbolDeclaration|QID]);
\end{code}  

The problem with this situation is that the reference itself does not encode the
kind of thing that is referenced. By looking at the reference alone we only know
that we reference some kind of symbol. This makes writing code that processes
the model cumbersome, since the target of a \ic{SymbolRef} has to be taken into
account when deciding how to treat (translate, validate) a symbol reference. A
more natural design of the language would use different reference constructs for
the different referencable elements. In this case, the reference itself is
specific to the referenced meta class, making processing much easier.

\begin{code} 
AtomicLevel returns Expression:
    ...
    ({VariableRef} var=[Variable]);
    ({ParameterRef} param=[Parameter]);
    ({HardwareBuildingBlockRef} hbb=[HardwareBuildingBlock]);
\end{code}  

However, this is not possible with Xtext, since the parser cannot distinguish
the three cases syntactically. In all three cases, the reference syntax itself
is just an \ic{ID}. Only during the linking phase could the system check which
kind of element is actually referenced, but this is too late for the parser,
which needs an unambiguous grammar. The grammar could be disambiguated by using
a different syntax for each element:

\begin{code} 
AtomicLevel returns Expression:
    ...
    ({VariableRef} "v:" var=[Variable]);
    ({ParameterRef} "p:" param=[Parameter]);
    ({HardwareBuildingBlockRef} "bb:" hbb=[HardwareBuildingBlock]);
\end{code}  

While this approach will technically work, it would lead to an awkward syntax
and is hence typically not used. The only remaining alternative is to make all
referencable elements extend \ic{SymbolDeclaration} and use a single reference
concept.





\section{Scoping in MPS}

Making references work in MPS requires several ingredients. First of all,
developers define a reference as part of the language structure. Then, an editor
is defined that determines how the referenced element is rendered at the
referencing site. We have shown this in the previous section. To determine which
instances of the referenced concept are allowed, a scoping function has to be
implemented. It simply returns a list of all the elements that are considered
valid targets for the reference, as well a an optional text string used
to represent the respective element in the code completion menu.

As we have explained above, smart references are an important ingredient to make
this work conveniently. They make sure that users can simply type the name (or
whatever else is put into the code completion menu by the language developer) of
the targeted element; once something is selected, the corresponding reference
concept is instantiated, and the selected target is set.

\parhead{Simple Scopes} As an example, we begin with the scope definition for
the target reference of the Transition concept. To recap, it is defined as:

\begin{code}
concept Transition      
  // ...                                        
  references:                           
    State target 1 specializes: <none>    
\end{code}

The scope itself is defined via the search scope constraint below. The system
provides an anonymous function \ic{search scope} that gets a number of arguments
that describe the context including the enclosing node and the referencing node.
As the signature shows, the function has to return either an \ic{ISearchScope}
or simply a sequence of nodes of type \ic{State}. The scope of the target state
is simple the set of states of the state machine that (transitively) contains
the transition. To implement this, the expression in the body of this function
crawls up the containment hierarchy until it finds a \ic{Statemachine} and then
returns its \ic{states}. The code used to express scopes can be arbitrarily 
complex and is implemented in MPS' BaseLanguge.
\begin{code}
link {target} 
  referent set handler:
    <none> 
  search scope: 
    (model, scope, referenceNode, linkTarget, enclosingNode)
    	->join(ISearchScope | sequence<node<State>>) { 
      enclosingNode.ancestor<concept = Statemachine>.states; 
    } 
  validator: 
    <default> 
  presentation : 
    <no presentation> 
;\end{code}


In addition to the search scope, language developers can provide code that
should be executed if a new reference target is set (\ic{referent set handler}),
additional validation (\ic{validator}), as well as customized
presentation in the code completion menu (\ic{presentation}).

\parhead{Nested Scopes} In a more complex, block oriented language with
nested scopes, a different implementation pattern is recommended:

\begin{itemize}
  \item All program elements that contribute elements that can be referenced
  (such as blocks, functions or methods) implement an interface \ic{IScopeProvider}.
  \item This interface provides a method \ic{getVisibleElements<concept C)} that
  returns all elements that are available in that scope. 
  \item The search scope function simply calls this method on the owning
  \ic{IScopeProvider}, passing in the concept whose instances it wants to see 
  (\ic{State} in the above example).
  \item The implementation of the method recursively calls the method on its
  owning \ic{IScopeProvider}, until there is none anymore. It also removes 
  elements that are overshadowed from the result.
\end{itemize}

\parhead{Polymorphic References} We have explained above how references work in
principle: they are real pointers to the references element. In the section on
Xtext (\todo{make sure we explain that first}) we have seen how from a given
location only one kind of reference for any given syntactic form can be
implemented. Consider the following example, where we refer to a global variable
\ic{a} and an event parameter (\ic{timestamp}) from within expressions:

\begin{code}
var int a;
var int b;

statemachine linefollower {                                                         
  in event initialized(int timestamp);
  states {                                                                
    state initializing {                                                      
      on initialized [now() - timestamp > 1000 && a > 3] -> running                                                   
    }     
    state running {
    }
  }                                                                            
}                                                                                   
\end{code}

Both references to local variables and to event parameters use the same
syntactic form: simply a text string (the name of the respective target
element). In Xtext, this has to be implemented with a single reference concept,
typically called \ic{SymbolReference}, that can reference to any kind of
\ic{Symbol}. \ic{LocalVariableDefintions} and \ic{EventParameters} would both
extend \ic{Symbol}, and scopes would make sure both kinds are visible from
within guard expressions. The problem with this approach is that the reference
itself contains no type information about what it references, it is simply a
\ic{SymbolReference}. Processing code has to inspect the type of the
referenced symbol to find out what a particular \ic{SymbolReference} actuallymeans.

In projectional editors this is done differently. To solve the example above,
one would create a \ic{LocalVariableReference} and an
\ic{EventParameterReference}. The former references variables and the latter
references event parameters. Both have an editor that simply renders the name
of the referenced element, and each of them has \ic{their own} scope definition! 
So adding new kinds of references to existing expression languages can be done
in a modular fashion, since the new reference expression comes with its own,
independent scoping rule. 

Entering the reference happens by typing the name of the referenced element (cf.
the concept of smart references introduced above). In the case where there's a
\ic{LocalVariable} and a \ic{EventParameter} of the same name, the user has to
make an explicit decision, at the time of entry (the name won't bind, and the
code completion menu requires a choice). It is important to understand that,
although the names are similar, the tool still knows which one refers to a \ic{LocalVariable} and which
one refers to a \ic{EventParameter}: upon selection from the code completion
menu, the correct reference objects are created.




%-------- Older Notes
%
%In parsing:
%  parser only produces tree
%  graph always through naming, symbol table, etc.
%  but may be built into grammar lang
%  in both cases naming is important
%  if grammar has real refs, then scoping is used 
%    to define the set of target objects
%  maybe the same obj has several names, dep on from where I refer to it
%          name shadowing, scopes as a hierarchy
%
%  challenge: multiple refs to diff things via the same ref syntax
%  seen in many languages, e.g. Java
%
%  example 1: an expression 'time.getSeconds()'; is time a local var or a field?
%
%  example 2: a name 'java.lang.System.out'; is 'out' a field? a class? a package name? an
%  inner class? the capitalization gives us a hint but is only a
%  convention. need semantic information
%
%  multiple refs to diff things problem in Xtext
%
% works in spoofax, but with the most straightforward approach
% references have the same abstract syntax (e.g., Var(x), pointing to
%  a variable or a field)
%
%In projection
%  references are real refs, based on unique IDs
%  still need scopes to define the set of valid targets   
%
%Compare proj and parser, where in parser the info in the reference has to be
%enough to resolve the uniquely named target. In proj systems, what is shown is
%irrelevant, since behind the scenes the ID is used.
